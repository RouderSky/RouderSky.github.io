<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MarkDown语法测试</title>
    <url>/posts/5df9aa96.html</url>
    <content><![CDATA[<p><a href="https://roudersky.com/">转载自</a></p>
<h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><blockquote>
<p>引用</p>
<blockquote>
<p>引用中的引用</p>
</blockquote>
</blockquote>
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<hr>
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<hr>
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<hr>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<p>这是正常的文字</p>
<p><em>斜体文本</em></p>
<p><em>斜体文本</em></p>
<p><strong>粗体文本</strong></p>
<p><strong>粗体文本</strong></p>
<p><em><strong>粗斜体文本</strong></em></p>
<p><em><strong>粗斜体文本</strong></em></p>
<p><del>这是加删除线的文字</del></p>
<p>$ \sum_{i&#x3D;1}^n a_i&#x3D;0 $</p>
<p>$$ \sum_{i&#x3D;1}^n a_i&#x3D;0 $$</p>
<p><code>int a;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>  <span class="hljs-comment">/* An annoying &quot;Hello World&quot; example */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0xFFFF</span>; i++)<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br><br>  <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  unordered_map &lt;string, vector&lt;string&gt; &gt; m;<br>  m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;\\\\&quot;</span>; <span class="hljs-comment">// this is an error</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-2e3</span> + <span class="hljs-number">12l</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code class="hljs">val s = &quot;hello Markdown&quot;
println( s )
</code></pre>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<p>$$<br>\begin{vmatrix}<br>  \frac{cot\frac{FOV}{2}}{Aspect} &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; cot\frac{FOV}{2} &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; -\frac{Far+Near}{Far-Near} &amp; -\frac{2 \cdot Near \cdot Far}{Far-Near} \<br>  0 &amp; 0 &amp; -1 &amp; 0<br>\end{vmatrix}<br>$$</p>
<ul>
<li><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029173905.png?x-oss-process=style/WaterMask" alt="20221029173905"></li>
<li><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/%E4%B8%80%E8%84%9A%E6%89%AB%E5%BC%80.gif" alt="一脚扫开"></li>
</ul>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=894986163&bvid=BV15P4y1T7nS&cid=555347982&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>]]></content>
  </entry>
  <entry>
    <title>游戏动画技术简介</title>
    <url>/posts/49a81750.html</url>
    <content><![CDATA[<p>  动画系统是游戏中对表现力影响最大的系统之一，经过一段时间的调研，最后通过这篇文章总结下游戏动画系统。</p>
<h1 id="精灵动画系统"><a href="#精灵动画系统" class="headerlink" title="精灵动画系统"></a>精灵动画系统</h1><p>  精灵动画系统在早年间计算机性能还比较差的时候被广泛运用，一般作为游戏的背景而存在，比如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029175924.png?x-oss-process=style/WaterMask" alt="极品飞车系列的路边观众"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180025.png?x-oss-process=style/WaterMask" alt="NBA2K系列的观众"><br>  这些人物都是一个四边形，游戏引擎会给四边形连续贴上纹理贴图来产生动感。通常为了不暴露这是个扁的四边形，会使这些四边形一直面向摄像机。比如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180040.png?x-oss-process=style/WaterMask" alt="DOOM"><br>  这类动画系统在早期游戏中盛行，因为当时的计算机性能不够，而该系统对计算机资源的消耗非常低。现在部分手游依然会保留这类动画系统，因为手机性能有限。</p>
<h1 id="刚性层阶式动画"><a href="#刚性层阶式动画" class="headerlink" title="刚性层阶式动画"></a>刚性层阶式动画</h1><p>  刚性层阶式动画驱动的人物都由一堆独立的刚性物体组合而成。刚性物体指的是不会发生形变(包括缩放)的物体。然后动画系统会驱动每一个刚性物体，从而实现动画效果。最经典的例子就是1997年在PS上发售的FF7。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180105.png?x-oss-process=style/WaterMask" alt="97版FF7"><br>  这个系统驱动的是3D模型，而不再是四边形贴图，同时还能保持高效的性能和较低的内存使用量。缺点是不允许网格发生形变，整个人物会显得非常生硬。而且人物的关节位置会产生明显的“裂缝”。</p>
<h1 id="每顶点动画"><a href="#每顶点动画" class="headerlink" title="每顶点动画"></a>每顶点动画</h1><p>  每顶点动画需要动画师为每个顶点去k动画。工作量非常巨大，产生的数据量也非常巨大，但是可以获得非常精细的动画效果，网格的三角形产生形变。通常用于制作CG中人物的表情，一般通过硬件设备来捕捉人脸信息，再转换成顶点数据。<br>  <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><br>    <iframe src="//player.bilibili.com/player.html?aid=859596268&bvid=BV1eV4y1g7H7&cid=875385956&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe><br>  </div><br>  <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><br>    <iframe src="//player.bilibili.com/player.html?aid=559589709&bvid=BV1Re4y127Tn&cid=875387307&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe><br>  </div></p>
<h1 id="变形目标动画-morphing-animation"><a href="#变形目标动画-morphing-animation" class="headerlink" title="变形目标动画(morphing animation)"></a>变形目标动画(morphing animation)</h1><p>  由于每顶点动画需要保存大量的动画数据，不方便存储和使用。于是提出了变形目标动画，动画师只需要通过调整网格上所有顶点的信息制作出一些静态姿势(morph target)。这些静态姿势都是一些“极端”的姿势，例如生气、开心等。在游戏引擎中通过对这些静态姿势按时间进行线性插值即可得到动画。</p>
<h1 id="蒙皮动画-skinened-animation"><a href="#蒙皮动画-skinened-animation" class="headerlink" title="蒙皮动画(skinened animation)"></a>蒙皮动画(skinened animation)</h1><blockquote>
<p>有时也被称为骨骼动画、蒙皮骨骼动画，是一种FK</p>
</blockquote>
<p>  为了可以得到较生动的动画效果，允许网格的三角形产生形变。同时兼顾较高的性能、较低的存储空间。蒙皮动画便出现了，现在市场上几乎所有的游戏都采用蒙皮动画作为动画解决方案。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>  在蒙皮动画中有几个重要的概念。首先是骨骼(skeleton)，骨骼由关节通过一棵树的形态组织起来。如果是一个人物模型，一般以髋部为根节点，以肢体末端为叶节点，比如手指、脚指、眼睛等。skeleton本身不需要被渲染引擎渲染出来，仅由动画系统驱动。</p>
<p>  然后是皮肤(skin)，皮肤由多边形网格组成。而网格又由顶点构成，这些顶点将会被动画师通过设置权重绑定(bind)到若干关节上。一般每个顶点最多绑定4个关节。但不是所有的关节都会被顶点绑定，这些没有被绑定的关节又称为定位器(locator)，作为其它模型的挂接点存在。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180348.png?x-oss-process=style/WaterMask" alt="DX中skeleton的组织方式"><br>  蒙皮动画中存在几个重要的姿势(pose)，这些姿势可以矩阵或者SQT格式来保存。首先是绑定姿势，又称为T-pose，顾名思义，是动画师在给模型顶点做绑定时用的姿势。该姿势从DCC中输出之后就固定好了，在游戏运行时不会被改变。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180400.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180408.png?x-oss-process=style/WaterMask"><br>  然后是局部姿势，它保存了当前关节在其父关节空间中的姿势。因为动画引擎直接驱动的是局部姿势，我们经常需要对局部姿势进行各种插值，所以一般不会存储为矩阵形式，而是存储为SQT形式。我们的动画片段就是由一连串的局部姿势组合起来，也就是说动画片段是一个因变量为局部姿势，自变量为时间的函数。</p>
<p>  最后是全局姿势，它保存了关节在其模型空间或世界空间中的姿势，具体保存形式不同的引擎有不同的做法。它是在游戏运行过程中通过联合具有父子关系的局部姿势实时生成的，算是被动画引擎间接驱动。</p>
<h2 id="蒙皮-skinning"><a href="#蒙皮-skinning" class="headerlink" title="蒙皮(skinning)"></a>蒙皮(skinning)</h2><p>  首先需要准备数据，每一个关节都保存着一个绑定姿势逆矩阵，以下简称IBP，该矩阵可以将物体从模型空间转换到当前关节空间。IBP是在3D模型从DCC输出后，利用T-Pose计算出来的。一次计算，无限次使用。</p>
<p>  动画引擎Update之后，每一个关节都会得到一个最新的局部姿势。这个时候可以进行一些额外的插值计算、程序式动画、IK等后处理过程。因为局部姿势一般保存为SQT格式，所以需要在这时转换成矩阵。</p>
<p>  然后我们开始计算每个关节的全局姿势矩阵，计算方法是依次连接关节本身及其所有父节点的局部姿势矩阵。</p>
<p>  最后IBP乘上全局姿势矩阵，就得到了蒙皮矩阵。顶点乘上蒙皮矩阵后会对顶点产生什么样的影响呢？可以这么想象：顶点原本位于模型为T-Pose时的模型空间中，乘上了IBP之后进入到关节空间中；再乘上全局姿势矩阵，这时模型摆出了由动画引擎驱动的姿势，在这个姿势下从关节空间回到模型空间。</p>
<p>  所以最终呈现的效果是，顶点被关节带到了特定位置。计算出所有关节的蒙皮矩阵之后，我们就得到了矩阵调色</p>
<p>  然后开始正式蒙皮。每个顶点都会从矩阵调色板中取得需要绑定的关节的蒙皮矩阵，然后更具动画师设定好的权重对这些矩阵进行混合。顶点乘上混合后的矩阵，这时蒙皮就完成了。</p>
<p>  ps：动画引擎Update时，可以通过多种方式计算出局部姿势。可以对单个动画片段进行一维线性插值实现时间性混合来得到常规的动画效果。可以对两个动画片段进行淡入&#x2F;淡出计算获得圆滑过渡、冻结过渡等过渡效果。更进一步推广，可以对多个动画片段进行N维线性插值实现自定义的混合。为了充分利用资源，可以对动画片段进行分部混合或加法混合，例如人物在Idle状态时，通过加法混合给人物加入一些小动作，使得人物更真实。例如…<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-14d7181792c45287b55129c0856b82ff_720w.gif"></p>
]]></content>
      <categories>
        <category>游戏引擎从入门到入土</category>
      </categories>
  </entry>
  <entry>
    <title>漫谈Entity-Component-System</title>
    <url>/posts/1abc5785.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>  对于很多人来说，ECS只是一个可以提升性能的架构，但是我觉得ECS更强大的地方在于可以降低代码复杂度。</p>
<p>  在游戏项目开发的过程中，一般会使用OOP的设计方式让GameObject处理自身的业务，然后框架去管理GameObject的集合。但是使用OOP的思想进行框架设计的难点在于一开始就要构建出一个清晰类层次结构。而且在开发过程中需要改动类层次结构的可能性非常大，越到开发后期对类层次结构的改动就会越困难。</p>
<p>  经过一段时间的开发，总会在某个时间点开始引入多重继承。实现一个又可工作、又易理解、又易维护的多重继承类层次结构的难度通常超过其得益。因此多数游戏工作室禁止或严格限制在类层次结构中使用多重继承。若非要使用多重继承，要求一个类只能多重继承一些 简单且无父类的类(min-in class)，例如Shape和Animator。</p>
<p>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029194540.png?x-oss-process=style/WaterMask"></p>
<p>  也就是说在大型游戏项目中，OOP并不适用于框架设计。但是也不用完全抛弃OOP，只是在很大程度上，代码中的类不再具体地对应现实世界中的具体物件，ECS中类的语义变得更加抽象了。</p>
<p>  ECS有一个很重要的思想：数据都放在一边，需要的时候就去用，不需要的时候不要动。ECS 的本质就是数据和操作分离。传统OOP思想常常会面临一种情况，A打了B，那么到底是A主动打了B还是B被A打了，这个函数该放在哪里。但是ECS不用纠结这个问题，数据存放到Component种，逻辑直接由System接管。借着这个思想，我们可以大幅度减少函数调用的层次，进而缩短数据流传递的深度。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>  Entity由多个Component组成，Component由数据组成，System由逻辑组成。</p>
<h2 id="Component-组件"><a href="#Component-组件" class="headerlink" title="Component(组件)"></a>Component(组件)</h2><p>  Component是数据的集合，只有变量，没有函数，但可以有getter和setter函数。Component之间不可以直接通信。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">Component</span>&#123;<br>	<span class="hljs-comment">//子类将会有大量变量，以供System利用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Entity-实体"><a href="#Entity-实体" class="headerlink" title="Entity(实体)"></a>Entity(实体)</h2><p>  Entity用来代表游戏世界中任意类型的游戏对象，宏观上Entity是一个Component实例的集合，且拥有一个全局唯一的EntityID，用于标识Entity本身。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Entity</span>&#123;<br>	Int32 ID;<br>	List&lt;Component&gt; components;<br>        <span class="hljs-comment">//通过观察者模式将自己注册到System可以提升System遍历的速度，因为只需要遍历已经注册的entity</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>  Entity需要遵循立即创建和延迟销毁原则，销毁放在帧末执行。因为可能会出现这样的情况：systemA提出要在entityA所在位置创建一个特效，然后systemB认为需要销毁entityA。如果systemB直接销毁了entityA，那么稍后FxSystem就会拿不到entityA的位置导致特效播放失败（你可能会问为什么不直接把entityA的位置记录下来，这样就不会有问题了。这里只是简单举个例子，不要太深究(●’◡’●)）。理想的表现效果应该是，播放特效后消失。</p>
<h2 id="System-系统"><a href="#System-系统" class="headerlink" title="System(系统)"></a>System(系统)</h2><p>  System用来制定游戏的运行规则，只有函数，没有变量。System之间的执行顺序需要严格制定。System之间不可以直接通信。</p>
<p>  一个 System只关心某一个固定的Component组合，这个组合集合称为tuple。</p>
<p>  各个System的Update顺序要根据具体情况设置好，System在Update时都会遍历所有的Entity，如果一个Entity拥有该System的tuple中指定的所有Component实例，则对该Entity进行处理。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">System</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ASystem</span>:<span class="hljs-title">System</span>&#123;<br>    Tuple tuple;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>        <span class="hljs-keyword">for</span>(Entity entity <span class="hljs-keyword">in</span> World.entitys)&#123;<br>            <span class="hljs-keyword">if</span>(entity.components中有tuple指定的所有Component实例)&#123;<br>                <span class="hljs-comment">//do something for Components</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>  一个Component会被不同System区别对待，因为每个System用到的数据可能只有其中一部分，且不一定相同。</p>
<h2 id="World-世界"><a href="#World-世界" class="headerlink" title="World(世界)"></a>World(世界)</h2><p>  World代表整个游戏世界，游戏会视情况来创建一个或两个World。通常情况下只有一个，但是守望先锋为了做死亡回放，有两个World，分别是liveGame和replyGame。World下面会包含所有的System实例和Entity实例。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">World</span>&#123;<br>    List&lt;System&gt; systems;                   <span class="hljs-comment">//所有System</span><br>    <span class="hljs-built_in">dictionary<span class="hljs-keyword">&lt;Int32, Entity&gt;</span></span> entitys;      <span class="hljs-comment">//所有Entity，Int32是Entity.ID</span><br><br>    <span class="hljs-comment">//由引擎帧循环驱动</span><br>    <span class="hljs-built_in">void</span> Update()&#123;<br>        <span class="hljs-keyword">for</span>(System sys <span class="hljs-keyword">in</span> systems)<br>            sys.Update();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  由ECS架构出来的游戏世界就像是一个数据库表，每个Entity对应一行，每个Component对应一列，打了✔代表Entity拥有Component。</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">Component1</th>
<th align="center">Component2</th>
<th align="center">…</th>
<th align="center">ComponentN</th>
</tr>
</thead>
<tbody><tr>
<td>EntityId1</td>
<td align="center"></td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>EntityId2</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">✔</td>
</tr>
<tr>
<td>…</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>EntityIdN</td>
<td align="center">✔</td>
<td align="center">✔</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="单例Component"><a href="#单例Component" class="headerlink" title="单例Component"></a>单例Component</h2><p>  在定义一个Component时最好先搞清楚它的数据是System数据还是Entity数据。如果是System的数据，一般设计成单例Component。例如存放玩家键盘输入的 Component ，全局只需要一个，很多 System 都需要去读这个唯一的 Component 中的数据。<br>  单例Component顾名思义就是只有一个实例的Component，它只能用来存储某些System状态。单例Component在整个架构中的占比通常会很高，据说在守望先锋中占比高达40%。其实换一个角度来看，单例Component可以看成是只有一个Component的匿名Entity单例，但可以通过GetSingletonIns接口来直接访问，而不用通过EntityID。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>  守望先锋种有一个根据输入状态来决定是不是要把长期不产生输入的对象踢下线的AFKSystem，该System需要对象同时具备连接Component、输入Component等，然后AFKSystem遍历所有符合要求的对象，根据最近输入事件产生的时间，把长期没有输入事件的对象通知下线。</p>
<h1 id="设计需要遵循的原则"><a href="#设计需要遵循的原则" class="headerlink" title="设计需要遵循的原则"></a>设计需要遵循的原则</h1><ol>
<li>设计并不是从Entity开始的，而是应该从System抽象出Component，最后组装到Entity中。</li>
<li>设计的过程中尽量确保每个System都依赖很多Component去运行，也就是说System和Component并不是一对一的关系，而是一对多的关系。所以xxxCOM不一定有xxxSys，xxxSys不一定有xxxCOM。<ul>
<li>System和Component的划分很难在一开始就确定好，一般都是在实现的过程中看情况一步一步地去划分System和Component。而且最终划分出来的System和Component一般都是比较抽象的，也就是说通常不会对应现实世界中的具体物件，可以参考下图守望先锋System和Component划分的例子。<br><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029195909.png?x-oss-process=style/WaterMask" alt="20221029195909"></li>
</ul>
</li>
<li>System尽量不改变Component的数据。<ul>
<li>可以读数据完成的功能就不要写数据来完成。因为写数据会影响到使用了这些数据的模块，如果对于其它模块不熟悉的话，就会产生Bug。如果只是读数据来增加功能的话，即使出Bug也只局限于新功能中，而不会影响其它模块。这样容易管理复杂度，而且给并行处理留下了优化空间。</li>
</ul>
</li>
</ol>
<h1 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h1><p>  我在一个游戏demo里尝试使用ECS去进行设计，最大的感受是所有游戏逻辑都变得那么的合理，应对改动、扩展也变得那么的轻松。加班变少了，也不再焦虑。在开始使用ECS来架构业务层之前，我对ECS还是存有一丝疑虑的。担心会不会因为规矩太多了，导致有些功能写不出来。中途也确实因为ECS的种种规矩，导致有些功能不好写出来，需要用到一些奇技淫巧，剑走偏锋。但这些技术最终造就了一个可持续维护的、解耦合的、简洁易读的代码系统。据说守望团队在将整个游戏转成ECS之前也不确定ECS是不是真的好使。现在他们说ECS可以管理快速增长的代码复杂性，也是事后诸葛亮。</p>
<p>  引擎层的System比较好定义，因为引擎相关层级划分比较明确。但是游戏业务逻辑层可能会出现各种奇奇怪怪的System，因为业务层的需求千变万化，有时没有办法划分出一个对应具体业务的System。例如我曾经在业务层定义过DamageHitSystem、PointForceSys。</p>
<p>  推迟技术：不是非常必要马上执行的内容可以推迟到合适的时再执行，这样可以将副作用集中到一处，易于做优化。例如游戏可能会在某个瞬间产生大量的贴花，利用延迟技术可以将这些需要产生的贴花数据保存下来，稍后可以将部分重叠的贴花删除，再依据性能情况分到多个帧中去创建，可以有效平滑性能毛刺。</p>
<p>  如果不知道该如何去划分System，而导致System之间一定要相互通信才能完成功能，可以通过将数据放在中的一个队列里延迟处理。比如SystemA在执行Update的时候，需要执行SystemB中的逻辑。但是这个时候还没轮到SystemB执行Update，只能先将需要执行的内容保存到一个地方。但是System本身又没有数据，所以SystemA只好将需要执行的内容保存到单例Component中的一个队列里，等轮到SystemB执行Update的时候再从队列里拿出数据来执行逻辑。</p>
<p>  但是System之间通过单例Component有个缺点。如果向单例Component中添加太多需要延迟处理的数据，一旦出现bug就不好查了。因为这类数据是一段时间之前添加进来的，到后面才出问题的话，不好定位是何处、何时、基于什么情况添加进来的。解决方案是给每一条需要延迟处理的数据加上调用堆栈信息、时间戳、一个用于描述为什么添加进来的字符串。</p>
<p>  各个System都用到的公共函数可以定义在全局，也可以作为对应System的静态函数，这类函数叫做Utility函数。Utility函数涉及的Component最好尽可能少，不然需要作为参数传进函数Component会很多，导致函数调用不太雅观。Utility函数最好是无副作用的，即不对Component的数据做任何写操作，只读取数据，最后返回计算结果。要改Component的数据的话，也要交给System来改。</p>
<p>  函数调用堆栈的层次变浅了，因为逻辑被摊开到各个System，而System之间又禁止直接访问。代码变得扁平化，扁平化意味的函数封装少了，所以阅读、修改、扩展也很轻松。</p>
<p>  如果可以把整个游戏世界都抽象成数据，存档&#x2F;读档功能的实现也变得容易了。存档时只需要将所有Component数据保存下来，读档时只需要将所有Component数据加载进来，然后System照常运行。想想就觉得强大，这就是DOP的魅力。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>  模式简单</p>
<p>  结构清晰</p>
<p>  通过组合高度复用。用组合代替继承，可以像拼积木一样将任意Component组装到任意Entity中。</p>
<p>  扩展性强。Component和System可以随意增删。因为Component之间不可以直接访问，System之间也不可以直接访问，也就是说Component之间不存在耦合，System之间也不存在耦合。System和Component在设计原则上也不存在耦合。对于System来说，Component只是放在一边的数据，Component提供的数据足够就update，数据不够就不update。所以随时增删任意Component和System都不会导致游戏崩溃报错。</p>
<p>  天然与DOP(data-oriented processing)亲和。数据都被统一存放到各种各样的Component中，System直接对这些数据进行处理。函数调用堆栈深度大幅度降低，流程被弱化。</p>
<p>  易优化性能。因为数据都被统一存放到Component中，所以如果能够在内存中以合理的方式将所有Component聚合到连续的内存中，这样可以大幅度提升cpu cache命中率。cpu cache命中良好的情况下，Entity的遍历速度可以提升50倍，游戏对象越多，性能提升越明显。ECS的这项特性给大部分人留下了深刻印象，但是大部分人也认为这就是ECS的全部。我觉得可能是被Unity的官方演示带歪的。</p>
<p>  易实现多线程。由于System之间不可以直接访问，已经完全解耦，所以理论上可以为每个System分配一个线程来运行。需要注意的是，部分System的执行顺序需要严格制定，为这部分System分配线程时需要注意一下执行先后顺序。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>  在充满限制的情况下写代码，有时速度会慢一些。但是习惯之后，后期开发速度会越来越快。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>  一个entity就是一个ID，所有组成这个entity的component将会被这个ID给标记。因为不用创建entity类，可以降低内存的消耗。如果通过以下方式来组织架构，还可以提升cpu cache命中率。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//数组下标代表entity的ID</span><br><span class="hljs-selector-tag">ComponentA</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentAs</span>;<br><span class="hljs-selector-tag">ComponentB</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentBs</span>;<br><span class="hljs-selector-tag">ComponentC</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentCs</span>;<br><span class="hljs-selector-tag">ComponentD</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentDs</span>;<br>...<br></code></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://gameinstitute.qq.com/community/detail/114516">《守望先锋》架构设计与网络同步 – GDC2017 精品分享实录</a></li>
<li><a href="http://gamadu.com/artemis/">http://gamadu.com/artemis/</a></li>
<li><a href="http://gameprogrammingpatterns.com/component.html">http://gameprogrammingpatterns.com/component.html</a></li>
<li><a href="http://t-machine.org/index.php/2014/03/08/data-structures-for-entity-systems-contiguous-memory/">http://t-machine.org/index.php/2014/03/08/data-structures-for-entity-systems-contiguous-memory/</a></li>
<li><a href="http://blog.lmorchard.com/2013/11/27/entity-component-system/">http://blog.lmorchard.com/2013/11/27/entity-component-system/</a> </li>
<li><a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html">浅谈《守望先锋》中的 ECS 构架</a></li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>技术美术的职责</title>
    <url>/posts/dd4c3610.html</url>
    <content><![CDATA[<h1 id="何为技术美术"><a href="#何为技术美术" class="headerlink" title="何为技术美术"></a>何为技术美术</h1><p>  技术美术(Technical Artist, TA)主要职责是作为美术师和程序员之间沟通合作的桥梁。因此TA需要同时兼备编码能力和美术能力，门槛较高，所以身价一般也比较高。前段时间原神的大火，进一步提升了TA的身价。TA是一个复合型工种，所以不同TA的能力侧重点会不一样。TA大致可以再细分为两种类型。一种偏向技术，驻扎在游戏引擎组。一种偏向美术，驻扎在美术支持组。</p>
<p>  其实还可以继续细分的。比如</p>
<p>  效果TA，主要负责实现具体的美术效果，比如人物描边、火焰效果、水流效果、运动模糊。</p>
<p>  流程TA，主要负责各种资源的导出工作，例如全局光照烘焙流程、场景分块导出流程等。</p>
<p>  优化TA主要负责性能优化工作，比如遮挡剔除的实现、具体效果的性能优化。</p>
<p>  引擎TA主要负责游戏引擎整体渲染效果的把控，定制渲染管线，所以需要对引擎非常熟悉，并且能够对团队进行引擎相关的培训。</p>
<p>  资产TA，需要整理、维护项目的资源，比如制定性能指标、资源检查。</p>
<p>  相比于客户端程序，TA跟美术的沟通更加的紧密和频繁，TA需要主动去跟美术进行沟通，不要期待美术会及时反馈问题。</p>
<h1 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h1><p>  TA最重要的工作就是实现具体的美术效果，例如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234443.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234451.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234515.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234522.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234544.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234610.png?x-oss-process=style/WaterMask"><br>  一般来说，实现一个美术效果分为4个阶段，方案确定、技术预研、效果实现、生产跟进。</p>
<p>  TA在拿到一个具体的美术效果需求时，需要针对这个需求选择合适的实现方案。为了找到合适的方案，首先需要用技术语言将需求表达出来。然后对竞品进行分析，推测对方使用了什么技术来实现该效果。再去学习与实现技术相关的资料，可以到书籍、SIGGRAPH等地方找到需要的内容。最后针对之前的工作内容整理输出一份文档，发起一次会议和相关人员对齐之后的工作内容。</p>
<p>  方案确定之后，TA就可以尝试在项目生产环境下对效果进行初步的实现，输出一个demo。这个过程中不需要太关注代码架构的合理性和性能问题，尽可能快就好。如果过程中使用的美术素材需要使用比较特殊的方式进行制作，就自己动手制作，不要麻烦美术。因为这个实现方案可能并不是最终的实现方案，这时让美术去学习新的制作方法性价比不高。等这个方案真的成为了最终方案时，再推广新的制作方法。但是常规的素材还是需要积极找美术配合输出的。</p>
<p>  在整个过程中需要习惯性地将自己想法和问题记录到文档上，可以作为备忘录，也方便之后进行技术分享。demo出来之后，可以开会跟相关人员对实现出来的效果进行讨论，确定最终是否采纳该方案。</p>
<p>  如果demo的效果不ok，则需要重新选择实现方案。否则将继续往前推进，这时就进入到了方案实现阶段，这个阶段主要是将demo的效果落地到项目生产环境中。在这个过程中需要依据项目规范重构demo的实现代码。如果存在较明显的性能消耗，则需要开展性能优化工作。开发特殊素材的制作工具并进行优化。输出美术制作文档，配合给出样例素材。如果有必要，则对美术进行基本的生产培训。之后还可以定期给团队成员进行技术分享，确保大家对引擎技术有着一致的认知。</p>
<p>  在方案正式投入生产线使用时，TA需要积极主动跟美术进行交流，确保他们在制作过程没有被问题卡住，保证开发流程通畅。效果的跟进不可以交给QA来进行，QA只负责提出异常效果，表现力需要TA亲自跟进。多向美术收集素材制作工具的使用体验，及时对工具进行改良。</p>
<h1 id="在各研发阶段中的具体工作职责"><a href="#在各研发阶段中的具体工作职责" class="headerlink" title="在各研发阶段中的具体工作职责"></a>在各研发阶段中的具体工作职责</h1><p>  在项目研发的不同阶段，TA的工作侧重点会有所不同。</p>
<p>  在项目启动阶段，TA需要配合美术同学给出可供我们项目参考的美术风格，并针对特定的效果进行技术评估，确定效果是否能实现。除了仿制出其它项目的效果之外，TA还需要为项目增加自己的特色，提升项目的市场竞争力。</p>
<p>  在项目Demo制作阶段，TA就需要开始实现具体效果了，可参考上文。</p>
<p>  在项目立项阶段，主要对效果表现力和性能进行优化。</p>
<p>  在中期阶段，TA需要对资产进行良好地分类、维护、升级，因为资产会逐渐变得庞大。控制好资产大小，确保被打包的资产不多也不少。为了更合理地管理好资产，需要输出一定的规范文档，并依据必要的规范实现自动资源检查。还需要关注性能表现，针对性能消耗较大的效果进行优化，如果无法优化，可以考虑直接毙掉该效果。这时还需要开始考虑上线后可能会面临的问题，针对这些问题给出解决方案。</p>
<p>  在内测阶段，需要及时解决运行环境中出现的性能问题、兼容性问题、效果表现力问题。</p>
<p>  项目上线后，可以对之前工作结果进行总结和分享，沉淀下来，为新的项目做准备。</p>
]]></content>
      <categories>
        <category>游戏开发碎碎念</category>
      </categories>
  </entry>
  <entry>
    <title>GUI开发那点事</title>
    <url>/posts/6d38ce7b.html</url>
    <content><![CDATA[<p>  每个项目组的GUI开发流程都不太相同。有些项目组的流程非常落后，基本没有框架设计，都是直接代码设置UI控件，不利于迭代。做的比较好的会采用MVC相关模式进行设计，下面也只讲使用了MVC的工作流程。C由客户端同学负责实现。V由GUI同学进行制作。M和V的连接工作在理想的情况下应该也是由GUI同学进行设置，但是因为上手有些难度，没有很好地落地，所以这块最终由客户端同学进行设置。</p>
<p>  总体来看，GUI开发流程分为以下几个阶段。</p>
<p>  策划会先提出界面需求，客户端程序需要认真阅读需求文档，确保需求是完整。因为我之前遇到过策划给出不完整的需求文档，需求前后矛盾、需求细节丢失、需求模糊不清。有一次特别离谱，商城需求文档竟然不给出具体的数值设计。在需求不完整的情况下就开始做功能的工作效率是很低的，需要一边做一边问策划，有时候一个问题要半天时间策划才能给答复。</p>
<p>  千万不要在需求不完整的情况下展开后面的工作，跟策划和PM提了之后没有理会就提多几次。一定要让策划和PM重视前期规划工作，不然后面就会变成策划想到什么就做什么，想到一点内容就加一点内容进入，加到最后发现和前面的东西有点矛盾，又删除前面的内容。这会带来不必要的时间浪费，在极端情况下可能要推翻重来。</p>
<p>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-91346abb1a400b9a78d80e3cd3fe4401_b.gif"></p>
<p>  需求明确之后就由GUI同学输出效果图。</p>
<p>  等策划确认效果之后，客户端同学也要来看一下效果图。看看有没有比较奇怪的效果，对这些效果进行讨论，确定实现方案或者换效果。如果界面比较复杂，需要跟GUI同学对一下层级结构。</p>
<p>  进行界面资源输出。一般来说，界面资源输出工作交给GUI同学来负责，但是有些项目会将这个工作交给客户端同学。曾经待过的一个项目组就是这么干的，需要将一张半透的效果图叠在界面最上层，一点一点的拼出来。有时一个界面可以拼一天，眼睛要爆炸，我都不知道我是程序还是GUI了。无论是由谁来输出，都需要注意一下UI控件的命名，不要使用a、b、c、1、2、3之类的名字。最好可以表达出这个UI控件的类型、作用，比如LoginBtn代表这是个按钮，点击之后开始登录。</p>
<p>  客户端同学拿到界面资源之后，首先需要做的事情是检查UI控件摆放的层级结构是否合理。层级结构可以按照区域或者功能模块来划分，这么做的好处是可以快速定位到自己想要的UI控件，之后做UI资源迭代会轻松很多。一般一个界面的UI控件量都不会很少，即使开头很少，随着功能、效果的迭代优化也会变得越来越多。如果没有处理好UI控件摆放的层级结构，做资源迭代时寻找资源会让你怀疑人生的。</p>
<p>  UI界面资源处理好之后，就可以开始进行数据绑定工作了。这个过程需要将V和M关联起来，一般都会提供可视化编辑工具，不需要写代码。所以这项工作其实GUI同学也可以做的。但是因为数据绑定需要对业务需求有更深入的理解，大部分GUI同学都会觉得这不是他们应该做的内容，他们应该只负责输出好看的、满足功能需求的界面。</p>
<p>  如果可以由GUI同学来负责设置的话，客户端程序可以同步开始写业务逻辑代码，生产速度会更快。但是这要做好前期沟通的工作，确保大家对数据的认知是保持一致的，这个沟通的工作可能也要花费时间。综合来看，这项工作还是交给客户端程序来处理会比较好。</p>
<p>  客户端程序这个时候就可以开始写逻辑代码了。这里需要遵守一个原则，既然都使用了MVC框架，就不允许通过通过代码直接操作UI控件，只允许修改UI控件对应的绑定数据。在实现功能的过程中一般也不可以在修改UI界面的样式。如果非要修改，在改动比较小的情况下可以客户端程序自己改一下，然后让GUI同学过来确认下。如果改动比较大，就直接交给GUI同学进行修改。</p>
<p>  GUI开发工作整体难度不大，只要积极沟通就好。一般来说，如果开发时间超出预期，大部分都是因为开发过程中出现了莫名奇妙的Bug，由UI框架设计引起。针对这种情况，如果容易修复的bug可以直接进行修复。比较难修复的bug可以记录到一个专门的文档中。方便别人遇到同样的问题时可以快速找到解决方案，提升整体的开发效率，也作为之后修复bug的checklist。</p>
]]></content>
  </entry>
</search>
