<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GUI开发那点事</title>
    <url>/posts/6d38ce7b.html</url>
    <content><![CDATA[<p>每个项目组的GUI开发流程都不太相同。有些项目组的流程非常落后，基本没有框架设计，都是直接代码设置UI控件，不利于迭代。做的比较好的会采用MVC相关模式进行设计，下面也只讲使用了MVC的工作流程。C由客户端同学负责实现。V由GUI同学进行制作。M和V的连接工作在理想的情况下应该也是由GUI同学进行设置，但是因为上手有些难度，没有很好地落地，所以这块最终由客户端同学进行设置。</p>
<p>总体来看，GUI开发流程分为以下几个阶段。</p>
<p>策划会先提出界面需求，客户端程序需要认真阅读需求文档，确保需求是完整。因为我之前遇到过策划给出不完整的需求文档，需求前后矛盾、需求细节丢失、需求模糊不清。有一次特别离谱，商城需求文档竟然不给出具体的数值设计。在需求不完整的情况下就开始做功能的工作效率是很低的，需要一边做一边问策划，有时候一个问题要半天时间策划才能给答复。</p>
<p>千万不要在需求不完整的情况下展开后面的工作，跟策划和PM提了之后没有理会就提多几次。一定要让策划和PM重视前期规划工作，不然后面就会变成策划想到什么就做什么，想到一点内容就加一点内容进入，加到最后发现和前面的东西有点矛盾，又删除前面的内容。这会带来不必要的时间浪费，在极端情况下可能要推翻重来。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-91346abb1a400b9a78d80e3cd3fe4401_b.gif" /></p>
<p>需求明确之后就由GUI同学输出效果图。</p>
<p>等策划确认效果之后，客户端同学也要来看一下效果图。看看有没有比较奇怪的效果，对这些效果进行讨论，确定实现方案或者换效果。如果界面比较复杂，需要跟GUI同学对一下层级结构。</p>
<p>进行界面资源输出。一般来说，界面资源输出工作交给GUI同学来负责，但是有些项目会将这个工作交给客户端同学。曾经待过的一个项目组就是这么干的，需要将一张半透的效果图叠在界面最上层，一点一点的拼出来。有时一个界面可以拼一天，眼睛要爆炸，我都不知道我是程序还是GUI了。无论是由谁来输出，都需要注意一下UI控件的命名，不要使用a、b、c、1、2、3之类的名字。最好可以表达出这个UI控件的类型、作用，比如LoginBtn代表这是个按钮，点击之后开始登录。</p>
<p>客户端同学拿到界面资源之后，首先需要做的事情是检查UI控件摆放的层级结构是否合理。层级结构可以按照区域或者功能模块来划分，这么做的好处是可以快速定位到自己想要的UI控件，之后做UI资源迭代会轻松很多。一般一个界面的UI控件量都不会很少，即使开头很少，随着功能、效果的迭代优化也会变得越来越多。如果没有处理好UI控件摆放的层级结构，做资源迭代时寻找资源会让你怀疑人生的。</p>
<p>UI界面资源处理好之后，就可以开始进行数据绑定工作了。这个过程需要将V和M关联起来，一般都会提供可视化编辑工具，不需要写代码。所以这项工作其实GUI同学也可以做的。但是因为数据绑定需要对业务需求有更深入的理解，大部分GUI同学都会觉得这不是他们应该做的内容，他们应该只负责输出好看的、满足功能需求的界面。</p>
<p>如果可以由GUI同学来负责设置的话，客户端程序可以同步开始写业务逻辑代码，生产速度会更快。但是这要做好前期沟通的工作，确保大家对数据的认知是保持一致的，这个沟通的工作可能也要花费时间。综合来看，这项工作还是交给客户端程序来处理会比较好。</p>
<p>客户端程序这个时候就可以开始写逻辑代码了。这里需要遵守一个原则，既然都使用了MVC框架，就不允许通过通过代码直接操作UI控件，只允许修改UI控件对应的绑定数据。在实现功能的过程中一般也不可以在修改UI界面的样式。如果非要修改，在改动比较小的情况下可以客户端程序自己改一下，然后让GUI同学过来确认下。如果改动比较大，就直接交给GUI同学进行修改。</p>
<p>GUI开发工作整体难度不大，只要积极沟通就好。一般来说，如果开发时间超出预期，大部分都是因为开发过程中出现了莫名奇妙的Bug，由UI框架设计引起。针对这种情况，如果容易修复的bug可以直接进行修复。比较难修复的bug可以记录到一个专门的文档中。方便别人遇到同样的问题时可以快速找到解决方案，提升整体的开发效率，也作为之后修复bug的checklist。</p>
]]></content>
      <categories>
        <category>游戏开发碎碎念</category>
      </categories>
  </entry>
  <entry>
    <title>MarkDown语法测试</title>
    <url>/posts/5df9aa96.html</url>
    <content><![CDATA[<p><a href="https://roudersky.com/">转载自</a></p>
<h1 id="h1">h1</h1>
<h2 id="h2">h2</h2>
<h3 id="h3">h3</h3>
<h4 id="h4">h4</h4>
<h5 id="h5">h5</h5>
<blockquote>
<p>引用 &gt;引用中的引用</p>
</blockquote>
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<hr />
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<hr />
<ul>
<li>无序列表</li>
<li>无序列表</li>
<li>无序列表</li>
</ul>
<hr />
<ol type="1">
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<p>这是正常的文字</p>
<p><em>斜体文本</em></p>
<p><em>斜体文本</em></p>
<p><strong>粗体文本</strong></p>
<p><strong>粗体文本</strong></p>
<p><strong><em>粗斜体文本</em></strong></p>
<p><strong><em>粗斜体文本</em></strong></p>
<p><del>这是加删除线的文字</del></p>
<p>$ _{i=1}^n a_i=0 $</p>
<p><span class="math display">\[ \sum_{i=1}^n a_i=0 \]</span></p>
<p><code>int a;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>  <span class="hljs-comment">/* An annoying &quot;Hello World&quot; example */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0xFFFF</span>; i++)<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br><br>  <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  unordered_map &lt;string, vector&lt;string&gt; &gt; m;<br>  m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;\\\\&quot;</span>; <span class="hljs-comment">// this is an error</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-2e3</span> + <span class="hljs-number">12l</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs">val s = &quot;hello Markdown&quot;
println( s )</code></pre>
<table>
<thead>
<tr class="header">
<th>姓名</th>
<th style="text-align: center;">技能</th>
<th style="text-align: right;">排行</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>刘备</td>
<td style="text-align: center;">哭</td>
<td style="text-align: right;">大哥</td>
</tr>
<tr class="even">
<td>关羽</td>
<td style="text-align: center;">打</td>
<td style="text-align: right;">二哥</td>
</tr>
<tr class="odd">
<td>张飞</td>
<td style="text-align: center;">骂</td>
<td style="text-align: right;">三弟</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th>姓名</th>
<th style="text-align: center;">技能</th>
<th style="text-align: right;">排行</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>刘备</td>
<td style="text-align: center;">哭</td>
<td style="text-align: right;">大哥</td>
</tr>
<tr class="even">
<td>关羽</td>
<td style="text-align: center;">打</td>
<td style="text-align: right;">二哥</td>
</tr>
<tr class="odd">
<td>张飞</td>
<td style="text-align: center;">骂</td>
<td style="text-align: right;">三弟</td>
</tr>
</tbody>
</table>
<p><span class="math display">\[
\begin{vmatrix}
  \frac{cot\frac{FOV}{2}}{Aspect} &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; cot\frac{FOV}{2} &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; -\frac{Far+Near}{Far-Near} &amp; -\frac{2 \cdot Near
\cdot Far}{Far-Near} \\
  0 &amp; 0 &amp; -1 &amp; 0
\end{vmatrix}
\]</span></p>
<ul>
<li><figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029173905.png?x-oss-process=style/WaterMask"
alt="20221029173905" />
<figcaption aria-hidden="true">20221029173905</figcaption>
</figure></li>
<li><figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/一脚扫开.gif"
alt="一脚扫开" />
<figcaption aria-hidden="true">一脚扫开</figcaption>
</figure></li>
</ul>
<div
style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<pre><code class="hljs">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=894986163&amp;bvid=BV15P4y1T7nS&amp;cid=555347982&amp;page=1&amp;high_quality=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;</code></pre>
</div>
]]></content>
  </entry>
  <entry>
    <title>可编程渲染管线(Scriptable Render Pipeline, SRP)</title>
    <url>/posts/e35daff.html</url>
    <content><![CDATA[<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105002824.png?x-oss-process=style/WaterMask" /></p>
<p>可编程渲染管线处理数据的流程可分为以下3大阶段</p>
<h1 id="应用阶段">1. 应用阶段</h1>
<p>这个阶段大概会由CPU处理4件事情。首先会对模型数据进行可见性判断。模型数据由顶点位置、法线方向、顶点颜色、纹理坐标等构成。然后会将模型数据加载到显存以提高读取速度。再为每个图元设置常数寄存器和渲染状态。最后为一个渲染图元列表调用DrawCall指令。</p>
<p>图元可以是点、线、三角形。</p>
<h1 id="几何阶段">2. 几何阶段</h1>
<p>这个阶段由GPU进行处理，会对每一个需要渲染的图元进行逐顶点、逐多边形处理，最根本的任务是将顶点的模型坐标转换到屏幕空间。</p>
<h2 id="顶点着色器">2.1 顶点着色器</h2>
<p>顶点着色器的基本任务是将顶点转换到齐次裁剪空间，还可以进行的其他任务有：
- 逐顶点着色操作，如逐顶点光照 - 纹理计算 - 逐顶点蒙皮 -
逐顶点程序式动画(procedural animation)</p>
<p><strong>2.1.1 投影变换</strong></p>
<p><span
class="math display">\[Aspect=\frac{近裁剪平面宽度}{近裁剪平面高度}=\frac{远裁剪平面宽度}{远裁剪平面高度}\]</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011112.png) -->
<p><strong>透视投影</strong></p>
<p>在摄像机使用透视投影的时候，为了呈现出近大远小的透视收缩(perspective
foreshortening)效果，需要对顶点进行透视投影变换。使用透视投影矩阵进行变换后，并没有进行裁剪，只是使得w值有了意义，为后面的裁剪做准备。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105001504.png?x-oss-process=style/WaterMask" /></p>
<p><span class="math inline">\(透视投影近裁剪平面高度=2 \cdot Near \cdot
tan\frac{FOV}{2}\)</span></p>
<p><span class="math inline">\(透视投影远裁剪平面高度=2 \cdot Far \cdot
tan\frac{FOV}{2}\)</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011200.png) -->
<p>Unity透视投影矩阵(右乘)</p>
<p><span class="math display">\[
\begin{vmatrix}
  \frac{cot\frac{FOV}{2}}{Aspect} &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; cot\frac{FOV}{2} &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; -\frac{Far+Near}{Far-Near} &amp; -\frac{2 \cdot Near
\cdot Far}{Far-Near} \\
  0 &amp; 0 &amp; -1 &amp; 0
\end{vmatrix}
\]</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011212.png) -->
<p>会改变空间手系，从右手系变成了左手系，因为Unity的观察空间是右手系，NDC空间是左手系</p>
<p>观察空间中的顶点(x,y,z)透视投影到齐次裁剪空间后变为</p>
<p><span class="math display">\[(x \cdot
\frac{cot\frac{FOV}{2}}{Aspect}, y \cdot cot\frac{FOV}{2}, -z \cdot
\frac{Far+Near}{Far-Near}-\frac{2 \cdot Near \cdot Far}{Far-Near},
-z)\]</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011223.png) -->
<p>透视投影齐次裁剪空间中坐标的w值为 <span
class="math inline">\(-Z_{posInViewSpace}\)</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011717.png) -->
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105001658.png?x-oss-process=style/WaterMask"
alt="变换情况" />
<figcaption aria-hidden="true">变换情况</figcaption>
</figure>
<p><strong>正交投影</strong></p>
<p><span class="math display">\[正交投影远(近)裁剪平面高度=2 \cdot
Size\]</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011245.png) -->
<p>Unity正交投影矩阵(右乘)</p>
<p><span class="math display">\[
\begin{vmatrix}
    \frac{1}{Aspect \cdot Size} &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \frac{1}{Size} &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; -\frac{2}{Far-Near} &amp; -\frac{Far+Near}{Far-Near}
\\
    0 &amp; 0 &amp; 0 &amp; 1 \\
\end{vmatrix}
\]</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011253.png) -->
<p>会改变空间手系，从右手系变成了左手系，因为Unity的观察空间是右手系，NDC空间是左手系</p>
<p>观察空间种的顶点(x,y,z)正交投影到齐次裁剪空间后变为 <span
class="math inline">\((\frac{x}{Aspect \cdot Size}, \frac{y}{Size},
-\frac{2z}{Far-Near}-\frac{Far+Near}{Far-Near}, 1)\)</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011307.png) -->
<p>正交投影齐次裁剪空间中坐标的w值为1</p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105001921.png) -->
<h2 id="曲面细分着色器">2.2 曲面细分着色器</h2>
<p>用于细分图元</p>
<h2 id="几何着色器">2.3 几何着色器</h2>
<ul>
<li>几何着色器的功能是修改、剔除、创建图元，可以实现以下效果：
<ul>
<li>阴影体积拉伸(shadow volume extrusion)</li>
<li>渲染立方体贴图(cube map)的6个面</li>
<li>在网格的轮廓边拉伸毛发的鳍(fur in)</li>
<li>从点数据生成例子四边形</li>
<li>动态镶嵌</li>
<li>把线段分形细分(fractal subdivision)以模拟闪电、布料</li>
<li>将数据传到管线开头重新进入管线
<ul>
<li>用例：在顶点着色器内对头发样条的控制点进行物理模拟，在几何着色器内把样条镶嵌成线段，通过流输出将线段传到管线开头重新进入管线进行渲染</li>
</ul></li>
</ul></li>
</ul>
<h2 id="裁剪">2.4 裁剪</h2>
<p>裁剪的作用是将每个三角形在平截头体以外的部分切掉，把在平截头体以外的三角形剔除。</p>
<p>满足以下条件的顶点才会被保留下来：</p>
<p><span class="math display">\[-w&lt;=x&lt;=w\]</span> <span
class="math display">\[-w&lt;=y&lt;=w\]</span> <span
class="math display">\[-w&lt;=z&lt;=w\]</span></p>
<!-- ![](https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105011331.png) -->
<h2 id="齐次除法">2.5 齐次除法</h2>
<p>所谓的齐次除法就是让x、y、z都除以w，这时就可以得到NDC空间中的坐标</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/透视投影的齐次除法.png?x-oss-process=style/WaterMask"
alt="透视投影的齐次除法" />
<figcaption aria-hidden="true">透视投影的齐次除法</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/正交投影的齐次除法.png?x-oss-process=style/WaterMask"
alt="正交投影的齐次除法" />
<figcaption aria-hidden="true">正交投影的齐次除法</figcaption>
</figure>
<p>上图右边都是OpenGL的NDC，DirectX的NDC也和上图右边类似，但z范围在[0,1]</p>
<h2 id="屏幕映射">2.6屏幕映射</h2>
<p>视口空间：程序运行窗口构成的空间</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/屏幕空间：整个显示屏幕构成的空间.png?x-oss-process=style/WaterMask"
alt="屏幕空间：整个显示屏幕构成的空间" />
<figcaption
aria-hidden="true">屏幕空间：整个显示屏幕构成的空间</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/Unity中将NDC坐标转换为屏幕坐标的右乘矩阵.png?x-oss-process=style/WaterMask"
alt="Unity中将NDC坐标转换为屏幕坐标的右乘矩阵" />
<figcaption
aria-hidden="true">Unity中将NDC坐标转换为屏幕坐标的右乘矩阵</figcaption>
</figure>
<p>矩阵中的X、Y是视口空间原点的屏幕坐标</p>
<h1 id="光栅化阶段">3. 光栅化阶段</h1>
<p>这个阶段由GPU来决定绘制哪些片元以及这些片元的颜色</p>
<p>片元=片段：三角形被栅格化后，其中的每一个小方块都是一个片元，可以看成是还不确定最终是否可以呈现到屏幕上的像素</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221105002226.png?x-oss-process=style/WaterMask" /></p>
<h2 id="三角形设置">3.1 三角形设置</h2>
<p>这个阶段的任务是找出三角形边界所覆盖的像素</p>
<h2 id="三角形遍历">3.2 三角形遍历</h2>
<p>这个阶段会对每个三角形进行栅格化，即找出每个三角形覆盖的像素区域。区域中的片元中信息（屏幕坐标、深度值、法线坐标、纹理坐标）由3个顶点数据进行插值(必要时会采用透视校正插值)得到</p>
<h2 id="提前深度测试">3.3 提前深度测试</h2>
<p>如果用户没有在片元着色器中改变深度或自我丢弃(discard)，显卡会自动开启该功能</p>
<h2 id="片元着色器">3.4 片元着色器</h2>
<p>用于执行逐像素着色操作，如纹理采样、多重纹理采样、逐像素光照</p>
<h2 id="逐片元操作">3.5 逐片元操作</h2>
<p><strong>3.5.1 模板测试</strong> <figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">if 开启了模板测试 then<br>    比较参考值(使用读取掩码)和模板缓冲区中的模板值(使用读取掩码)<br>    if not 通过模板测试 then<br>        舍弃该片元<br>    end<br>    根据已设置的渲染状态更新模板缓冲区中的值(使用写入掩码)<br>end<br></code></pre></td></tr></table></figure> <strong>3.5.2
深度测试</strong> <figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">if</span> 开启了深度测试 <span class="hljs-keyword">then</span><br>    比较该片元的深度值和深度缓冲区中的深度值<br>    <span class="hljs-keyword">if</span> 通过了深度测试 <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">if</span> 开启了深度写入 <span class="hljs-keyword">then</span><br>            将深度值写入深度缓冲区<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        舍弃该片元<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">if</span> 开启了深度写入 <span class="hljs-keyword">then</span><br>        将深度值写入深度缓冲区<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure> <strong>3.5.3 混合</strong>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">if</span> 开启了混合 <span class="hljs-keyword">then</span><br>    用alpha混合函数(alpha blending <span class="hljs-keyword">function</span>)将该片元的颜色值和颜色缓冲区中的颜色值进行混合<br><span class="hljs-keyword">else</span><br>    直接使用该片元的颜色值<br><span class="hljs-keyword">end</span><br>更新颜色缓冲区中的颜色值<br></code></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>图形渲染</category>
      </categories>
  </entry>
  <entry>
    <title>工作多年之后回顾经典排序算法</title>
    <url>/posts/1f3756ac.html</url>
    <content><![CDATA[<p>排序都要做的事情是比较和交换</p>
<p>稳定排序：排序前后，两个相等的元素在其序列中的前后位置顺序相同</p>
<p>这里只有插入排序和归并排序是稳定排序</p>
<p>以下示例均假设我们要从小到大进行排序</p>
<h1 id="选择排序">选择排序</h1>
<blockquote>
<p>非稳定排序</p>
<p>排序效率和输入无关</p>
</blockquote>
<p>选择排序的基本步骤：先找出最小元素放到0号位置，再找出次小元素放到1号位置，再找出次次小元素放到2号位置，以此类推</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221103235237.png?x-oss-process=style/WaterMask"
alt="排序过程中的数据变化" />
<figcaption aria-hidden="true">排序过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-2bdd6b162c403d376c56c02e8a5560af_720w.gif"
alt="排序过程图形化" />
<figcaption aria-hidden="true">排序过程图形化</figcaption>
</figure>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#ifndef __SELECTIONSORT_H__</span><br><span class="hljs-meta">#define __SELECTIONSORT_H__</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Selection</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">//选择排序</span><br>  <span class="hljs-keyword">void</span> Sort(<span class="hljs-built_in">char</span> *a, <span class="hljs-built_in">int</span> length)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">index</span> &lt; length - <span class="hljs-number">1</span>; ++<span class="hljs-keyword">index</span>)<br>    &#123;<br>      <span class="hljs-comment">//找出从当前位置index开始到后面所有元素中最小元素的下标</span><br>      <span class="hljs-built_in">int</span> indexOfCurMin = <span class="hljs-keyword">index</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>; i &lt; length; ++i)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &lt; a[indexOfCurMin])<br>        indexOfCurMin = i;<br>      &#125;<br><br>      <span class="hljs-comment">//将找到的最小元素和index位置上的元素进行交换</span><br>      <span class="hljs-built_in">int</span> temp = a[<span class="hljs-keyword">index</span>];<br>      a[<span class="hljs-keyword">index</span>] = a[indexOfCurMin];<br>      a[indexOfCurMin] = temp;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-meta">#endif</span><br></code></pre></td></tr></table></figure>
<h2 id="特性">特性</h2>
<p>该算法的优点是对输入数据的移动次数最少。缺点是运行效率低，无法处理大规模的数据
## 性能分析 使用该算法对n个元素进行排序时</p>
<p>时间复杂度为O(n^2)，需要对元素进行n(n-1)/2次比较以及n-1次交换。值得注意的是，元素交换次数与元素个数成线性关系，这是其它排序算法都没有的</p>
<p>空间复杂度为0</p>
<h1 id="插入排序">插入排序</h1>
<blockquote>
<p>稳定排序</p>
<p>排序效率和输入有关，当待排序的元素越有序（倒置很少）时，该算法可能比其它任何算法都要快</p>
</blockquote>
<p>插入排序的基本步骤：每一次都将一个未排序的元素插入到已经排好序的数组中</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221103235443.png?x-oss-process=style/WaterMask"
alt="排序过程中的数据变化" />
<figcaption aria-hidden="true">排序过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-33306ddf0943d2a9b0d748e21a098909_720w.gif"
alt="排序过程图形化" />
<figcaption aria-hidden="true">排序过程图形化</figcaption>
</figure>
<h2 id="代码实现-1">代码实现</h2>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#ifndef __INSERTIONSOER_H__</span><br><span class="hljs-meta">#define __INSERTIONSOER_H__</span><br><br><span class="hljs-comment">//插入排序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Insertion</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">void</span> Sort1_0(<span class="hljs-built_in">char</span> *a, <span class="hljs-built_in">int</span> length)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">1</span>; <span class="hljs-keyword">index</span> &lt; length; ++<span class="hljs-keyword">index</span>)<br>    &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-keyword">index</span>; i &gt; <span class="hljs-number">0</span>; --i)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &lt; a[i - <span class="hljs-number">1</span>])<br>        &#123;<br>          <span class="hljs-built_in">char</span> temp = a[i];<br>          a[i] = a[i - <span class="hljs-number">1</span>];<br>          a[i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>        <span class="hljs-comment">//else</span><br>        <span class="hljs-comment">//  break;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">//优化版本</span><br>  <span class="hljs-keyword">void</span> Sort2_0(<span class="hljs-built_in">char</span> *a, <span class="hljs-built_in">int</span> length)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">1</span>; <span class="hljs-keyword">index</span> &lt; length; ++<span class="hljs-keyword">index</span>)<br>    &#123;<br>      <span class="hljs-built_in">char</span> needToInsert = a[<span class="hljs-keyword">index</span>];<br>    <br>      <span class="hljs-built_in">int</span> i;<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; needToInsert &lt; a[i]; --i)<br>        a[i + <span class="hljs-number">1</span>] = a[i];  <span class="hljs-comment">//右移</span><br>    <br>      a[i + <span class="hljs-number">1</span>] = needToInsert;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-meta">#endif</span><br></code></pre></td></tr></table></figure>
<h2 id="特性-1">特性</h2>
<p>这里需要补充两个概念</p>
<p>倒置：两个待排序元素的排列顺序与目标顺序相反</p>
<p>部分有序：如果元素倒置的数量小于元素个数的某个倍数时，那么就说这些待排序元素是部分有序的</p>
<p>该算法缺点是运行效率低，无法处理大规模的数据</p>
<p>插入排序和冒泡排序很像，冒泡排序的算法如下：从未排序元素的第一对直到最后一对，如果第一个元素比第二个元素大就交换，重复这个步骤直到所有元素都排序完成</p>
<h2 id="性能分析">性能分析</h2>
<p>使用该算法对n个元素进行排序时</p>
<p>时间复杂度在最坏的情况下为O(n<sup>2)，最好的情况为O(n)，所以平均为O(n</sup>2)。元素间的比较次数大于等于倒置数，小于等于倒置数+数组大小-1，在最坏的情况下为n(n-1)/2次，最好的情况下为n-1次。元素间进行交换的次数等于倒置数，在最坏的情况下为n(n-1)/2次，最好的情况下为0次</p>
<p>空间复杂度为0</p>
<h1 id="希尔排序">希尔排序</h1>
<blockquote>
<p>非稳定排序</p>
<p>排序效率是否输入有关取决于第二步使用的排序算法是否输入有关</p>
</blockquote>
<p>希尔排序的基本步骤： 1. 确定h的初值 1.
每次循环都使数组中任意间隔为h的元素都是有序的（这样的数组称为h有序数组）
1. 每次循环结束，h都要递减一次，直到h等于1</p>
<p>ps：h的递减方式是多种多样的，不同的递减方式决定了希尔排序算法的效率，目前还没有研究出最好的递减序列</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/递减序列的一个例子.png?x-oss-process=style/WaterMask"
alt="递减序列的一个例子" />
<figcaption aria-hidden="true">递减序列的一个例子</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/排序过程图形化.gif"
alt="排序过程图形化" />
<figcaption aria-hidden="true">排序过程图形化</figcaption>
</figure>
<h2 id="代码实现-2">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//基于插入排序的希尔排序算法</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __SHELLSORT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SHELLSORT_H__</span><br><br><span class="hljs-comment">//希尔排序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//1.0版本</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort1_0</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">//确定h的最大值</span><br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>)<br>      h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;    <span class="hljs-comment">//1,4,13,40,121,364,1093，...</span><br>  <br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>)  <span class="hljs-comment">//间隔控制</span><br>    &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h; ++i)  <span class="hljs-comment">//每个子数组的头</span><br>      &#123;<br>        <span class="hljs-comment">//对每个子数组进行插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + h; j &lt; length; j += h)<br>        &#123;<br>          <span class="hljs-type">char</span> needToInsert = a[j];<br>          <span class="hljs-type">int</span> k;<br>          <span class="hljs-keyword">for</span> (k = j - h; j &gt;= i&amp;&amp;needToInsert &lt; a[k]; k -= h)<br>            a[k + h] = a[k];<br>      <br>          a[k + h] = needToInsert;<br>        &#125;<br>      &#125;<br>    <br>      h /= <span class="hljs-number">3</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">//2.0版本</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort2_0</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">//确定h的最大值</span><br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>)<br>      h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;    <span class="hljs-comment">//1,4,13,40,121,364,1093，...</span><br>  <br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>)<br>    &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h; i &lt; length; ++i)    <span class="hljs-comment">//从所有子数组的第二元素开始到最后的元素，妙</span><br>      &#123;<br>        <span class="hljs-comment">//在i元素所属的子数组内对i元素进行插入排序</span><br>        <span class="hljs-type">char</span> needToInsert = a[i];<br>        <span class="hljs-type">int</span> j;<br>        <span class="hljs-keyword">for</span> (j = i - h; j &gt;= <span class="hljs-number">0</span> &amp;&amp; needToInsert &lt; a[j]; j -= h)<br>          a[j + h] = a[j];<br>    <br>        a[j + h] = needToInsert;<br>      &#125;<br>    <br>      h /= <span class="hljs-number">3</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<h2 id="特性-2">特性</h2>
<p>该算法的优点是可以处理大规模的数据，适用于大部分场合，其它更复杂优秀的排序算法最多比该算法快2倍。缺点是无法处理超大规模的数据</p>
<h2 id="性能分析-1">性能分析</h2>
<p>使用该算法对n个元素进行排序时</p>
<p>时间复杂度目前在数学上是未知的</p>
<p>空间复杂度为0</p>
<h1 id="归并排序">归并排序</h1>
<blockquote>
<p>稳定排序</p>
<p>排序效率与输入无关</p>
</blockquote>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/归并效果.png?x-oss-process=style/WaterMask"
alt="归并效果" />
<figcaption aria-hidden="true">归并效果</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/归并过程中的数据变化.png?x-oss-process=style/WaterMask"
alt="归并过程中的数据变化" />
<figcaption aria-hidden="true">归并过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/自顶向下的排序过程中的数据变化.png?x-oss-process=style/WaterMask"
alt="自顶向下的排序过程中的数据变化" />
<figcaption
aria-hidden="true">自顶向下的排序过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/自顶向下的排序过程图形化.gif"
alt="自顶向下的排序过程图形化" />
<figcaption aria-hidden="true">自顶向下的排序过程图形化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/自底向上的排序过程中的数据变化.png?x-oss-process=style/WaterMask"
alt="自底向上的排序过程中的数据变化" />
<figcaption
aria-hidden="true">自底向上的排序过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/自底向上的排序过程图形化.png?x-oss-process=style/WaterMask"
alt="自底向上的排序过程图形化" />
<figcaption aria-hidden="true">自底向上的排序过程图形化</figcaption>
</figure>
<h2 id="代码实现-3">代码实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MERGESORT_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MERGESORT_H__</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  <span class="hljs-comment">/* NULL */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">/* min */</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Merge</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">//原数组的副本,辅助空间</span><br>  <span class="hljs-type">char</span> *aux;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Merge</span>()&#123; aux = <span class="hljs-literal">NULL</span>; &#125;<br>  <br>  <span class="hljs-comment">//单次归并，将a数组的两部分已排好的子数组合并起来</span><br>  <span class="hljs-comment">//mid代表左边子数组的最后一个元素下标</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i)<br>      aux[i] = a[i];<br>  <br>    <span class="hljs-type">int</span> idxOfLeft = left;<br>    <span class="hljs-type">int</span> idxOfRight = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//开始归并</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (idxOfLeft &gt; mid&amp;&amp;idxOfRight &lt;= right)<br>        a[i] = aux[idxOfRight++];<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idxOfLeft &lt;= mid&amp;&amp;idxOfRight &gt; right)<br>        a[i] = aux[idxOfLeft++];<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aux[idxOfLeft] &lt; aux[idxOfRight])<br>        a[i] = aux[idxOfLeft++];<br>      <span class="hljs-keyword">else</span><br>        a[i] = aux[idxOfRight++];<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">//自顶向下的递归归并排序</span><br>  <span class="hljs-comment">//这个函数还可以优化，如果left和right之间的插值小到一定的程度，就不用再递归了；直接用插入排序、希尔排序或者选择排序，速度可以提升；其中插入排序可以缩短10%~15%</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SortCore</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right)        <span class="hljs-comment">//可以改成==</span><br>      <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>      <span class="hljs-built_in">SortCore</span>(a, left, mid);<br>      <span class="hljs-built_in">SortCore</span>(a, mid + <span class="hljs-number">1</span>, right);<br>      <span class="hljs-built_in">merge</span>(a, left, mid, right);    <span class="hljs-comment">//这条语句在执行前还可以做一个判断：如果a[mid]&lt;=a[mid+1]，这条语句可以不执行；</span><br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">//启动函数</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">//防止内存泄漏</span><br>    <span class="hljs-keyword">if</span> (aux != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">delete</span>[] aux;<br>      aux = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <br>    aux = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length];<br>    <span class="hljs-built_in">SortCore</span>(a, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>);<br>  &#125;<br>  <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeBu</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">//a数组的副本,辅助空间</span><br>  <span class="hljs-type">char</span> *aux;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MergeBu</span>()&#123; aux = <span class="hljs-literal">NULL</span>; &#125;<br>  <br>  <span class="hljs-comment">//单次归并，将a数组的两部分已排好的子数组合并起来</span><br>  <span class="hljs-comment">//mid代表左边子数组的最后一个元素下标</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i)<br>      aux[i] = a[i];<br>  <br>    <span class="hljs-type">int</span> idxOfLeft = left;<br>    <span class="hljs-type">int</span> idxOfRight = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//开始归并</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left; i &lt;= right; ++i)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (idxOfLeft &gt; mid&amp;&amp;idxOfRight &lt;= right)<br>        a[i] = aux[idxOfRight++];<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idxOfLeft &lt;= mid&amp;&amp;idxOfRight &gt; right)<br>        a[i] = aux[idxOfLeft++];<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aux[idxOfLeft] &lt; aux[idxOfRight])<br>        a[i] = aux[idxOfLeft++];<br>      <span class="hljs-keyword">else</span><br>        a[i] = aux[idxOfRight++];<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">//自底向上的归并排序</span><br>  <span class="hljs-comment">//可以给链表进行排序，而不用辅助数组</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Sort</span><span class="hljs-params">(<span class="hljs-type">char</span> *a, <span class="hljs-type">int</span> length)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">//保险</span><br>    <span class="hljs-keyword">if</span> (aux)<br>    &#123;<br>      <span class="hljs-keyword">delete</span>[] aux;<br>      aux = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <br>    aux = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[length];<br>  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> subArraySize = <span class="hljs-number">1</span>; subArraySize &lt; length; subArraySize &lt;&lt;= <span class="hljs-number">1</span>)<br>    &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; left + subArraySize &lt; length; left += (subArraySize &lt;&lt; <span class="hljs-number">1</span>))    <span class="hljs-comment">//注意这里的终止条件</span><br>        <span class="hljs-built_in">merge</span>(a, left, left + subArraySize - <span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(left + (subArraySize &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>, length - <span class="hljs-number">1</span>));<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<h2 id="特性-3">特性</h2>
<p>该算法的优点是能够处理超大规模的数据，缺点是需要O(n)大小的辅助空间</p>
<h2 id="性能分析-2">性能分析</h2>
<p>使用该算法对n个元素进行排序时</p>
<p>时间复杂度为O(nlgn)，元素间的比较次数在最坏的情况下为nlgn次，在最好的情况下为(nlgn/2)次，平均为(nlgn)(3/4)次。</p>
<p>空间复杂度为O(n)+递归辅助栈大小</p>
<h1 id="快速排序">快速排序</h1>
<blockquote>
<p>非稳定排序</p>
</blockquote>
<p>在介绍算法之前需要先了解一个操作--切分</p>
<p>切分的目标是通过调整数组将首元素(或尾元素)放到正确的位置。该位置左边的元素都小于该位置的元素，右边的元素都大于该位置的元素。切分的一个经典应用是查找数组中第k大的元素。需要注意的是，切分要在一个数组上进行各种交换操作，如果不想改变原数组的话，则需要多创建一个数组来进行辅助</p>
<p>快速排序函数的基本步骤：对数组进行切分，再对经过切分得到的两个子数组分别调用快速排序函数</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/切分效果.png?x-oss-process=style/WaterMask"
alt="切分效果" />
<figcaption aria-hidden="true">切分效果</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/切分过程中的数据变化.png?x-oss-process=style/WaterMask"
alt="切分过程中的数据变化" />
<figcaption aria-hidden="true">切分过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/排序过程中的数据变化.png?x-oss-process=style/WaterMask"
alt="排序过程中的数据变化" />
<figcaption aria-hidden="true">排序过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/排序过程图形化（每次都用当前数组中的最后一个元素进行切分）.gif"
alt="排序过程图形化（每次都用当前数组中的最后一个元素进行切分）" />
<figcaption
aria-hidden="true">排序过程图形化（每次都用当前数组中的最后一个元素进行切分）</figcaption>
</figure>
<h2 id="代码实现-4">代码实现</h2>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">#ifndef __QUICKSORT_H__<br>#define __QUICKSORT_H__<br><br><span class="hljs-keyword">class</span> Quick<br>&#123;<br>public:<br>  void <span class="hljs-constructor">Sort(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">length</span>)</span><br>  &#123;<br>    <span class="hljs-comment">//在开始递归排序前最好先打乱一下数组，防止不合理的切分；这样就不容易出现O(N^2)这种情况</span><br>    <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, 0, <span class="hljs-params">length</span> - 1)</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">//可以优化：在数组被分割得小于某个数值的时候，改用插入排序</span><br>  void <span class="hljs-constructor">SortCore(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right)<br>    &#123;<br>      return;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">int</span> j = <span class="hljs-constructor">Partition(<span class="hljs-params">a</span>, <span class="hljs-params">left</span>, <span class="hljs-params">right</span>)</span>;<br>      <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, <span class="hljs-params">left</span>, <span class="hljs-params">j</span> - 1)</span>;<br>      <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, <span class="hljs-params">j</span> + 1, <span class="hljs-params">right</span>)</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">//可以优化：选取部分元素来找出这部分元素的中位数当作基准</span><br>  <span class="hljs-comment">//可以优化（代码看quick3way）  </span><br>  <span class="hljs-built_in">int</span> <span class="hljs-constructor">Partition(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span><br>  &#123;<br>    <span class="hljs-comment">//分割标准，取了首元素来当标准</span><br>    <span class="hljs-built_in">char</span> standard = a<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>;<br><br>    <span class="hljs-built_in">int</span> i = left+<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> j = right;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-comment">//特别注意 ++i 和 --j 的位置</span><br>      <span class="hljs-comment">//注意a[i] &lt;= standard和standard &lt;= a[j]的等于号</span><br>      <span class="hljs-keyword">while</span> (i &lt;= right<span class="hljs-operator"> &amp;&amp; </span>a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= standard)&#123; ++i; &#125;      <span class="hljs-comment">//i &lt;= right可以改成i &lt; right</span><br>      <span class="hljs-keyword">while</span> (j &gt;= left + <span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>standard &lt;= a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>)&#123; --j; &#125;    <span class="hljs-comment">//j &gt;= left+1不可以更改j &gt; left+1</span><br>     <br>      <span class="hljs-keyword">if</span> (i &lt; j)<br>      &#123;<br>        <span class="hljs-built_in">char</span> temp = a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>        a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = temp;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>        break;<br>     <br>    &#125;<br><br>    a<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>    a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = standard;<br>  <br>    return j;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">//三向切分的快速排序：在一个数组中，不会多次选择主键值同样的元素作为基准；可以改成三向切分，就是比基准值小的元素放在左边，与基准值相等的元素放在中间，比基准值大的元素放在右边；对于包含大量重复元素的数组，可以将时间复杂度有NlgN降到N</span><br><span class="hljs-keyword">class</span> Quick3way<br>&#123;<br>public:<br>  void <span class="hljs-constructor">Sort(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">length</span>)</span><br>  &#123;<br>    <span class="hljs-comment">//在开始递归排序前最好先打乱一下数组，防止不合理的切分；这样就不容易出现O(N^2)这种情况</span><br>    <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, 0, <span class="hljs-params">length</span> - 1)</span>;<br>  &#125;<br>  <br>  void <span class="hljs-constructor">SortCore(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span><br>  &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right)<br>    &#123;<br>      return;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-comment">//三向切分</span><br>#<span class="hljs-keyword">if</span> <span class="hljs-number">0</span><br>      <span class="hljs-comment">//第一次切分</span><br>      <span class="hljs-built_in">char</span> standard = a<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>;<br>      <span class="hljs-built_in">int</span> i = left+<span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">int</span> j = right;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>      &#123;<br>        <span class="hljs-keyword">while</span> (a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; standard<span class="hljs-operator"> &amp;&amp; </span>i &lt;= right)&#123; ++i; &#125;<br>        <span class="hljs-keyword">while</span> (standard &lt;= a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> &amp;&amp; </span>j &gt;= left+<span class="hljs-number">1</span>)&#123; --j; &#125;<br>    <br>        <span class="hljs-keyword">if</span> (i &lt; j)<br>        &#123;<br>          <span class="hljs-built_in">char</span> temp = a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = temp;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>          break;<br>      &#125;<br>      a<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>      a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = standard;<br>    <br>      <span class="hljs-built_in">int</span> lessRight = j - <span class="hljs-number">1</span>;<br>    <br>      <span class="hljs-comment">//第二次切分</span><br>      j = right;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>      &#123;<br>        <span class="hljs-keyword">while</span> (a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span>standard<span class="hljs-operator"> &amp;&amp; </span>i &lt;= right)&#123; ++i; &#125;<br>        <span class="hljs-keyword">while</span> (standard &lt; a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><span class="hljs-operator"> &amp;&amp; </span>j &gt;= lessRight + <span class="hljs-number">2</span>)&#123; --j; &#125;<br>    <br>        <span class="hljs-keyword">if</span> (i &lt; j)<br>        &#123;<br>          <span class="hljs-built_in">char</span> temp = a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = temp;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>          break;<br>      &#125;<br>    <br>      <span class="hljs-built_in">int</span> equelRight = j;<br>    <br>      <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, <span class="hljs-params">left</span>, <span class="hljs-params">lessRight</span>)</span>;<br>      <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, <span class="hljs-params">equelRight</span> + 1, <span class="hljs-params">right</span>)</span>;<br>#endif<br>#<span class="hljs-keyword">if</span> <span class="hljs-number">1</span>  <br>      <span class="hljs-comment">//如果无法理解这段代码，请使用样例：6、2、3、7、6、6、9、1，来模拟一下</span><br>      <span class="hljs-built_in">char</span> standard = a<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>;<br>      <span class="hljs-comment">//[left,lt-1]中的元素都小于基准值</span><br>      <span class="hljs-comment">//[lt,i-1]中的元素都等于基准值</span><br>      <span class="hljs-comment">//[gt+1,right]中的元素都大于基准值</span><br>      <span class="hljs-built_in">int</span> lt = left;<br>      <span class="hljs-built_in">int</span> i = left + <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">int</span> gt = right;<br>      <span class="hljs-keyword">while</span> (i &lt;= gt)<br>      &#123;<br>        <span class="hljs-keyword">if</span> (a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; standard)<br>        &#123;<br>          <span class="hljs-built_in">char</span> temp = a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">lt</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">lt</span>]</span> = temp;<br>      <br>          ++i;<br>          ++lt;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><span class="hljs-operator"> == </span>standard)<br>        &#123;<br>          ++i;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &gt; standard)<br>        &#123;<br>          <span class="hljs-built_in">char</span> temp = a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = a<span class="hljs-literal">[<span class="hljs-identifier">gt</span>]</span>;<br>          a<span class="hljs-literal">[<span class="hljs-identifier">gt</span>]</span> = temp;<br>      <br>          --gt;<br>        &#125;<br>      &#125;<br>      <br>      <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, <span class="hljs-params">left</span>, <span class="hljs-params">lt</span> - 1)</span>;<br>      <span class="hljs-constructor">SortCore(<span class="hljs-params">a</span>, <span class="hljs-params">i</span>, <span class="hljs-params">right</span>)</span>; <br>#endif<br>    &#125;<br>  &#125;<br>&#125;;<br><br>#endif<br></code></pre></td></tr></table></figure>
<h2 id="特性-4">特性</h2>
<p>该算法的优点是可优化的空间大，经过精心调优的快速排序在大多数情况下都会比其他基于比较的排序算法更快，缺点是如果每次切分选择的元素都不正确，算法运行效率就会大幅度降低。例如第一次选了最小元素，第二次选择了次小元素作基准...，这种情况下时间复杂度就会变成O(n^2)，但是这种情况出现的概率比你电脑被雷劈中的概率还要小</p>
<h2 id="性能分析-3">性能分析</h2>
<p>使用该算法对n个元素进行排序时</p>
<p>时间复杂度为O(nlgn)，虽然和归并排序一样，但是比归并要快</p>
<p>空间复杂度为递归辅助栈的大小</p>
<h1 id="优先队列">优先队列</h1>
<p>在讲解堆排序之前需要先介绍一个数据结构--优先队列。该数据结构每一次取元素都只能获取最大（或最小）的元素</p>
<p>实现优先队列的方式有很多种</p>
<p>可以通过数组来实现无序或有序的优先队列</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221104000612.png?x-oss-process=style/WaterMask" /></p>
<p>还可以通过二叉堆来实现。二叉堆是一棵父节点总是大于（或小于）等于两个子节点的二叉树，这样一棵二叉树又可以说是堆有序的。二叉堆可以使用数组形式的完全二叉树来存储</p>
<p>树包括堆，堆包括二叉堆。因为一般使用的堆都是二叉堆，所以通常将二叉堆称为堆</p>
<p>为堆添加或移除元素都会先破坏堆的有序状态，然后再遍历堆来恢复有序状态（这个过程称为堆的有序化）
## 基于二叉堆实现的优先队列 以下二叉堆都是最大堆</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/上浮过程（插入操作的基础）.png?x-oss-process=style/WaterMask"
alt="上浮过程（插入操作的基础）" />
<figcaption aria-hidden="true">上浮过程（插入操作的基础）</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/下沉过程（删除操作的基础）.png?x-oss-process=style/WaterMask"
alt="下沉过程（删除操作的基础）" />
<figcaption aria-hidden="true">下沉过程（删除操作的基础）</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/插入元素（左）、删除元素（右）的过程.png?x-oss-process=style/WaterMask"
alt="插入元素（左）、删除元素（右）的过程" />
<figcaption
aria-hidden="true">插入元素（左）、删除元素（右）的过程</figcaption>
</figure>
<h2 id="代码实现-5">代码实现</h2>
<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">//优先队列的一种实现方式：二叉堆<br>//二叉堆：用这个数据结构可以很容易进行排序，但是直接用这个数据结构来排序效率并不高，因为我们只用很小一部分代码就够了<br>class MaxPQ<br>&#123;<br>private:<br>  char *pq;    <span class="hljs-regexp">//</span>节点为k，父节点为(k-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>，左孩子为<span class="hljs-number">2</span>*k+<span class="hljs-number">1</span>，右孩子为<span class="hljs-number">2</span>*k+<span class="hljs-number">2</span><br>  <span class="hljs-keyword">int</span> count;   <span class="hljs-regexp">//</span>记录堆中元素的个数<br>public:<br>  MaxPQ(<span class="hljs-keyword">int</span> maxN)<br>  &#123;<br>    pq = new char[maxN];<br>    count = <span class="hljs-number">0</span>;<br>  &#125;<br>  ~MaxPQ()<br>  &#123;<br>    <span class="hljs-keyword">delete</span>[] pq;<br>  &#125;<br>  bool isEmpty()<br>  &#123;<br>    <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">int</span> size()<br>  &#123;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>  void insert(char v)<br>  &#123;<br>    p<span class="hljs-string">q[count]</span> = v;<br>    swim(count);<br><br>    ++count;<br>  &#125;<br>  char delMax()<br>  &#123;<br>    char max = p<span class="hljs-string">q[0]</span>;<br><br>    char temp = p<span class="hljs-string">q[0]</span>;<br>    p<span class="hljs-string">q[0]</span> = p<span class="hljs-string">q[count - 1]</span>;<br>    p<span class="hljs-string">q[count - 1]</span> = temp;<br><br>    --count;<br><br>    sink(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">return</span> max;<br>  &#125;<br>  //核心<br>  void swim(<span class="hljs-keyword">int</span> k)<br>  &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; p<span class="hljs-string">q[k]</span> &gt; p<span class="hljs-string">q[(k - 1) / 2]</span>)<br>    &#123;<br>      char temp = p<span class="hljs-string">q[k]</span>;<br>      p<span class="hljs-string">q[k]</span> = p<span class="hljs-string">q[(k - 1) / 2]</span>;<br>      p<span class="hljs-string">q[(k - 1) / 2]</span> = temp;<br><br>      k = (k - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>  &#125;<br>  //核心<br>  void sink(<span class="hljs-keyword">int</span> k)<br>  &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span> &lt; count)<br>    &#123;<br>      <span class="hljs-keyword">int</span> maxChild = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (maxChild + <span class="hljs-number">1</span> &lt; count &amp;&amp; p<span class="hljs-string">q[maxChild + 1]</span> &gt; p<span class="hljs-string">q[maxChild]</span>)<br>        ++maxChild;<br><br>      <span class="hljs-keyword">if</span> (p<span class="hljs-string">q[k]</span> &gt;= p<span class="hljs-string">q[maxChild]</span>)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        char temp = p<span class="hljs-string">q[k]</span>;<br>        p<span class="hljs-string">q[k]</span> = p<span class="hljs-string">q[maxChild]</span>;<br>        p<span class="hljs-string">q[maxChild]</span> = temp;<br><br>        k = maxChild;<br>      &#125;<br><br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="性能分析-4">性能分析</h2>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
<th style="text-align: right;">插入第一个元素</th>
<th style="text-align: right;">删除最大元素</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>基于有序数组的优先队列</td>
<td style="text-align: right;">N</td>
<td style="text-align: right;">1</td>
</tr>
<tr class="even">
<td>基于无序数组的优先队列</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">N</td>
</tr>
<tr class="odd">
<td>基于二叉堆的优先队列</td>
<td style="text-align: right;">lgN</td>
<td style="text-align: right;">lgN</td>
</tr>
<tr class="even">
<td>某种理想的优先队列</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
</tr>
</tbody>
</table>
<p>从N个元素中找到最大的M个元素所需的成本：</p>
<table>
<thead>
<tr class="header">
<th>某种理想的优先队列</th>
<th style="text-align: right;">时间复杂度</th>
<th style="text-align: right;">空间复杂度（用于存储N个输入）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>其他最快的排序算法</td>
<td style="text-align: right;">NlgN</td>
<td style="text-align: right;">N</td>
</tr>
<tr class="even">
<td>数组实现的优先队列</td>
<td style="text-align: right;">NM</td>
<td style="text-align: right;">M</td>
</tr>
<tr class="odd">
<td>二叉堆实现的优先队列</td>
<td style="text-align: right;">NlgM</td>
<td style="text-align: right;">M</td>
</tr>
</tbody>
</table>
<h1 id="堆排序">堆排序</h1>
<blockquote>
<p>非稳定排序</p>
</blockquote>
<p>堆排序的基本步骤： 1. 将一个数组建成堆，建堆的方法有两种： 1.
层序遍历二叉树（从左到右遍历数组），每个节点都进行上浮操作 2.
从非叶子节点开始反向层序遍历二叉树（从右到左遍历数组），每个节点都进行下沉操作。这种方式的效率更高，只需要少于2N次比较以及少于N次交换
2. 不断删除堆顶元素</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221104001057.png?x-oss-process=style/WaterMask"
alt="排序过程中的数据变化" />
<figcaption aria-hidden="true">排序过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/排序过程中的数据变化.png?x-oss-process=style/WaterMask"
alt="排序过程中的数据变化" />
<figcaption aria-hidden="true">排序过程中的数据变化</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/排序过程图形化.gif"
alt="排序过程图形化" />
<figcaption aria-hidden="true">排序过程图形化</figcaption>
</figure>
<h2 id="代码实现-6">代码实现</h2>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#ifndef __HEAPSORT_H__</span><br><span class="hljs-meta">#define __HEAPSORT_H__</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//注意：count是待排序数组的长度</span><br>  <span class="hljs-keyword">void</span> sink(<span class="hljs-built_in">char</span> *a, <span class="hljs-built_in">int</span> k, <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>)<br>  &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">count</span>)<br>    &#123;<br>      <span class="hljs-built_in">int</span> maxChild = <span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span> (maxChild + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">count</span> &amp;&amp; a[maxChild + <span class="hljs-number">1</span>] &gt; a[maxChild])<br>        ++maxChild;<br><br>      <span class="hljs-keyword">if</span> (a[k] &gt;= a[maxChild])<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">char</span> temp = a[k];<br>        a[k] = a[maxChild];<br>        a[maxChild] = temp;<br><br>        k = maxChild;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//可以优化：先下沉后上浮，可将比较次数减少一半；这个方法需要额外的空间来辅助，只有当比较需要很高的代价时才采用</span><br>  <span class="hljs-keyword">void</span> sort(<span class="hljs-built_in">char</span> *a,<span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>)<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = (<span class="hljs-keyword">count</span> - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>      sink(a, i, <span class="hljs-keyword">count</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-keyword">count</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i)<br>    &#123;<br>      <span class="hljs-built_in">char</span> temp = a[i];<br>      a[i] = a[<span class="hljs-number">0</span>];<br>      a[<span class="hljs-number">0</span>] = temp;<br><br>      sink(a, <span class="hljs-number">0</span>, i);<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-meta">#endif</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>技术美术的职责</title>
    <url>/posts/dd4c3610.html</url>
    <content><![CDATA[<h1 id="何为技术美术">何为技术美术</h1>
<p>技术美术(Technical Artist,
TA)主要职责是作为美术师和程序员之间沟通合作的桥梁。因此TA需要同时兼备编码能力和美术能力，门槛较高，所以身价一般也比较高。前段时间原神的大火，进一步提升了TA的身价。TA是一个复合型工种，所以不同TA的能力侧重点会不一样。TA大致可以再细分为两种类型。一种偏向技术，驻扎在游戏引擎组。一种偏向美术，驻扎在美术支持组。</p>
<p>其实还可以继续细分的。比如</p>
<p>效果TA，主要负责实现具体的美术效果，比如人物描边、火焰效果、水流效果、运动模糊。</p>
<p>流程TA，主要负责各种资源的导出工作，例如全局光照烘焙流程、场景分块导出流程等。</p>
<p>优化TA主要负责性能优化工作，比如遮挡剔除的实现、具体效果的性能优化。</p>
<p>引擎TA主要负责游戏引擎整体渲染效果的把控，定制渲染管线，所以需要对引擎非常熟悉，并且能够对团队进行引擎相关的培训。</p>
<p>资产TA，需要整理、维护项目的资源，比如制定性能指标、资源检查。</p>
<p>相比于客户端程序，TA跟美术的沟通更加的紧密和频繁，TA需要主动去跟美术进行沟通，不要期待美术会及时反馈问题。
# 主要工作职责 TA最重要的工作就是实现具体的美术效果，例如 <img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234443.png?x-oss-process=style/WaterMask" />
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234451.png?x-oss-process=style/WaterMask" />
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234515.png?x-oss-process=style/WaterMask" />
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234522.png?x-oss-process=style/WaterMask" />
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234544.png?x-oss-process=style/WaterMask" />
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234610.png?x-oss-process=style/WaterMask" />
一般来说，实现一个美术效果分为4个阶段，方案确定、技术预研、效果实现、生产跟进。</p>
<p>TA在拿到一个具体的美术效果需求时，需要针对这个需求选择合适的实现方案。为了找到合适的方案，首先需要用技术语言将需求表达出来。然后对竞品进行分析，推测对方使用了什么技术来实现该效果。再去学习与实现技术相关的资料，可以到书籍、SIGGRAPH等地方找到需要的内容。最后针对之前的工作内容整理输出一份文档，发起一次会议和相关人员对齐之后的工作内容。</p>
<p>方案确定之后，TA就可以尝试在项目生产环境下对效果进行初步的实现，输出一个demo。这个过程中不需要太关注代码架构的合理性和性能问题，尽可能快就好。如果过程中使用的美术素材需要使用比较特殊的方式进行制作，就自己动手制作，不要麻烦美术。因为这个实现方案可能并不是最终的实现方案，这时让美术去学习新的制作方法性价比不高。等这个方案真的成为了最终方案时，再推广新的制作方法。但是常规的素材还是需要积极找美术配合输出的。</p>
<p>在整个过程中需要习惯性地将自己想法和问题记录到文档上，可以作为备忘录，也方便之后进行技术分享。demo出来之后，可以开会跟相关人员对实现出来的效果进行讨论，确定最终是否采纳该方案。</p>
<p>如果demo的效果不ok，则需要重新选择实现方案。否则将继续往前推进，这时就进入到了方案实现阶段，这个阶段主要是将demo的效果落地到项目生产环境中。在这个过程中需要依据项目规范重构demo的实现代码。如果存在较明显的性能消耗，则需要开展性能优化工作。开发特殊素材的制作工具并进行优化。输出美术制作文档，配合给出样例素材。如果有必要，则对美术进行基本的生产培训。之后还可以定期给团队成员进行技术分享，确保大家对引擎技术有着一致的认知。</p>
<p>在方案正式投入生产线使用时，TA需要积极主动跟美术进行交流，确保他们在制作过程没有被问题卡住，保证开发流程通畅。效果的跟进不可以交给QA来进行，QA只负责提出异常效果，表现力需要TA亲自跟进。多向美术收集素材制作工具的使用体验，及时对工具进行改良。
# 在各研发阶段中的具体工作职责
在项目研发的不同阶段，TA的工作侧重点会有所不同。</p>
<p>在项目启动阶段，TA需要配合美术同学给出可供我们项目参考的美术风格，并针对特定的效果进行技术评估，确定效果是否能实现。除了仿制出其它项目的效果之外，TA还需要为项目增加自己的特色，提升项目的市场竞争力。</p>
<p>在项目Demo制作阶段，TA就需要开始实现具体效果了，可参考上文。</p>
<p>在项目立项阶段，主要对效果表现力和性能进行优化。</p>
<p>在中期阶段，TA需要对资产进行良好地分类、维护、升级，因为资产会逐渐变得庞大。控制好资产大小，确保被打包的资产不多也不少。为了更合理地管理好资产，需要输出一定的规范文档，并依据必要的规范实现自动资源检查。还需要关注性能表现，针对性能消耗较大的效果进行优化，如果无法优化，可以考虑直接毙掉该效果。这时还需要开始考虑上线后可能会面临的问题，针对这些问题给出解决方案。</p>
<p>在内测阶段，需要及时解决运行环境中出现的性能问题、兼容性问题、效果表现力问题。</p>
<p>项目上线后，可以对之前工作结果进行总结和分享，沉淀下来，为新的项目做准备。</p>
]]></content>
      <categories>
        <category>游戏开发碎碎念</category>
      </categories>
  </entry>
  <entry>
    <title>游戏动画技术简介</title>
    <url>/posts/49a81750.html</url>
    <content><![CDATA[动画系统是游戏中对表现力影响最大的系统之一，经过一段时间的调研，最后通过这篇文章总结下游戏动画系统。
# 精灵动画系统
精灵动画系统在早年间计算机性能还比较差的时候被广泛运用，一般作为游戏的背景而存在，比如
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029175924.png?x-oss-process=style/WaterMask"
alt="极品飞车系列的路边观众" /> <img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180025.png?x-oss-process=style/WaterMask"
alt="NBA2K系列的观众" />
这些人物都是一个四边形，游戏引擎会给四边形连续贴上纹理贴图来产生动感。通常为了不暴露这是个扁的四边形，会使这些四边形一直面向摄像机。比如
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180040.png?x-oss-process=style/WaterMask"
alt="DOOM" />
这类动画系统在早期游戏中盛行，因为当时的计算机性能不够，而该系统对计算机资源的消耗非常低。现在部分手游依然会保留这类动画系统，因为手机性能有限。
# 刚性层阶式动画
刚性层阶式动画驱动的人物都由一堆独立的刚性物体组合而成。刚性物体指的是不会发生形变(包括缩放)的物体。然后动画系统会驱动每一个刚性物体，从而实现动画效果。最经典的例子就是1997年在PS上发售的FF7。
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180105.png?x-oss-process=style/WaterMask"
alt="97版FF7" />
这个系统驱动的是3D模型，而不再是四边形贴图，同时还能保持高效的性能和较低的内存使用量。缺点是不允许网格发生形变，整个人物会显得非常生硬。而且人物的关节位置会产生明显的“裂缝”。
# 每顶点动画
每顶点动画需要动画师为每个顶点去k动画。工作量非常巨大，产生的数据量也非常巨大，但是可以获得非常精细的动画效果，网格的三角形产生形变。通常用于制作CG中人物的表情，一般通过硬件设备来捕捉人脸信息，再转换成顶点数据。
<div
style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<pre><code class="hljs">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=859596268&amp;bvid=BV1eV4y1g7H7&amp;cid=875385956&amp;page=1&amp;high_quality=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;</code></pre>
</div>
<div
style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<pre><code class="hljs">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=559589709&amp;bvid=BV1Re4y127Tn&amp;cid=875387307&amp;page=1&amp;high_quality=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;</code></pre>
</div>
<h1 id="变形目标动画morphing-animation">变形目标动画(morphing
animation)</h1>
<p>由于每顶点动画需要保存大量的动画数据，不方便存储和使用。于是提出了变形目标动画，动画师只需要通过调整网格上所有顶点的信息制作出一些静态姿势(morph
target)。这些静态姿势都是一些“极端”的姿势，例如生气、开心等。在游戏引擎中通过对这些静态姿势按时间进行线性插值即可得到动画。</p>
<h1 id="蒙皮动画skinened-animation">蒙皮动画(skinened animation)</h1>
<blockquote>
<p>有时也被称为骨骼动画、蒙皮骨骼动画，是一种FK</p>
</blockquote>
<p>为了可以得到较生动的动画效果，允许网格的三角形产生形变。同时兼顾较高的性能、较低的存储空间。蒙皮动画便出现了，现在市场上几乎所有的游戏都采用蒙皮动画作为动画解决方案。
## 概念
在蒙皮动画中有几个重要的概念。首先是骨骼(skeleton)，骨骼由关节通过一棵树的形态组织起来。如果是一个人物模型，一般以髋部为根节点，以肢体末端为叶节点，比如手指、脚指、眼睛等。skeleton本身不需要被渲染引擎渲染出来，仅由动画系统驱动。</p>
<p>然后是皮肤(skin)，皮肤由多边形网格组成。而网格又由顶点构成，这些顶点将会被动画师通过设置权重绑定(bind)到若干关节上。一般每个顶点最多绑定4个关节。但不是所有的关节都会被顶点绑定，这些没有被绑定的关节又称为定位器(locator)，作为其它模型的挂接点存在。
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180348.png?x-oss-process=style/WaterMask"
alt="DX中skeleton的组织方式" />
蒙皮动画中存在几个重要的姿势(pose)，这些姿势可以矩阵或者SQT格式来保存。首先是绑定姿势，又称为T-pose，顾名思义，是动画师在给模型顶点做绑定时用的姿势。该姿势从DCC中输出之后就固定好了，在游戏运行时不会被改变。
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180400.png?x-oss-process=style/WaterMask" />
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180408.png?x-oss-process=style/WaterMask" />
然后是局部姿势，它保存了当前关节在其父关节空间中的姿势。因为动画引擎直接驱动的是局部姿势，我们经常需要对局部姿势进行各种插值，所以一般不会存储为矩阵形式，而是存储为SQT形式。我们的动画片段就是由一连串的局部姿势组合起来，也就是说动画片段是一个因变量为局部姿势，自变量为时间的函数。</p>
<p>最后是全局姿势，它保存了关节在其模型空间或世界空间中的姿势，具体保存形式不同的引擎有不同的做法。它是在游戏运行过程中通过联合具有父子关系的局部姿势实时生成的，算是被动画引擎间接驱动。
## 蒙皮(skinning)
首先需要准备数据，每一个关节都保存着一个绑定姿势逆矩阵，以下简称IBP，该矩阵可以将物体从模型空间转换到当前关节空间。IBP是在3D模型从DCC输出后，利用T-Pose计算出来的。一次计算，无限次使用。</p>
<p>动画引擎Update之后，每一个关节都会得到一个最新的局部姿势。这个时候可以进行一些额外的插值计算、程序式动画、IK等后处理过程。因为局部姿势一般保存为SQT格式，所以需要在这时转换成矩阵。</p>
<p>然后我们开始计算每个关节的全局姿势矩阵，计算方法是依次连接关节本身及其所有父节点的局部姿势矩阵。</p>
<p>最后IBP乘上全局姿势矩阵，就得到了蒙皮矩阵。顶点乘上蒙皮矩阵后会对顶点产生什么样的影响呢？可以这么想象：顶点原本位于模型为T-Pose时的模型空间中，乘上了IBP之后进入到关节空间中；再乘上全局姿势矩阵，这时模型摆出了由动画引擎驱动的姿势，在这个姿势下从关节空间回到模型空间。</p>
<p>所以最终呈现的效果是，顶点被关节带到了特定位置。计算出所有关节的蒙皮矩阵之后，我们就得到了矩阵调色</p>
<p>然后开始正式蒙皮。每个顶点都会从矩阵调色板中取得需要绑定的关节的蒙皮矩阵，然后更具动画师设定好的权重对这些矩阵进行混合。顶点乘上混合后的矩阵，这时蒙皮就完成了。</p>
<p>ps：动画引擎Update时，可以通过多种方式计算出局部姿势。可以对单个动画片段进行一维线性插值实现时间性混合来得到常规的动画效果。可以对两个动画片段进行淡入/淡出计算获得圆滑过渡、冻结过渡等过渡效果。更进一步推广，可以对多个动画片段进行N维线性插值实现自定义的混合。为了充分利用资源，可以对动画片段进行分部混合或加法混合，例如人物在Idle状态时，通过加法混合给人物加入一些小动作，使得人物更真实。例如...
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-14d7181792c45287b55129c0856b82ff_720w.gif" /></p>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
  </entry>
  <entry>
    <title>算法题--从尾到头打印链表</title>
    <url>/posts/4f46182d.html</url>
    <content><![CDATA[<p>5 # 要求 时间限制：1秒 空间限制：32768K</p>
<h1 id="题目描述">题目描述</h1>
<p>输入一个链表，从尾到头打印链表每个节点的值</p>
<h1 id="解题思路">解题思路</h1>
<p>链表必须要从头开始访问，如果需要将打印顺序颠倒，可以利用栈的特性。有时候方法就是这么简单
- -</p>
<p>如果想展示你的算法能力，可以写成递归--深度优先搜索</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  int val;</span><br><span class="hljs-comment">  struct ListNode *next;</span><br><span class="hljs-comment">  ListNode(int x) :</span><br><span class="hljs-comment">    val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">  </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    stack&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <br>    <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      temp.<span class="hljs-built_in">push</span>(head-&gt;val);<br>      head = head-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(!temp.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>      res.<span class="hljs-built_in">push_back</span>(temp.<span class="hljs-built_in">top</span>());<br>      temp.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈Entity-Component-System</title>
    <url>/posts/1abc5785.html</url>
    <content><![CDATA[<h1 id="简介">简介</h1>
<p>对于很多人来说，ECS只是一个可以提升性能的架构，但是我觉得ECS更强大的地方在于可以降低代码复杂度。</p>
<p>在游戏项目开发的过程中，一般会使用OOP的设计方式让GameObject处理自身的业务，然后框架去管理GameObject的集合。但是使用OOP的思想进行框架设计的难点在于一开始就要构建出一个清晰类层次结构。而且在开发过程中需要改动类层次结构的可能性非常大，越到开发后期对类层次结构的改动就会越困难。</p>
<p>经过一段时间的开发，总会在某个时间点开始引入多重继承。实现一个又可工作、又易理解、又易维护的多重继承类层次结构的难度通常超过其得益。因此多数游戏工作室禁止或严格限制在类层次结构中使用多重继承。若非要使用多重继承，要求一个类只能多重继承一些
简单且无父类的类(min-in class)，例如Shape和Animator。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029194540.png?x-oss-process=style/WaterMask" /></p>
<p>也就是说在大型游戏项目中，OOP并不适用于框架设计。但是也不用完全抛弃OOP，只是在很大程度上，代码中的类不再具体地对应现实世界中的具体物件，ECS中类的语义变得更加抽象了。</p>
<p>ECS有一个很重要的思想：数据都放在一边，需要的时候就去用，不需要的时候不要动。ECS
的本质就是数据和操作分离。传统OOP思想常常会面临一种情况，A打了B，那么到底是A主动打了B还是B被A打了，这个函数该放在哪里。但是ECS不用纠结这个问题，数据存放到Component种，逻辑直接由System接管。借着这个思想，我们可以大幅度减少函数调用的层次，进而缩短数据流传递的深度。
# 基本概念
Entity由多个Component组成，Component由数据组成，System由逻辑组成。 ##
Component(组件)
Component是数据的集合，只有变量，没有函数，但可以有getter和setter函数。Component之间不可以直接通信。
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">Component</span>&#123;<br>	<span class="hljs-comment">//子类将会有大量变量，以供System利用</span><br>&#125;<br></code></pre></td></tr></table></figure> ## Entity(实体)
Entity用来代表游戏世界中任意类型的游戏对象，宏观上Entity是一个Component实例的集合，且拥有一个全局唯一的EntityID，用于标识Entity本身。
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Entity</span>&#123;<br>	Int32 ID;<br>	List&lt;Component&gt; components;<br>        <span class="hljs-comment">//通过观察者模式将自己注册到System可以提升System遍历的速度，因为只需要遍历已经注册的entity</span><br>&#125;<br></code></pre></td></tr></table></figure>
Entity需要遵循立即创建和延迟销毁原则，销毁放在帧末执行。因为可能会出现这样的情况：systemA提出要在entityA所在位置创建一个特效，然后systemB认为需要销毁entityA。如果systemB直接销毁了entityA，那么稍后FxSystem就会拿不到entityA的位置导致特效播放失败（你可能会问为什么不直接把entityA的位置记录下来，这样就不会有问题了。这里只是简单举个例子，不要太深究(●'◡'●)）。理想的表现效果应该是，播放特效后消失。
## System(系统)
System用来制定游戏的运行规则，只有函数，没有变量。System之间的执行顺序需要严格制定。System之间不可以直接通信。</p>
<p>一个
System只关心某一个固定的Component组合，这个组合集合称为tuple。</p>
<p>各个System的Update顺序要根据具体情况设置好，System在Update时都会遍历所有的Entity，如果一个Entity拥有该System的tuple中指定的所有Component实例，则对该Entity进行处理。
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">System</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ASystem</span>:<span class="hljs-title">System</span>&#123;<br>    Tuple tuple;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>        <span class="hljs-keyword">for</span>(Entity entity <span class="hljs-keyword">in</span> World.entitys)&#123;<br>            <span class="hljs-keyword">if</span>(entity.components中有tuple指定的所有Component实例)&#123;<br>                <span class="hljs-comment">//do something for Components</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
一个Component会被不同System区别对待，因为每个System用到的数据可能只有其中一部分，且不一定相同。
## World(世界)
World代表整个游戏世界，游戏会视情况来创建一个或两个World。通常情况下只有一个，但是守望先锋为了做死亡回放，有两个World，分别是liveGame和replyGame。World下面会包含所有的System实例和Entity实例。
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">World</span>&#123;<br>    List&lt;System&gt; systems;                   <span class="hljs-comment">//所有System</span><br>    <span class="hljs-built_in">dictionary<span class="hljs-keyword">&lt;Int32, Entity&gt;</span></span> entitys;      <span class="hljs-comment">//所有Entity，Int32是Entity.ID</span><br><br>    <span class="hljs-comment">//由引擎帧循环驱动</span><br>    <span class="hljs-built_in">void</span> Update()&#123;<br>        <span class="hljs-keyword">for</span>(System sys <span class="hljs-keyword">in</span> systems)<br>            sys.Update();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
由ECS架构出来的游戏世界就像是一个数据库表，每个Entity对应一行，每个Component对应一列，打了✔代表Entity拥有Component。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Component1</th>
<th style="text-align: center;">Component2</th>
<th style="text-align: center;">...</th>
<th style="text-align: center;">ComponentN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EntityId1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td>EntityId2</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">✔</td>
</tr>
<tr class="odd">
<td>...</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td>EntityIdN</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;">✔</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h2 id="单例component">单例Component</h2>
<p>在定义一个Component时最好先搞清楚它的数据是System数据还是Entity数据。如果是System的数据，一般设计成单例Component。例如存放玩家键盘输入的
Component ，全局只需要一个，很多 System 都需要去读这个唯一的 Component
中的数据。
单例Component顾名思义就是只有一个实例的Component，它只能用来存储某些System状态。单例Component在整个架构中的占比通常会很高，据说在守望先锋中占比高达40%。其实换一个角度来看，单例Component可以看成是只有一个Component的匿名Entity单例，但可以通过GetSingletonIns接口来直接访问，而不用通过EntityID。</p>
<h2 id="例子">例子</h2>
<p>守望先锋种有一个根据输入状态来决定是不是要把长期不产生输入的对象踢下线的AFKSystem，该System需要对象同时具备连接Component、输入Component等，然后AFKSystem遍历所有符合要求的对象，根据最近输入事件产生的时间，把长期没有输入事件的对象通知下线。</p>
<h1 id="设计需要遵循的原则">设计需要遵循的原则</h1>
<ol type="1">
<li>设计并不是从Entity开始的，而是应该从System抽象出Component，最后组装到Entity中。</li>
<li>设计的过程中尽量确保每个System都依赖很多Component去运行，也就是说System和Component并不是一对一的关系，而是一对多的关系。所以xxxCOM不一定有xxxSys，xxxSys不一定有xxxCOM。
<ul>
<li>System和Component的划分很难在一开始就确定好，一般都是在实现的过程中看情况一步一步地去划分System和Component。而且最终划分出来的System和Component一般都是比较抽象的，也就是说通常不会对应现实世界中的具体物件，可以参考下图守望先锋System和Component划分的例子。
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029195909.png?x-oss-process=style/WaterMask"
alt="20221029195909" /></li>
</ul></li>
<li>System尽量不改变Component的数据。
<ul>
<li>可以读数据完成的功能就不要写数据来完成。因为写数据会影响到使用了这些数据的模块，如果对于其它模块不熟悉的话，就会产生Bug。如果只是读数据来增加功能的话，即使出Bug也只局限于新功能中，而不会影响其它模块。这样容易管理复杂度，而且给并行处理留下了优化空间。</li>
</ul></li>
</ol>
<h1 id="使用心得">使用心得</h1>
<p>我在一个游戏demo里尝试使用ECS去进行设计，最大的感受是所有游戏逻辑都变得那么的合理，应对改动、扩展也变得那么的轻松。加班变少了，也不再焦虑。在开始使用ECS来架构业务层之前，我对ECS还是存有一丝疑虑的。担心会不会因为规矩太多了，导致有些功能写不出来。中途也确实因为ECS的种种规矩，导致有些功能不好写出来，需要用到一些奇技淫巧，剑走偏锋。但这些技术最终造就了一个可持续维护的、解耦合的、简洁易读的代码系统。据说守望团队在将整个游戏转成ECS之前也不确定ECS是不是真的好使。现在他们说ECS可以管理快速增长的代码复杂性，也是事后诸葛亮。</p>
<p>引擎层的System比较好定义，因为引擎相关层级划分比较明确。但是游戏业务逻辑层可能会出现各种奇奇怪怪的System，因为业务层的需求千变万化，有时没有办法划分出一个对应具体业务的System。例如我曾经在业务层定义过DamageHitSystem、PointForceSys。</p>
<p>推迟技术：不是非常必要马上执行的内容可以推迟到合适的时再执行，这样可以将副作用集中到一处，易于做优化。例如游戏可能会在某个瞬间产生大量的贴花，利用延迟技术可以将这些需要产生的贴花数据保存下来，稍后可以将部分重叠的贴花删除，再依据性能情况分到多个帧中去创建，可以有效平滑性能毛刺。</p>
<p>如果不知道该如何去划分System，而导致System之间一定要相互通信才能完成功能，可以通过将数据放在中的一个队列里延迟处理。比如SystemA在执行Update的时候，需要执行SystemB中的逻辑。但是这个时候还没轮到SystemB执行Update，只能先将需要执行的内容保存到一个地方。但是System本身又没有数据，所以SystemA只好将需要执行的内容保存到单例Component中的一个队列里，等轮到SystemB执行Update的时候再从队列里拿出数据来执行逻辑。</p>
<p>但是System之间通过单例Component有个缺点。如果向单例Component中添加太多需要延迟处理的数据，一旦出现bug就不好查了。因为这类数据是一段时间之前添加进来的，到后面才出问题的话，不好定位是何处、何时、基于什么情况添加进来的。解决方案是给每一条需要延迟处理的数据加上调用堆栈信息、时间戳、一个用于描述为什么添加进来的字符串。</p>
<p>各个System都用到的公共函数可以定义在全局，也可以作为对应System的静态函数，这类函数叫做Utility函数。Utility函数涉及的Component最好尽可能少，不然需要作为参数传进函数Component会很多，导致函数调用不太雅观。Utility函数最好是无副作用的，即不对Component的数据做任何写操作，只读取数据，最后返回计算结果。要改Component的数据的话，也要交给System来改。</p>
<p>函数调用堆栈的层次变浅了，因为逻辑被摊开到各个System，而System之间又禁止直接访问。代码变得扁平化，扁平化意味的函数封装少了，所以阅读、修改、扩展也很轻松。</p>
<p>如果可以把整个游戏世界都抽象成数据，存档/读档功能的实现也变得容易了。存档时只需要将所有Component数据保存下来，读档时只需要将所有Component数据加载进来，然后System照常运行。想想就觉得强大，这就是DOP的魅力。</p>
<h1 id="优点">优点</h1>
<p>模式简单</p>
<p>结构清晰</p>
<p>通过组合高度复用。用组合代替继承，可以像拼积木一样将任意Component组装到任意Entity中。</p>
<p>扩展性强。Component和System可以随意增删。因为Component之间不可以直接访问，System之间也不可以直接访问，也就是说Component之间不存在耦合，System之间也不存在耦合。System和Component在设计原则上也不存在耦合。对于System来说，Component只是放在一边的数据，Component提供的数据足够就update，数据不够就不update。所以随时增删任意Component和System都不会导致游戏崩溃报错。</p>
<p>天然与DOP(data-oriented
processing)亲和。数据都被统一存放到各种各样的Component中，System直接对这些数据进行处理。函数调用堆栈深度大幅度降低，流程被弱化。</p>
<p>易优化性能。因为数据都被统一存放到Component中，所以如果能够在内存中以合理的方式将所有Component聚合到连续的内存中，这样可以大幅度提升cpu
cache命中率。cpu
cache命中良好的情况下，Entity的遍历速度可以提升50倍，游戏对象越多，性能提升越明显。ECS的这项特性给大部分人留下了深刻印象，但是大部分人也认为这就是ECS的全部。我觉得可能是被Unity的官方演示带歪的。</p>
<p>易实现多线程。由于System之间不可以直接访问，已经完全解耦，所以理论上可以为每个System分配一个线程来运行。需要注意的是，部分System的执行顺序需要严格制定，为这部分System分配线程时需要注意一下执行先后顺序。</p>
<h1 id="缺点">缺点</h1>
<p>在充满限制的情况下写代码，有时速度会慢一些。但是习惯之后，后期开发速度会越来越快。</p>
<h1 id="优化">优化</h1>
<p>一个entity就是一个ID，所有组成这个entity的component将会被这个ID给标记。因为不用创建entity类，可以降低内存的消耗。如果通过以下方式来组织架构，还可以提升cpu
cache命中率。 <figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//数组下标代表entity的ID</span><br><span class="hljs-selector-tag">ComponentA</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentAs</span>;<br><span class="hljs-selector-tag">ComponentB</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentBs</span>;<br><span class="hljs-selector-tag">ComponentC</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentCs</span>;<br><span class="hljs-selector-tag">ComponentD</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentDs</span>;<br>...<br></code></pre></td></tr></table></figure></p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a
href="https://gameinstitute.qq.com/community/detail/114516">《守望先锋》架构设计与网络同步
-- GDC2017 精品分享实录</a></li>
<li>http://gamadu.com/artemis/</li>
<li>http://gameprogrammingpatterns.com/component.html</li>
<li>http://t-machine.org/index.php/2014/03/08/data-structures-for-entity-systems-contiguous-memory/</li>
<li>http://blog.lmorchard.com/2013/11/27/entity-component-system/</li>
<li><a
href="https://blog.codingnow.com/2017/06/overwatch_ecs.html">浅谈《守望先锋》中的
ECS 构架</a></li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>算法题--用两个栈实现队列</title>
    <url>/posts/bcbbc7d8.html</url>
    <content><![CDATA[<p>7 # 要求 时间限制：1秒 空间限制：32768K</p>
<h1 id="题目描述">题目描述</h1>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。
队列中的元素为int类型</p>
<h1 id="解题思路">解题思路</h1>
<p>利用栈可以颠倒一个序列的顺序这个特性来思考</p>
<p>像这类题目只要模拟一下就能找到答案：先加入一些元素，然后思考如何弹出你想要的元素，这样就解决了弹出的问题；再思考添加的问题</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102235103.png?x-oss-process=style/WaterMask"
alt="模拟过程" />
<figcaption aria-hidden="true">模拟过程</figcaption>
</figure>
<p>这道题中，stack1用于入队，stack2用于出队，只是出队是要注意：要保证stack2不为空时才可以出队；如果它为空，就要先将stack1中所有元素弹出到stack2中，再从stack2中弹出一个元素；如果它不为空，直接从stack2中弹出一个元素即可</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span></span><br><span class="hljs-function">  </span>&#123;<br>    stack1.<span class="hljs-built_in">push</span>(node);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>      <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())<br>      &#123;<br>         stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>         stack1.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>    &#125;<br>      <br>    <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>      cout &lt;&lt; <span class="hljs-string">&quot;队列为空&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">abort</span>();<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> res = stack2.<span class="hljs-built_in">top</span>();<br>    stack2.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;	<span class="hljs-comment">//入</span><br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;	<span class="hljs-comment">//出</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="拓展">拓展</h1>
<p>用两个队列来模拟栈，思考方式和这道题一样</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102235134.png?x-oss-process=style/WaterMask"
alt="模拟过程" />
<figcaption aria-hidden="true">模拟过程</figcaption>
</figure>
<p>两个队列的元素要不停的倒来倒去</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法题--替换空格</title>
    <url>/posts/25e9ce90.html</url>
    <content><![CDATA[<p>4 # 要求 时间限制：1秒 空间限制：32768K # 题目描述
请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are
Happy.则经过替换之后的字符串为We%20Are%20Happy. # 解题思路
拿到题目之后，一般会首先想到从头开始扫描这个字符串，遇到空格就将后面所有的字符都向后移动两格，再插入%20。虽然这个办法可行，但是时间复杂度为O（n^2），每一个字符都会有多次移动</p>
<p>现在希望每个字符只移动一次。我们要用两个指针P1和P2，P1指向字符串的最后一个字符'\0',P2指向替换了空格后的字符串尾部。每一个空格都会导致字符串增长两个字符</p>
<p>具体过程如下图所示 ​ <img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102021246.png?x-oss-process=style/WaterMask" /></p>
<h1 id="代码">代码</h1>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">void</span> replaceSpace(<span class="hljs-built_in">char</span> *<span class="hljs-built_in">str</span>,<span class="hljs-built_in">int</span> length)<br>  &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">str</span>==NULL || length&lt;=<span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-built_in">int</span> endIndexOfOriStr = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">int</span> endIndexOfNewStr = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">int</span> curIndexOfOriStr = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>      ++curIndexOfOriStr;<br>      <br>      ++endIndexOfOriStr;<br>      ++endIndexOfNewStr;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">str</span>[curIndexOfOriStr] == <span class="hljs-string">&#x27; &#x27;</span>)<br>        endIndexOfNewStr += <span class="hljs-number">2</span>;<br>        <br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">str</span>[curIndexOfOriStr] != <span class="hljs-string">&#x27;\0&#x27;</span>);<br>    <br>    <span class="hljs-keyword">if</span>(endIndexOfNewStr&gt;=length)<br>      <span class="hljs-keyword">return</span>;<br>        <br>    <span class="hljs-keyword">while</span>(endIndexOfOriStr &gt;= <span class="hljs-number">0</span> &amp;&amp; endIndexOfOriStr &lt; endIndexOfNewStr)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">str</span>[endIndexOfOriStr]==<span class="hljs-string">&#x27; &#x27;</span>)<br>      &#123;<br>        --endIndexOfOriStr;<br>        <span class="hljs-built_in">str</span>[endIndexOfNewStr--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">str</span>[endIndexOfNewStr--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        <span class="hljs-built_in">str</span>[endIndexOfNewStr--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-built_in">str</span>[endIndexOfNewStr] = <span class="hljs-built_in">str</span>[endIndexOfOriStr];<br>        --endIndexOfOriStr;<br>        --endIndexOfNewStr;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法题--重建二叉树</title>
    <url>/posts/f4b58e74.html</url>
    <content><![CDATA[<p>6 # 要求 时间限制：1秒 空间限制：32768K</p>
<h1 id="题目描述">题目描述</h1>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都<strong>不含重复的数字</strong>。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回</p>
<h1 id="解题思路">解题思路</h1>
<p>解题的前提：两个序列中必须有一个中序序列</p>
<p>前（后）序序列用于提供根节点，根节点就是序列第一个元素（最后一个元素）</p>
<p>中序序列用于确定当前根节点的左右子树有哪些节点</p>
<p>如下图所示：</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102234717.png?x-oss-process=style/WaterMask" /></p>
<p>确定了左右子树有哪些元素之后就继续递归</p>
<h1 id="代码">代码</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Definition for binary tree</span><br><span class="hljs-comment">struct TreeNode</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  int val;</span><br><span class="hljs-comment">  TreeNode *left;</span><br><span class="hljs-comment">  TreeNode *right;</span><br><span class="hljs-comment">  TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pre,vector&lt;<span class="hljs-type">int</span>&gt; vin)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">int</span> psize=pre.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> vsize=vin.<span class="hljs-built_in">size</span>();<br>      <br>    <span class="hljs-keyword">if</span>(psize==<span class="hljs-number">0</span> || vsize==<span class="hljs-number">0</span> || psize != vsize)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>      <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reBuildBinaryTreeCore</span>(pre, <span class="hljs-number">0</span>, psize<span class="hljs-number">-1</span>, vin, <span class="hljs-number">0</span>, vsize<span class="hljs-number">-1</span>);<br>  &#125;<br>  <br>  <span class="hljs-function">TreeNode* <span class="hljs-title">reBuildBinaryTreeCore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre, <span class="hljs-type">int</span> startIdxOfP, <span class="hljs-type">int</span> endIdxOfP,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  vector&lt;<span class="hljs-type">int</span>&gt;&amp; vin, <span class="hljs-type">int</span> startIdxOfV, <span class="hljs-type">int</span> endIdxOfV)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">int</span> valOfRoot = pre[startIdxOfP];<br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(valOfRoot);<br>    <br>    <span class="hljs-keyword">if</span>(startIdxOfP == endIdxOfP)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(startIdxOfV == endIdxOfV)<br>        <span class="hljs-keyword">return</span> root;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无效输入&quot;</span> &lt;&lt; endl;<br>  	<span class="hljs-built_in">abort</span>();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">int</span> idxOfRootInV = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(idxOfRootInV = startIdxOfV;idxOfRootInV &lt;= endIdxOfV &amp;&amp; <br>          vin[idxOfRootInV] != valOfRoot;++idxOfRootInV)<br>      &#123;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(vin[idxOfRootInV] != valOfRoot)<br>      &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无效输入&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">abort</span>();<br>      &#125;<br>    	<br>      <span class="hljs-type">int</span> leftLength = idxOfRootInV - startIdxOfV;<br>      <span class="hljs-comment">//左</span><br>      <span class="hljs-keyword">if</span>(startIdxOfV &lt;= idxOfRootInV - <span class="hljs-number">1</span>)<br>        root-&gt;left = <span class="hljs-built_in">reBuildBinaryTreeCore</span>(pre,<br>                                           startIdxOfP + <span class="hljs-number">1</span>,<br>                                           startIdxOfP + leftLength,<br>                                           vin,<br>                                           startIdxOfV,<br>                                           idxOfRootInV - <span class="hljs-number">1</span>);<br>      <span class="hljs-comment">//右</span><br>      <span class="hljs-keyword">if</span>(idxOfRootInV + <span class="hljs-number">1</span> &lt;= endIdxOfV)<br>        root-&gt;right = <span class="hljs-built_in">reBuildBinaryTreeCore</span>(pre,<br>                                            startIdxOfP + <span class="hljs-number">1</span> + leftLength,<br>                                            endIdxOfP,<br>                                            vin,<br>                                            idxOfRootInV+<span class="hljs-number">1</span>,<br>                                            endIdxOfV);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> root;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>GDC 2019 Evolving Combat in &#39;God of War&#39; for a New Perspective ⸺ “战神”战斗模式的全新变革 上篇</title>
    <url>/posts/238c8259.html</url>
    <content><![CDATA[<p>该GDC分享只免费公开PPT，视频需要GDC VAULT会员</p>
<p>分享的PPT下载地址：<a
href="https://www.gdcvault.com/play/1026423/Evolving-Combat-in-God-of">Evolving
Combat in 'God of War' for a New Perspective</a>
没有梯子的可以到这里下载：
https://pan.baidu.com/s/1a1FGedhthon0yK7BTnlVbQ 提取码：6kjs</p>
<p>演讲者：Mihir Sheth（圣莫尼卡工作室首席战斗设计师） 辅助问答：Jeet
Shroff（游戏总监和前游戏工程主管）</p>
<h1 id="战神的新旧更替">战神的新旧更替</h1>
<p>《战神》是⼀个第三人称动作冒险游戏，玩家扮演斯巴达半神奎托斯，传说中的武器披荆斩棘，同时获得⼀些⼼灵的启迪。</p>
<p>为了方便不熟悉《战神》系列作品的同学，在这里对比一下老战神和新战神的战斗效果。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005052.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005059.png?x-oss-process=style/WaterMask" /></p>
<div
style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<pre><code class="hljs">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=713569276&amp;bvid=BV1NX4y1K7Vc&amp;cid=277325769&amp;page=1&amp;high_quality=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;</code></pre>
</div>
</br>
<div
style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<pre><code class="hljs">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=22318492&amp;bvid=BV1MW41157Jf&amp;cid=36955509&amp;page=1&amp;high_quality=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;</code></pre>
</div>
<p>可以看到这是两种看起来截然不同的游戏，但是它们内在的玩法都包含了战神的精髓，游戏设计有着共同的基因。</p>
<h1 id="旧战斗风格">旧战斗风格</h1>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005433.png?x-oss-process=style/WaterMask" /></p>
<ol type="1">
<li>激烈与技巧</li>
<li>满满的乐趣</li>
<li>强大的力量感</li>
</ol>
<p>开发组一直想将日本动作游戏的烈度和技巧带到西方背景中。通过简易的玩法来扩大受众，同时将顶级的视觉体验带到玩家⾯前。</p>
<p>奎托斯是一个充满进攻性的角色，所以整体的战斗都充满力量感。对敌人对战时带给玩家一种在玩弄猎物的感觉。</p>
<p>在战神1~3中都是使用⼀个拉远的摄像机来完成的，在较远的地方可以看到奎托斯所有的动作。系列中的每一步作品都在不停地完善战斗机制、增强视觉效果以达到史诗般的效果。</p>
<h1 id="新战斗风格">新战斗风格</h1>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005503.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005511.png?x-oss-process=style/WaterMask" /></p>
<ol type="1">
<li>视角需具备踏实和亲密的感觉，需要适用于游戏的所有情景</li>
<li>利维坦之斧</li>
<li>玩家控制的第三人称镜头</li>
</ol>
<p>在这个视角下将呈现很多新事物，例如北欧神话、同时兼顾近战和远战的利维坦之斧头、一个玩家控制的第三人称近距离相机且从不瞬切。</p>
<p>这个新相机的目的是让玩家拥有更加具备沉浸感的体验，让玩家更加靠近奎托斯，让战斗更细致严谨。</p>
<p>这么做将完全改变战神的战斗体验，而且必须要做得更好。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005537.png?x-oss-process=style/WaterMask" /></p>
<p>开发组要做两件事情： 1. 为新摄像机重新定义战斗 2.
保留战神系列的核心战斗特性</p>
<h1 id="矛盾与战斗风格分析">矛盾与战斗风格分析</h1>
<p>用一个近距离相机来展现快速、激烈、充满力量感的史诗场景是一件很不可思议的事情。近距离和史诗两者本身就很矛盾，莫非要玩家达到”一花一世界，一叶一菩提“的境界才能欣赏这个游戏。首次在E3演示游戏时，玩家们都很惊讶这个设定，经常会说看不见东西。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005608.png?x-oss-process=style/WaterMask" /></p>
<p>构成战神战斗风格的元素： 1.
玩家及时响应式和combo式的出招，敌人各种夸张的受击反应 2.
充满力量感的向前位移式攻击 3. 轻松地同时与多个敌人进行战斗 4.
主角可以被轻易控制</p>
<h1 id="对比其他动作游戏">对比其他动作游戏</h1>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005634.png?x-oss-process=style/WaterMask" /></p>
<p>大部分其他拥有类似相机系统的游戏带有视角锁定系统，注重一对一战斗，而不是打群架。这种游戏的战斗风格都偏向于保守和谨慎，因为这种镜头难以看清周围的局势。主角的攻击动作也不会向前位移太多。攻击会以攻击距离和攻击时机为考量点，而不是触发有趣的敌人受击反应。</p>
<p>这些游戏这么做也是合理的，因为战斗系统和镜头是相互配合的。玩家也喜欢这些游戏。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005648.png?x-oss-process=style/WaterMask" /></p>
<p>《战神4》没有办法参照其他动作游戏的做法，因为战斗的核心体验和其他游戏不一样。《战神4》的玩家在战斗时是充满自信和攻击性的，和其它游戏的保守谨慎形成鲜明对比。</p>
<p>研发组一开始反对新镜头也正是因为这个矛盾。</p>
<p>核心矛盾：近距离镜头 vs 主角的自信感、攻击性以及场景的史诗感</p>
<p>但是Mihir
Sheth坚持认为这个新镜头设计是正确的，便一直朝着这个方向前进。</p>
<h1 id="追踪怪物tracking-enemies">追踪怪物(Tracking Enemies)</h1>
<h2 id="敌人的战斗状态划分">敌人的战斗状态划分</h2>
<p>威胁可以分为以下两种： 1. Aggressive：积极进攻 2.
Non-Aggressive：后退和等待中</p>
<p>这两种状态会对敌人的行为和位置产生不同的影响。Aggressive的敌人会积极尝试攻击玩家，Non-Aggressive的敌人会在离玩家有点距离的地方徘徊，等着切换为Aggressive状态。</p>
<p>敌人的状态可以是这两种状态的其中一种，可以想象一下功夫电影种的打斗场景，敌人都是一个接一个来进攻，而不是多个敌人一起进攻。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/成龙打斗.gif" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/甄子丹打斗.gif" /></p>
<p>为了能够追踪正确的敌人，即使玩家可以一次性和多个敌人进行战斗，玩家也必须要有办法知道哪个敌人是更具有威胁性的。</p>
<h2 id="aggressive-score">Aggressive Score</h2>
<blockquote>
<p>攻击性评分</p>
</blockquote>
<p>Aggressive Score由四个部分组成：0-00-0-000 1.
是否可以切换到Aggressive状态：用于确保当前不处于受击或相关状态 2.
优先级：由策划为每一个敌人类型设置的一个数字，同时还要设置优先级的生效距离。如果超过了这个距离，那么优先级就将为了最低(应该是这么理解吧？)
3. 是否被玩家瞄准 4.
行动等级：依据当前是否在相机可视范围内、与相机的角度、与玩家的距离综合得出
## Aggressive Token <img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005924.png?x-oss-process=style/WaterMask" /></p>
<p>为每种敌人类型设置一个数字作为Aggression token。</p>
<p>为当前可变为Aggressive状态的所有敌人的Aggression
token值总和设置一个初始值M。每当由一个敌人变为Aggressive状态，则M减去该敌人的Aggression
token值。若该敌人切出Aggressive状态，则M加上该敌人的Aggression
token值。</p>
<p>敌人按照Aggressive
Score从高到低进行排序，从排名高的敌人开始切换为Aggressive状态，直到M&lt;=0。</p>
<p>上图的示例中，M的初始值为14。左列红框打了星号的代表切换为Aggressive状态，右列红框的数值就是Aggression
token。从图中可以看出，当前只有最底下的哪个敌人不处于Aggressive状态。</p>
<p>这种方式可以很容易控制切换为Aggressive状态的敌人数量，可以通过调整M初始值的大小来调整游戏难度。
## 敌人的站位 <img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005951.png?x-oss-process=style/WaterMask" /></p>
<p>敌人站位方式需要切换的改革，需要配合新相机从头开始设计。 ##
确定设计方向 <img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010021.png?x-oss-process=style/WaterMask" /></p>
<p>在1~3部作品中，敌人的状态决定敌人事在站在玩家附近还是远离玩家，这样敌人就被放在两个同心圆中。没有做任何分散敌人的处理，没有地形分区的概念。较远的镜头可以让玩家看到每一个敌人，可以很容易感知到敌人的威胁。不太有攻击性的敌人偶尔会在地图边缘移动，让战斗看起来好像很智能。</p>
<p>但是现在的敌人可能在屏幕内也可能在屏幕外，远的敌人容易被近的敌人遮挡，因此需要确保敌人合理地分散开来。
## 第一次尝试：基于权重的站位系统为每个敌人找到最佳位置 <img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010043.png?x-oss-process=style/WaterMask" /></p>
<p>在玩家周围铺设多个检查点，所有检查点跟随玩家移动。每个检查点的权重根据是否在navmesh上以及是否存在通往主角的路径来评定。处于Aggressive状态的敌人会到权重较高的检查点。这样敌人会分布在主角周围，类似老版战神。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010055.png?x-oss-process=style/WaterMask" /></p>
<p>这个方案前期使用着还行，随着时间的推移发现了一些问题，需要更有效的方案。</p>
<p>存在的问题： 1. 检查点权重评定变得单⼀、复杂、凌乱，难以debug 2.
玩家和敌人不断移动，检查权重经常变得无效，敌人经常聚集在一起 3.
玩家无法在大脑中构建敌人位置地图（mantal
map）。敌人一旦不可见，玩家就会感到害怕，然后就不在变得自信和具有攻击性。这样就没战神内味了。</p>
<h2 id="第二次尝试">第二次尝试</h2>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010117.png?x-oss-process=style/WaterMask" /></p>
<p>不再为每个敌人选择最佳位置，而是不让敌人进⼊糟糕的位置。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010145.png?x-oss-process=style/WaterMask" /></p>
<p>Aggressive状态的敌人需要被约束在玩家面前的红色扇形中，让他们保持在镜头中。</p>
<p>Non-Aggressive状态的敌人会在玩家周围围成一个圈，像老版战神⼀样。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010258.png?x-oss-process=style/WaterMask" /></p>
<p>每个敌人都有自己的空间，跟随自己移动，其它敌人不可以进入这个空间中。</p>
<p>Aggressive状态的敌人拥有一个圆柱形空间。</p>
<p>Non-Aggressive状态的敌人拥有一个略微弯曲的矩形空间。有利于将敌人横向散落，又不会占用过多与玩家间隔的那块空间，因为大部分情况下Non-Aggressive状态的敌人比Aggressive状态的敌人要多。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010320.png?x-oss-process=style/WaterMask" /></p>
<p>比上一版好的地方： 1. 算法更简单 2. 算法不容易失效 3.
敌人的站位更好看</p>
<p>仍然存在的问题： 1.
突然切换为Aggressive状态的敌人可能会从玩家身后走到身前，可能会吓玩家一跳，而怪怪的，好像是专门过来找打的。
2. 玩家无法在⼤脑中构建敌人位置地图（mantal
map），这个问题直到游戏快要发布的前几个月才被解决。</p>
<h2 id="解决关键问题">解决关键问题</h2>
<p>关键问题：敌人如何以玩家想要的方式站位</p>
<p>解决思路：一个敌人要么一直在镜头中，要么一直在镜头外，除非是玩家操作导致切换</p>
<p>额外设计：一旦一个敌人掉到的镜头外，该敌人当前处于世界空间的哪个象限就要一直在这个象限中。这样即使敌人不在玩家视野内，也可以知道它大概在什么位置（ps：问题是玩家怎么知道敌人会被固定在一个时间空间的象限中呢？）</p>
<p>在这之后的测试中，玩家的操作变得自信和充满攻击性，这正是他们所希望看到的。</p>
<h2 id="威胁指示标记">威胁指示标记</h2>
<p>为了让玩家更了解镜头外的敌人在干嘛，他们考虑添加一些标记在屏幕。相比雷达或小地图，还是在HUD上做标记不容易分散玩家的注意力。他们在屏幕边缘闪烁和小箭头指示两者间权衡了利弊之后选择了小箭头的形式。</p>
<p>玩家知道的越多，就越有信心，所以箭头有三种颜色：白色代表附近的敌人、红色代表正在攻击玩家的敌人、紫色代表远距离攻击的敌人。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010412.png?x-oss-process=style/WaterMask" /></p>
<p>由于前面的站位系统做得好，所以小箭头的表现也良好，玩家容易理解。</p>
<h2 id="运镜辅助">运镜辅助</h2>
<p>在激烈的战斗中使用右摇杆控制镜头会为操作额外增加一个维度的复杂度。《战神4》希望可以面向更大的玩家群体，所以需要设计一个运镜辅助机制。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010432.png?x-oss-process=style/WaterMask" /></p>
<p>两个机制： 1.
为敌人赋予一个权重，用于选取摄像机的聚焦点，摄像机自动调整使得聚焦点保持在视野中。
2. 镜头自动转向玩家攻击的方向</p>
<p>自动调整镜头达到玩家心中期待的状态不是一件容易的事情。虽然这套运镜辅助机制并不100%正确，但是可以缓解玩家不少操作压力。大部分玩家体验良好，如果玩家不喜欢也可以在设置菜单中关闭该机制。</p>
<hr />
<p><a href="https://roudersky.com/posts/9b30e53c.html">下篇地址</a></p>
<hr />
<p>第一次写GDC解读类文章，如果有不正确的地方，欢迎大家留言指正</p>
<p>如果大家觉得哪个GDC分享非常好，可以留言推荐一下，合适的话我也去品品~</p>
]]></content>
      <categories>
        <category>GDC</category>
      </categories>
      <tags>
        <tag>GDC</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Road 1.写给准备进入职场的游戏人</title>
    <url>/posts/7d2f1a5e.html</url>
    <content><![CDATA[<p>​
准备进入游戏公司工作对于每一个热爱游戏的人来说都是一件令人兴奋的事情，但因为陌生会伴随着不安。本文简单记录一下当年初入职场时的感受以及遇到的各种问题。</p>
<h1 id="适应">适应</h1>
<p>刚刚进入职场的新人在前两个月主要做的事情是适应新环境、工作节奏和氛围。</p>
<p>对于部分新人来说，他可能是从其他城市来到当前这个陌生的城市。需要适应的环境不仅仅是公司的环境，包括生活的环境，例如气候，我刚刚来到杭州的时候正好是最冷的时候，作为一个在广东长大的孩子，感觉难以承受。</p>
<p>如果之前都是在学校敲代码，没有感受过真实生产环境下敲代码。或者之前以实习的身份来敲代码，现在用正式员工的身份敲代码。或者之前不在这家公司，而是在其他公司。我们都要适应下新的工作节奏。如果项目进度非常赶的话，节奏可能会很快，这时可能会比较吃力。我们还需要适应工作氛围。有些公司的工作氛围很沉闷压抑，自己就不要太跳。有些公司的工作氛围比较活泼，自己就可以多放开一点。</p>
<p>平日上班时间应该是在学习各种课程，而不是在忙着做项目相关的事情。项目进度再赶都不要给刚刚来到公司的新人安排具体业务。事情总是做不完的，要想安排的话随时都可以把新人的日常全部排满。今天修个bug，明天改个功能，短期来看总产出提升了，但是长期来看对新人是有害的。</p>
<p>项目进度变得这么赶是一件不正常的事情，公司应该反思一下为什么会这么赶，也许pm的排期并不合理。这个状态可以是阶段性的，不应该是长期性的。但无论如何，如果非要让刚刚来到公司的新人去赶任务，就要跟新人好好沟通。</p>
<p>可以从公司对待你的态度看出公司是不是重视你。如果公司重视你，它会为你作长远的培养规划，想着怎么让你在未来3~5年内跟公式共同成长。如果公司不重视你，它会急着压榨你身上的剩余价值，压榨完了就赶紧换掉。</p>
<p>这段时间算是一个过渡期，虽然短期来看没什么产出，但长期来看对公司有很大的价值，如果这家公司有长远眼光的话。</p>
<p>非常不幸的是，我刚毕业去到公司就被拉到前线去战斗了。当时项目进度非常赶，所有的新人都被拉走了，战况异常激烈。大家都快要患上PTSD了，我也差点阵亡。现在回想起来，当年的自己真热血。</p>
<p>新人完成过渡之后，就可以开始安排一些业务类型的任务。通过业务类型的任务可以让新人逐步了解公司的产品设计和代码。等新人慢慢上手之后可以和新人进行进一步的沟通，结合新人的意愿去调整之后的任务安排。切忌一直安排差不多的任务，时间长了降低新人的热情。也不要把一些比较恶心的锅甩给新人，我发现不少公司都喜欢将锅甩给新人。这时锅的主人会松一口气，等新人兜不住的时候就pua新人。</p>
<h1 id="感觉自己在打杂">感觉自己在打杂？</h1>
<p>大部分刚刚进入游戏研发大厂的同学都是意气风发，磨拳擦掌准备大干一场的。但是进去之后发现自己接到的任务都是一些技术含量不高的任务，这时心里就会开始产生落差，觉得自己这匹千里马没有被伯乐相中，无法施展自己的才华，不被重视。其实这种产生这种心理从某种角度来看也是一种好事，因为这说明这位同学上进、关注自身成长。</p>
<p>但是不必太过心急，因为刚去到一个新的环境中，同事对你还不够了解，不敢委派比较重要的任务给你。无论如何，你都要把交给自己的任务都当作重要任务来完成，不要因为一个任务很琐屑而敷衍了事。其实大部分情况下，再简单的任务都能学到新的东西，总能把它做得更好。</p>
<p>你执行的每一项任务都会被leader看在眼里，每一项任务都会在leader心里留下印象。你是希望不断在leader心里累积失望，还是不断在leader心里累积信任，很大程度上取决于你做事情的态度。我记得某大佬说过一句话：“能力还不够也没关系，只要你态度够好，我们就愿意培养。”</p>
<p>我见过心浮气躁、耐不下性子来处理事情的新人A，也见过勤勤恳恳、脚踏实地的新人B。A完成任务的速度和质量整体来看是不如B的，B做出来的内容总是给人一种一种很精致的感觉，而且时间把控得比较好，不会太快，也不会踩着时间点来。</p>
<p>慢慢地，leader就会将一些需要投入一定时间进行预研的项目给到B。所以一定要认真对待给到自己的每一个任务，不要以为这个任务琐屑，leader就不关注你。如果自己都觉得自己的任务不重要，就没有人会觉得你的任务重要。</p>
<p>如果很长一段时间（多长时间算长需要看具体情况，个人感觉4个月左右差不多了）过去了，leader还没有给到你比较重要的任务，但是自己做得已经很不错了，再继续下去提升并不大。而且因为熟练度提升了，leader派下来的任务会越来越多，压榨你每一份精力。</p>
<p>慢慢就会陷入到疲于应付任务，没有时间思考的状态。这种情况就要引起警觉了，如果是处于业务上升期，可以理解，但是也要有个度，毕竟每个人都要为自己负责，不要对公司过于忠诚。公司不会为你的人生负责。</p>
<p>这时就要跟leader进行沟通，保持信息对称。</p>
<p>最担心出现误解，leader所了解的信息、预期和你所了解的信息、预期不一致，但是你以为是一致的。误解会随着时间的推移慢慢被放大，导致双方工作状态不好，降低合作效率。其实你的很多问题都是沟通问题，比如对leader不满意。</p>
<p>在出现误解之后，为了保持信息对称，要么改变自己的想法，要么想办法说服leader。在信息对称之后，如果你和leader还是处不来，可以选择跨级沟通。如果跨级沟通还是没有办法解决的话，你懂的=
=</p>
<h1 id="熟悉">熟悉</h1>
<p>刚开始处理公司的任务时会有很多地方都是陌生的，做笔记是一个快速熟悉的好方法，而且也非常值得去做。因为这个时候不懂的东西是最多的，提升是最快的，将每一点成长都记录下来可以给后来人留下一段可以借鉴的成长经历。</p>
<p>有人喜欢每周一记，有人喜欢每日一记，有人喜欢每时每刻都记。我还是比较喜欢每时每刻都记，记录频率尽可能地高。因为我平时的任务都比较多，很多东西如果没有马上记下来就很容易忘记。我也因为这样漏掉了很多内容，所以非常鼓励大家养成记录的习惯。</p>
<p>有些工作室有着良好的记录文化，这些工作室的策划案整体质量比那些没有良好记录文化的工作要高。除了策划案质量的提升，还会带来看不见的价值。比如研发做好记录可以提升自己的研发效率、沟通效率、成长效率，这些效能的提升不容易让人察觉到是做记录带来的。</p>
<p>我觉得良好的记录工具是很重要的，舒适的记录环境可以让自己更爱记录。比较通用的记录工具有协同办公软件，例如某书。对于工程师来说，markdown使用起来还是很舒服的，我一般会用vscode+markdown。这些都不喜欢的话，再不济都要用notepad++，怎么都不要用windows自带的记事本来记录。不知道为什么，记事本一打开就犯困。</p>
<p>很多东西都可以记，比如工作流程的改进、认知的提升、技术点的突破、人生感悟、未来规划。我是那种脑子里一不小心就蹦出一个灵感的人，通过随手记录的方式可以捕捉到这些灵感。</p>
]]></content>
      <categories>
        <category>Game Road</category>
      </categories>
  </entry>
  <entry>
    <title>Game Road 3.在工作期间快速发展需要有的态度</title>
    <url>/posts/70d2a4f9.html</url>
    <content><![CDATA[<h1
id="凡事有交代件件有着落事事有回音">凡事有交代，件件有着落，事事有回音</h1>
<p>我们做的每一件事情都应该闭环，有头有尾。有时候leader可能只是简单跟你说要去做某件事情，不要因为说得比较简单而不重视它。</p>
<p>例如leader可能会发个截图过来跟你说：“这个地方性能有点问题，去跟进一下看看。”你可能会稍后找个时间来查一下，确定问题之后就开始修复，提交代码的时候也没有给leader去review一下。</p>
<p>过了很长一段时间之后，leader纳闷怎么这么就都没有回应，是不是哪里卡住了不知道怎么修
。于是主动来问你性能问题跟进得怎么样了。这时你有可能忘了修复的具体细节，或者说明具体修复细节之后，leader看出了这个修复方案存在问题。这个时候就会给leader留下一种不靠谱的心里印象。</p>
<p>老实说，要做到这一点挺不容易的。因为游戏行业的研发节奏本身就很快，平时开发压力很大，要顾上所有的事情不是一件简单的事情。但是无论无何，leader交代下来的事情要比其他事情更积极一点，单单是做到这一点，你的升迁速度就已经快很多了。</p>
<h1
id="前三年是成长最快的三年工作时间以外也要多花时间提升自己">前三年是成长最快的三年，工作时间以外也要多花时间提升自己</h1>
<p>新人刚刚来到职场需要学习的东西还很多，有些技能以前在学校读书的时候没有意识到它的重要性。在职场工作的过程中会慢慢需要用到一些比较重要的技能，当发现自己这一块技能水平存在不足时，就给自己规划好时间去学习提升。</p>
<p>工作时间以外可以花点时间去学习，可以利用早期的时间、午休时间、下班后的时间。当然不是要将这些时间全部用上，能充分利用其中一个时间段就已经很不错了。把自己逼得太紧，效果反而不太理想，娱乐时间还是要有一点的。只会学习不玩耍,聪明孩子也变傻。</p>
<p>这样坚持几年时间下来会比不做这些事情会累很多，但是我觉得还是值得的。可能有人会说：“这跟加班有什么区别？工贼”我觉得差别很是很大的，加班的产出是给公司的，而经常时对自己成长提升不大的内容。但是自己学习提升得到的东西都是自己的，可以跟着你一辈子（不要说时间长了把它搞忘了=
=）。</p>
<p>相信我，只要能坚持住，你的成长速度是飞快的。</p>
<h1
id="不能只做一个杂家要先做一个专家">不能只做一个杂家，要先做一个专家</h1>
<p>刚刚进入到职场面对浩如烟海的技术会顿感迷茫，不要想着一下子抓住所有的技术。我们应该确定一个方向，这个确定过程可以是主动的，也可以是被动的。主动选自己喜欢的，被动选工作需要的。</p>
<p>锁定了方向之后，我们要深入学习这个方向的内容，要从原理上去了解做过的每一个东西，而不仅仅是满足于完成需求。同时也可以去学习其他技术点，随着主攻方向学习的深入，你可能就会发现其实很多东西是相通的。慢慢地，你的技能树就会形成一超多强的局势。这时就成为了一个T型人才。</p>
<p>如果有一个确定的方向，在面临岔路口的时候就不会茫然，你会很坚定地选择一个方向。这同样节省了很多时间。因为诱惑还是很多的，每次做选择都纠结很久的话会耗费很多心力，每个人每天的心力都是有限的，心力耗尽之后做事效率会下降很多。</p>
]]></content>
      <categories>
        <category>Game Road</category>
      </categories>
  </entry>
  <entry>
    <title>GDC 2019 Evolving Combat in &#39;God of War&#39; for a New Perspective ⸺ “战神” 战斗模式的全新变革 下篇</title>
    <url>/posts/9b30e53c.html</url>
    <content><![CDATA[<p>该GDC分享只免费公开PPT，视频需要GDC VAULT会员</p>
<p>分享的PPT下载地址：Evolving Combat in 'God of War' for a New
Perspective 没有梯子的可以到这里下载： <a
href="https://pan.baidu.com/s/1a1FGedhthon0yK7BTnlVbQ">https://pan.baidu.com/s/1a1FGedhthon0yK7BTnlVbQ</a>
提取码：6kjs</p>
<p>演讲者：Mihir Sheth（圣莫尼卡工作室首席战斗设计师） 辅助问答：Jeet
Shroff（游戏总监和前游戏工程主管）</p>
<p><a href="https://roudersky.com/posts/238c8259.html">上篇地址</a></p>
<h1 id="瞄准敌人targeting-enemies">瞄准敌人(Targeting Enemies)</h1>
<blockquote>
<p>帮助玩家攻击他们想攻击的</p>
</blockquote>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102015919.png?x-oss-process=style/WaterMask" /></p>
<p>在上图这样的战斗情景下，玩家按下攻击会向哪个怪物攻击呢？</p>
<p>右边的？因为离得近？</p>
<p>中间的？因为在屏幕中心？</p>
<p>还是就简单朝前方攻击就好？</p>
<p>公司高层要求他们在不适用锁定系统的情况下进行目标选择，同时又要可以流畅地和多个敌人进行战斗。</p>
<p>还要做到的一点是，无缝使用利维坦之斧的近战攻击和远程攻击。</p>
<h2 id="近战瞄准">近战瞄准</h2>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102015945.png?x-oss-process=style/WaterMask" /></p>
<p>在1~3部作品中，玩家都是使用左摇杆操作主角转身，面向谁就算是瞄准谁。</p>
<p><strong>在《战神4》中的早期尝试</strong></p>
<p>让屏幕中心对准的方向作为瞄准方向。</p>
<p>但是玩家反馈并不好，竟然没有打到他们想打的敌人，导致手感很差。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020038.png?x-oss-process=style/WaterMask" /></p>
<p><strong>最终解决方案</strong></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020102.png?x-oss-process=style/WaterMask" /></p>
<p>影响敌人被瞄准的权重的因素： 1. 镜头朝向：通过右摇杆展现 1.
是否在屏幕中 1. 与玩家的水平角度 1. 是否在屏幕正中 1.
玩家意图：通过左摇杆展现。和前作类似，这样玩家会比较熟悉 1. 与玩家的距离
1. 是否是玩家正在攻击的目标</p>
<p>ps：斜体字的那些项拥有一票否决权</p>
<p>如果瞄准了一个敌人，玩家就不能手动调整主角的攻击方向。如果没有敌人，玩家就朝摄像机方向攻击，无法向其它方向攻击。</p>
<p>开发团队希望让玩家感觉自己就是奎托斯，奎托斯不会像智障一样打空气。因为镜头就在主角身边，任何一点问题都会被放大很多，打空气也是。</p>
<h2 id="目标吸附suck-to-target">目标吸附(Suck to target)</h2>
<blockquote>
<p>注意：在攻击时，是主角被吸到敌人面前，而不是敌人被吸到主角面前</p>
</blockquote>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020141.png?x-oss-process=style/WaterMask" /></p>
<p>这个机制在《战神：崛起》用过</p>
<p>每次攻击都指定了参数：范围、速度和停止距离</p>
<p>每次攻击时，主角会依据以上参数被吸向敌人，让攻击敌人变得更容易</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020157.png?x-oss-process=style/WaterMask" /></p>
<p>存在一个很出戏的问题：在上图这种镜头下，主角被吸向怪物面前时，玩家很容易察觉到吸的过程</p>
<p>另一个很出戏的问题：主角在被吸过去的时候，敌人远离的玩家攻击范围</p>
<p>解决方案：依据敌人和相机的角度来调整范围参数，角度越大，范围越小</p>
<h2 id="远程瞄准">远程瞄准</h2>
<p>瞄准阻尼：当准心靠近敌人时，移动速率降低</p>
<p>自动瞄准：按下瞄准时，直接瞄准到一个敌人</p>
<h2 id="目标锁定">目标锁定</h2>
<p>高层要求要有目标锁定系统。玩家也希望有目标锁定系统，因为大部分玩家都熟悉目标锁定功能。所以在游戏即将发布时加入了目标锁定系统。
规则： 1.
启动目标锁定系统之后，会选取玩家正在瞄准的敌人作为锁定目标，这样过渡会比较平滑。
1. 使用右摇杆来切换想要被锁定的目标。 1.
即使开启目标锁定系统也允许玩家调整镜头高度 1.
即使开始进行远程瞄准，原本锁定的目标会被保留着，所以推出远程瞄准之后，还是会锁定着原来的目标</p>
<h1 id="攻击敌人engaging-enemies">攻击敌人(Engaging Enemies)</h1>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020240.png?x-oss-process=style/WaterMask" /></p>
<h2 id="动画位移">动画位移</h2>
<p>敌人受击后会后移一段距离，这时因为目标吸附功能的存在，主角会被吸向敌。</p>
<p>对于新镜头来说，敌人很容易被打出屏幕边缘，然后自动切换为一个新的敌人，就好像完成了combo得到了惩罚一样。移动的距离远了，玩家也很容易失去方向。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020255.png?x-oss-process=style/WaterMask" /></p>
<p>主角向怪物前移对战斗不利，因为视野会缩小。后前才会有利，因为视野会扩大。</p>
<p>所以，需要在 充满力量感的前移攻击 和 良好的战斗视野
之间进行平衡。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020317.png?x-oss-process=style/WaterMask" /></p>
<p>对策： 1. 减少了怪物普通受击反馈的位移 1. 减少了奎托斯攻击时的位移 1.
编辑器可以程序化缩放动画位移，有助于快速迭代测试</p>
<h2 id="攻击辅助机制strike-assist">攻击辅助机制(Strike Assist)</h2>
<p>要想办法将被击中的敌人保留在视野中</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020343.png?x-oss-process=style/WaterMask" /></p>
<p>进行一次攻击时，敌人的位移方向是 攻击方向 和 摄像机方向 的插值。</p>
<p>每个攻击都可以指定插值混合方式。</p>
<p>该机制的作用： 1. 敌人不会被打出视野外 1.
连续攻击同一个敌人可以将这个敌人拉到屏幕中央 1.
连续攻击时，主角也会被吸到屏幕中央 1.
远程瞄准更容易，因为瞄准时敌人已经在屏幕中央了，准心也在屏幕中央</p>
<p>该机制带来的额外惊喜：玩家可以通过控制镜头的方向来控制敌人被击飞的方向，可以创造出以下玩法：
1. 将敌人聚集到一起来释放AOE 1. 将敌人打下悬崖</p>
<p>没想到这样一个小机制可以带来这样的惊喜！</p>
<h2 id="受击碰撞">受击碰撞</h2>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020425.png?x-oss-process=style/WaterMask" /></p>
<p>敌人在受击位移过程中会对其它敌人产生碰撞反应（会有动作但不会受伤），可以将其它敌人撞开，这样可以更好的保护玩家。</p>
<h2 id="disrupting-enemy-aggression不知怎么翻译比较好">Disrupting Enemy
Aggression(不知怎么翻译比较好= =)</h2>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020448.png?x-oss-process=style/WaterMask" /></p>
<p>为了让玩家更加自信，激励玩家不断进攻。Aggressive状态下的敌人在播放受击反应时不会将状态切换为Non-Aggressive状态。这时受击敌人因为还在播放受击反应而无法攻击玩家，这给了玩家一定的优势。玩家只需要关注这个敌人和额外少数敌人。因为在普通难度下，一般只有两个Aggressive状态的敌人，玩家会很有掌控感。</p>
<p>这样会给玩家一个错觉：其它敌人看这当前被打的怪物这么惨，不敢上前了，老子真牛逼，老子就是战神本人！</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/一脚扫开.gif" /></p>
<p>哈哈哈，其实都被策划安排得稳稳妥妥的~</p>
<h2 id="浮空攻击air-juggling-enemies">浮空攻击(Air Juggling
Enemies)</h2>
<p>开发组想更花式地玩弄敌人，于是开发了浮空连击功能</p>
<p>面临的挑战： 1. 击飞到空中的敌人容易离开玩家的视野或遮挡玩家视野 1.
利维坦之斧的攻击范围有限 1. 主角无法跳跃，无法持续关注空中的敌人</p>
<p>解决方式：限制每个敌人的浮空高度，当怪物的位置高于一定高度时，会被施加一个向下的速度来修正高度。为了让这种体验正常，在浮空下落过程中不能依赖重力。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020544.png?x-oss-process=style/WaterMask" /></p>
<p>一旦敌人被打到空中，玩家就就将敌人维持在空中秀一下。为了保护玩家，被打浮空的敌人也会撞到其它敌人，敌人这个碰撞体比在地面受击要大得多，但是玩家还是要注意具有远程攻击技能的敌人。玩家要在合适的情况下在使用浮空打击。</p>
<h1 id="总结">总结</h1>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102020602.png?x-oss-process=style/WaterMask" /></p>
<p>听完正常分享之后，我们会发现这其中并没有什么高深的技术，但是他们完成了一次老IP的全面革新。一开始提出新镜头时面对大量质疑的声音，但是开发团队依然坚持自己的决定。</p>
<p>原本可以选择炒冷饭的，但是开发团队没有这么做，而是做了一次大胆的尝试。这次尝试之所以能够成功，很大程度上因为开发团队始终坚持着相同的大方向，紧紧地抓住战神系列作品地核心--主角充满自信和攻击性，场景如史诗般恢宏大气，整体充满力量感</p>
<p>可以看得出来在变革的过程中，每一次面临抉择如果跟着直觉走，选择一条理所当然、合情合理的轻松道路走下去。可能就没有今天的战神了，在各种ACT中迷失自我。</p>
<p>创新总是艰难的，向战神系列致敬！</p>
<hr />
<p>如果有不正确的地方，欢迎大家留言指正</p>
<p>如果大家觉得哪个GDC分享非常好，可以留言推荐一下，合适的话我也去品品~</p>
]]></content>
      <categories>
        <category>GDC</category>
      </categories>
      <tags>
        <tag>GDC</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Road 2.在研发团队中的做事方式</title>
    <url>/posts/75a0f04b.html</url>
    <content><![CDATA[<h1
id="人手永远是不够的事情是永远做不完的">人手永远是不够的，事情是永远做不完的</h1>
<p>很多人会以为任务都只能被安排，这可能跟一直以来项目进度都比较赶有关。每个任务都是由上头派发下来的，久而久之就会以为只能被动接受任务。但是其实是可以主动去找事情做的的。</p>
<p>人手永远是不够的，事情永远是做不完的，如果有自己想做的事情，不要想着等忙完当前的任务，我就去做。这样可能永远也等不到，因为任务会一个接着一个来，可以早点去请求自己想要的任务，或者自己创造任务（不是说去搞个问题出来，而是去发现问题，提出问题）</p>
<p>反正都是要打工，不如自己去找点有意思的事情做，这样起码死也要死在自己手里。</p>
<h1
id="了解leader需要解决什么问题自己可以帮上什么忙">了解leader需要解决什么问题，自己可以帮上什么忙</h1>
<p>在完成了自己当前任务的情况下，可以主动去了解leader有什么问题需要解决（有些部门会有一个需求池），从中找到自己感兴趣又有一定挑战性的任务承接下来。这样做的好处是，leader可以看到你的工作积极性，同时可以一定程度上掌握自己的发展方向。</p>
<p>时间长了，leader也会慢慢明白你想往哪个方向去发展，日后leader安排下来的任务也不会偏离自己心仪的方向太远。</p>
<h1
id="了解同事的任务拓展自己的知识面说不定自己还可以帮到他们">了解同事的任务，拓展自己的知识面。说不定自己还可以帮到他们</h1>
<p>在有空闲的时候可以关注一下同事的任务，可以在工作内容上进行对比，想想自己是否可以承接同事的任务。如果不可以，要如何提升才可以承接。这样做还可以拓宽自己的知识面，提升自己对技术的敏感度。</p>
<p>如果可以的话，还可以和同事一起进行讨论，为同事提供解决问题的思路。这样可以快速拉近自己和同事之间的关系。</p>
<h1
id="工作量较少的情况下多了解业界中经典或前沿的技术写写demo">工作量较少的情况下，多了解业界中经典或前沿的技术，写写demo</h1>
<p>平时多抽点时间了解业界的经典或者前沿技术，可以的话动手写写demo，有些知识只有真正实践过才能扎实掌握。其实大部分公司是鼓励员工可以抽出时间来学习的，这样做有利于工程师的长期成长。但是我待过的工作室很难让我抽出时间来做这些事情，业务开发量过大。</p>
<h1
id="体验公司的产品对比竞品提出改进点">体验公司的产品，对比竞品，提出改进点</h1>
<p>可以的话，要偶尔主动体验下公司的产品，有些工作室会组织大家一起来体验产品。</p>
<p>像我们做游戏的，体验产品其实就是玩游戏，在游玩的过程中记录下有待改进的地方。可以提高自己对公司产品的理解程度，方便之后开发新内容时更好地匹配当前地设定。</p>
<p>虽然新需求匹配旧设定这样一件事情是游戏策划的职责，但是我们还是多自己把关一下，算是对自己付出时间的一种负责。其实接到的新需求和旧设定不匹配的情况还是不少的，可能是因为策划不停修改、多个策划提出改进意见，导致主要负责策划自己都记不清功能当前变成什么样了，但是我们研发可以看代码准确把握功能的最新情况。</p>
<p>在体验产品的过程中，可以多个竞品对比一下。多想想别人的产品有哪些比我们做得好的地方，可以将这些好的点记录下来。然后找时间去研究下别人是怎么做到的，我们有没有可能向这个好的方向改变。</p>
<p>如果合适的话，我们就可以排期去优化我们的产品。如果我们可以一直向其他产品学习优秀的点，我们的产品就可以变得更好，集百家之所长。但是需要注意的是不要一味地模仿，不然最后我们的产品可能变成一只缝合怪。</p>
<h1
id="如果有我想做或需要做的事情就去积极推动">如果有我想做或需要做的事情，就去积极推动</h1>
<p>虽然我们是个打工人、新时代的农名工，但如果我们有自己想做的事情，可以主动承接，甚至发起自主任务去解决自己在项目中发现的问题。不用一直被动地接受任务，否则你会经常接到你不喜欢的任务，这样无论是完成任务的效率还是对于自己的提升可能都不会很高。</p>
<p>因为主动性不够强，任务经常只能做到做完的程度，而没有做好。能做到主动承接任务可以给leader留下一个敢于担当的好印象，这是领导力的一种侧面体现。</p>
<p>能做到主动发起自主任务，可以看出这个工程师善于发现项目中的潜在问题，洞察力强，这是工程能力的一种体现。在积极主动执行一项任务的时候，工程师可能会爆发自己的小宇宙，最终把任务完成到做好的程度。</p>
]]></content>
      <categories>
        <category>Game Road</category>
      </categories>
  </entry>
  <entry>
    <title>Game Road 4.执行任务的方式</title>
    <url>/posts/8ad6de59.html</url>
    <content><![CDATA[<p>在工作过程中，做事情分为以下4个境界，分别是做了、做完、做好、做对，难度和耗时都依次递增。
# 第一层境界--做了：被动执行，不关注结果
处于这个阶段的研发，别人说什么就做什么，不会为这项任务做整体的考虑。</p>
<p>这类人大致可以分为以下几种：</p>
<p>第一种人没追求的，得过且过，只是想在公司混混日子。他们会觉得事情只要能够完成就好，至于最终效果怎么样，跟他们没有关系。这类人很难拯救，因为他们根本不想成长。</p>
<p>第二种人有追求，但是没有意识到需要把事情做到更好，他们以为只要完成了任务就已经是完满完成任务了，上头就已经很满意了。这类人还是可以拯救的，因为他们只是不知道要做得更好而已，有可能是因为他们以前工作的地方给他留下了这种不好的观念。只要合理地对这类人进行引导，他们会明白之后应该怎么去做得更好。</p>
<p>第三种人有追求、有意识到需要做得更好，但是因为时间不够等原因被逼得只能勉强完成任务。出现这样的情况，责任并不完全在执行者身上，还有一部分原因在leader或者pm身上。游戏行业研发压力大，时间经常会被压得很紧，要把事情做得更好需要花费的时间自然是更多的。</p>
<p>如果真的要把这件事情做得更好的话，可能需要执行者牺牲私人时间。偶尔牺牲一下私人时间也还可以接受，如果这种情况经常发生，执行者也不可能一直牺牲自己的私人时间。从这一点来看，年轻人比中年人更有优势。因为年轻人，特别是刚刚出来工作的人，私人时间一般都是空闲的。但是中年人的私人时间一般都是有事情要做的。这也是35岁中年危机会出现的其中一个原因。</p>
<p>更好的解决方法是执行者找leader或者pm沟通重现沟通时间，让执行者有更多的时间去把事情做好。不要不好意思开口请求更多的研发时间，确实需要更多时间就要及时汇报，不需要什么东西都自己默默背负着，搞得自己压力很大，不仅影响工作状态，还可能影响生活状态。</p>
<p>事情只做到这个程度的话，其实是有点敷衍的，做出来的东西不太能放得上台面。时间长了，leader也能看出来，对自己的发展发展非常不利。</p>
<h1
id="第二层境界--做完高质量高标准完成任务">第二层境界--做完：高质量、高标准完成任务</h1>
<p>处于这个阶段的研发算是负责任的，起码完成的内容完备稳定，可以良好地接入到当前的系统中。
把事情做到这个程度只能说是比及格线稍微高一丢丢，完成的内容算是能看了。执行者完成任务之后不会有太大的成就感，只会舒一口气。</p>
<p>leader对这类人地印象不好也不坏，只会觉得这是个还能干活的人。</p>
<h1
id="第三层境界--做好完成的内容质量上乘">第三层境界--做好：完成的内容质量上乘</h1>
<p>这个阶段的人不仅能够完完整整地把事情做完，还会主动为功能作出更多角度的考虑，关注功能的长期发展。</p>
<p>即使在大厂中，能把事情做到这个程度的人也不多。因为不止要把事情做完，还要额外考虑更多的事情，如可维护性、扩展性、内存占率、cpu占用率、FPS。其实能够考虑到其中一两点已经很不错，我到现在也没有碰到能够把这些点全部考虑到的研发。</p>
<p>可能有些研发以为自己考虑到了，但那只是他以为，其实并没有。</p>
<p>例如可维护性，有些研发以为自己的代码写得非常好，但其实很多人都看不懂他的代码，然后他可能还会说：“不是都写得很清楚了吗”。过了一段时间之后他自己都看不懂，然后他就会说：“肯定有人改过我的代码了”，其实并没有人改过。。。</p>
<p>例如扩展性，有些研发以为自己的架构写得贼牛逼，觉得自己整了几个manager就很厉害，蜜汁自信。认真看一下他写的manager就会发现这几个manager之间的耦合度贼高，没有一个是可以单独运行的，这种并不叫封装，只能说是把原本的一坨代码强行拆开到多个模块中。</p>
<p>内存占用率、cpu占用率、FPS一般都是在功能完成之后再统一考虑。在开发过程中也可以稍微关注一下，但是不建议投入太多精力，因为过早的优化并不见得是一件好事。</p>
<p>老实说，如果自己想做，又真的有足够的时间为功能作多方面的考虑，应该是很享受的一件事情。因为可以看着自己的功能变得越来越好，就像自己的孩子长大一样。</p>
<p>要想得心应手地处理好额外地事情，需要长期的积累，厚积薄发。平时多阅读经典书籍，例如《计算组成原理》、《代码大全》等。</p>
<h1
id="第四层境界--做对完成的内容真的能解决用户的问题">第四层境界--做对：完成的内容真的能解决用户的问题</h1>
<p>处于这一层的人会具有更强的主动性，具备主人翁精神，参与任务方向的决策。</p>
<p>理论上，把握任务方向这件事情应该由专门的同事负责，在游戏公司中就是策划。把握方向是策划的本职工作。他们必须要达到这个境界。因为方向不对，努力白费。</p>
<p>把握方向跟研发没有太大关系。但是我们可以影响策划，对方向进行细微的调整。如果在某些设定上，你和策划没有办法达成一致，而你坚定地认为策划地想法是不合理地。那可以和直属leader沟通给方向，某些情况下甚至可以请leader去和策划沟通。</p>
<p>​<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102015322.png?x-oss-process=style/WaterMask"
alt="20221102015322" /></p>
<p>一个差的研发只是做了客户需要他做的事。而一个好的研发创造了客户希望他创造的价值，可以通过客户表面的语言帮客户找到深层次的需求是什么，然后提出一个更好的方案。我们要创造价值而不是创造代码。</p>
<p>但是做这样一件事其实不容易被leader注意到，而且需要额外花费时间。leader只能看到你在花时间跟策划聊天，也不知道你是在聊八卦还是聊正事。</p>
<p>但我认为这件事是有意义的，因为这项任务的完成结果能不能被上级认可，很大程度上要看这个功能在游戏中的最终表现。如果最后表现不行，甚至这个功能最后不上线，代码写得再好，上级对你的评价也不会高。</p>
<p>你的苦劳能不能被承认，还得看功劳够不够。所以为了不做无用功，还是要多关注一下方向。当你的功能被一次次推翻的时候，是很受打击的。因为没有什么成就感，在其他人看来，很多东西你做了跟没做一样。</p>
<p>这个阶段需要的是较强的沟通能力，能够和策划的思想碰撞出火花，但是又不会破坏关系。可以学习一下沟通方面的知识，推荐《非暴力沟通》。</p>
]]></content>
      <categories>
        <category>Game Road</category>
      </categories>
  </entry>
  <entry>
    <title>游戏引擎 1.概述</title>
    <url>/posts/8ddcbab2.html</url>
    <content><![CDATA[<p>该系列文章主要面向完全没有引擎基础，但具备一定编程基础的同学。讲解的内容不会展开太深入，只希望读者可以对游戏引擎中的技术有一个基本的理解。如果大家对其中的某些内容感兴趣，可以评论留言。我会根据大家的期望，力所能及地展开讲解。
# 简介 电子游戏是一款软实时(soft
real-time)模拟软件。软实时模拟软件需要做到可以响应实时操作，并且即使由于某些原因没有立即响应也不会造成灾难性后果。在电子游戏这样的软实时模拟软件中的大部分数学问题没有闭合式解，因此需要进行离散的模拟才能得到一个结果。</p>
<p>游戏引擎正是为了完成游戏中各种各样的模拟而整合了各种各样的模块，例如物理模块、渲染模块、逻辑模块等。早期的游戏引擎大多只能运行在特定平台，例如《雷神之锤》的引擎<a
href="https://github.com/id-Software/Quake">Quake engine</a>、<a
href="https://zh.wikipedia.org/wiki/%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C">魔兽世界</a>用的暴雪自家引擎。</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102021724.png?x-oss-process=style/WaterMask"
alt="Quake" />
<figcaption aria-hidden="true">Quake</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102021729.png?x-oss-process=style/WaterMask"
alt="魔兽世界" />
<figcaption aria-hidden="true">魔兽世界</figcaption>
</figure>
<p>后来出现了可以跨平台运行的通用游戏引擎，例如<a
href="https://unity.com/cn">Unity</a>、<a
href="https://www.unrealengine.com/zh-CN/">Unreal</a>。</p>
<div
style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<pre><code class="hljs">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=262246257&amp;bvid=BV1Ke411F7ZE&amp;cid=878641990&amp;page=1&amp;high_quality=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;</code></pre>
</div>
</br>
<div
style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
<pre><code class="hljs">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=389714115&amp;bvid=BV1td4y1C71P&amp;cid=878642018&amp;page=1&amp;high_quality=1&quot;  scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt;&lt;/iframe&gt;</code></pre>
</div>
<p>一般来说，越通用的游戏引擎，在特定平台上的运行效率会越不如那些只能运行于特定游戏平台的游戏引擎。因为性能优化总是基于特定假设的，这个假设越单一，优化起来会越轻松。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102022943.png?x-oss-process=style/WaterMask" /></p>
<h1 id="硬件">硬件</h1>
<p>硬件是运行游戏的物理设备，例如pc、xBox Series X、PS5、ns。</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023005.png?x-oss-process=style/WaterMask"
alt="PC" />
<figcaption aria-hidden="true">PC</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023017.png?x-oss-process=style/WaterMask"
alt="xBox Series X" />
<figcaption aria-hidden="true">xBox Series X</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023023.png?x-oss-process=style/WaterMask"
alt="PS5" />
<figcaption aria-hidden="true">PS5</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023028.png?x-oss-process=style/WaterMask"
alt="NS" />
<figcaption aria-hidden="true">NS</figcaption>
</figure>
<h1 id="驱动">驱动</h1>
<p>驱动是负责和硬件进行通信的底层软件，常见的驱动有显卡驱动（Nvidia、AMD）、声卡驱动。有了这些驱动之后，开发人员就不需要为具体的硬件设备编写代码。驱动很好地隐藏了硬件设备的复杂性，使开发工作的复杂度降低。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023101.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023109.png?x-oss-process=style/WaterMask" /></p>
<h1 id="操作系统">操作系统</h1>
<p>在操作系统层面上，大致上可以分成游戏专用操作系统和非游戏专用操作系统。</p>
<p>游戏专用操作系统有xbox的XBoxOS、ps4的Orbis
OS、ns的Horizon。这些操作系统的通常知识一个轻量级的库，在游戏运行时，游戏程序几乎可以占有硬件的所有资源和控制权，所以游戏运行效率很高。</p>
<p>而非游戏专用操作系统通常都会因为各种各样的原因只能占用硬件的部分资源和控制权，例如windows操作系统采用基于时间片(time-slice)的抢占式多任务(preemptive
multitasking)方式来运行所有程序。</p>
<p>这也是为什么同一款游戏在同样硬件性能的PC和PS3上面运行，PC上可能直接变成PPT，而PS3却可以30帧稳定运行。</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023136.png?x-oss-process=style/WaterMask"
alt="xbox的XBoxOS" />
<figcaption aria-hidden="true">xbox的XBoxOS</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023140.png?x-oss-process=style/WaterMask"
alt="ps4的Orbis OS" />
<figcaption aria-hidden="true">ps4的Orbis OS</figcaption>
</figure>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023144.png?x-oss-process=style/WaterMask"
alt="ns的Horizon" />
<figcaption aria-hidden="true">ns的Horizon</figcaption>
</figure>
<h1 id="软件开发包sdk">软件开发包(SDK)</h1>
<p>软件开发包一批功能良好的函数的集合，这些函数又称为称为API(application
programming interface)。</p>
<p>大部分游戏引擎都会接入第三方SDK以增强引擎的功能，通过接入SDK的方式给引擎增加功能可以减少引擎的研发压力，同时又能获得良好的效果表现。</p>
<p>下面列举一些比较常见的第三方SDK：</p>
<p>物理引擎有<a href="https://www.havok.com/">Havok</a>、<a
href="https://developer.nvidia.com/physx-sdk">PhysX</a>、<a
href="https://pybullet.org/wordpress/">Bullet</a>等。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023250.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023253.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023259.png?x-oss-process=style/WaterMask" /></p>
<p>动画引擎有<a href="https://www.havok.com/">Havok Animation</a>、<a
href="http://www.radgametools.com/cn/granny.html">Granny</a>等。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023326.png?x-oss-process=style/WaterMask" /></p>
<p>Havok Animation可以在运行时给动画加上物理效果，也就是<a
href="https://en.wikipedia.org/wiki/Physically_based_animation">物理动画技术(Physically
based animation)</a>。</p>
<p>动画的制作流程比较复杂繁琐，部分有钱的游戏厂商会通过动捕(motion
cap)的方式来制作动画，钱包确实顶不住的话可以使用Endorphin来自动生成帧动画，提高生产效率。还有一种减少工作量的方法，使用Euphoria在游戏运行时生成符合物理和生物力学的动画。</p>
<h1 id="平台独立层">平台独立层</h1>
<p>平台独立层会为特定模块封装各个平台的底层API，让游戏引擎可以支持在多个平台上运行。这一层算是游戏引擎和外界环境进行沟通的桥梁。
# 核心系统
核心系统会为游戏引擎提供一个软件该有的底层功能，所有类型的软件都会有这一层。</p>
<p>这一层的内容也不少，我们关注得比较多的是内容管理模块。因为游戏引擎往往都需要保证最多每隔32毫秒就要执行一边全体代码，对于内存的管理要求会比较高，需要实现高效地内存分配和释放，还会自定义数据结构及算法来减少或完全消除动态内存的分配。
# 渲染引擎
渲染这一块内容就比较丰富了，已经被独立成一个专业学科--计算机图形学。一般游戏引擎都不会去开发自己的渲染引擎，因为投入产出比太低，而且现有的渲染引擎已经很成熟了。所以游戏引擎一般都会接入已有的渲染引擎。</p>
<p>常见的渲染引擎有DirectX、OpenGL、Vulkan、Edge等。这里的Edge并不是指微软的Edge浏览器，而是专门为PS3渲染设计的，拥有高效几何处理技术的渲染引擎，同时它还具有动画播放功能。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023437.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023432.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023441.png?x-oss-process=style/WaterMask" /></p>
<p>渲染引擎一般会采用分层架构(layered
architecture)来组织代码，一般会被分为低阶渲染器(low-level
renderer)、场景图(scene graph)/剔除优化、视觉效果、前端。</p>
<p>低阶渲染器会使用图形SDK来设置好渲染器，实现几何图元(geometric
primitive)的高速渲染。</p>
<p>场景图/优化剔除会为不同的游戏场景提供不同的算法来限制提交到GPU的图元数量。常用的算法有平截头体剔除(frustum
cull)、空间细分(spatial
subdivision)、portal、遮挡剔除技术。其中空间细分算法可以使用不同的数据结构来构建场景图以快速判别潜在可见集(potentially
visible set, PVS)。</p>
<p>视觉效果层专门提供丰富的视觉效果，其中包括粒子系统(particle
system)、贴花系统(decal system)、光照贴图(light
mapping)、环境贴图(evironment mapping)、动态阴影(dynamic
shadow)、全屏后处理效果(full-screen post-processing
effect)等。其中全屏后处理效果包括高动态范围(high dynamic tange,
HDR)光照、敷霜效果(bloom)、全屏抗锯齿(full-screen anti-aliasing,
FSAA)、颜色较正(color
correction)等。其中颜色较正包括颜色偏移(color-shift)、略过漂白(bleach
bypass)、饱和度(saturation)、去饱和度(desaturation)等。美术师一般会在这一层上面进行工作。</p>
<p>前端是开发者、玩家与游戏进行交互的桥梁，包括了平视显示器(heads-up
display,
HUD)、辅助开发的工具（如内置菜单、主控台）、图形用户界面(graphical user
interface, GUI)、全动视频(full-motion video,
FMV)系统、游戏内置电影(in-game cinematics, IGC)系统等。</p>
<h1 id="人工智能">人工智能</h1>
<p>游戏中的传统人工智能并不是类似于深度学习的人工智能，而只是让角色看起来有智能。所有貌似拥有智能的行为都是提前硬编码好的，有限状态机和行为树是最常用的技术。现在游戏也慢慢开始加入了具有自我进化能力的人工智能，以后游戏过程中的不确定性会进一步增加。
# 性能分析工具
为了提升游戏运行效率，需要在研发过程中或研发完成时对游戏进行性能分析。现在比较成熟的性能分析工具有Intel的VTune、IBM的Quantify和Purify、Compuware的Bounds
Checker。有些游戏引擎会开发自己的性能分析工具，例如unty内置的Profiler。一个性能分析工具大致需要具备以下功能：</p>
<ol type="1">
<li>支持在游戏源码中手动加入测量代码，为希望监测性能的代码进行计时。</li>
<li>游戏运行期间，在屏幕上显示性能统计数据，这些数据包裹CPU占用率、GPU占用率、显存占用量、内存占用量、内存使用率、1.
最高使用率、内存泄漏量、网络延迟、FPS等。</li>
<li>将性能统计数据输出并保存下来，可以保存为文本文件、Excel文件等。</li>
<li>允许在代码内使用调试用打印语句(print
statement)，可以切换不同的调试输出种类，并设置输出的冗长级别(verbosity
level)。 # 物理
游戏物理模拟是个大部头，如果项目有真实物理模拟的需求，那么一般会专门配置一位负责开发物理效果的程序员。</li>
</ol>
<p>游戏物理和仿真物理的侧重点并不相同。仿真物理注重模拟效果的准确性，而不关注性能。游戏物理不追求模拟百分百正确，只要最终的效果看起来合理就好，需要特别关注性能表现。因为游戏需要在配置一般的设备上运行，没有太多的算了投放到物理模拟中。只要效果看起来没太大问题，那么它就是对的。
# 动画
动画同样是一个大部头，如果项目的动画很多且复杂细腻，一般也会专门配置一位专门负责开发动画效果的程序员。</p>
<p>动画效果可以很简单，也可以很复杂。最简单的就是播放单个帧动画，复杂的可以搞基于物理的动画、IK效果等。</p>
<p>负责游戏动画的程序员除了要做好表现效果之外，还要做好资源管理，包括动画资源和动画状态机资源。因为现在大部分项目都是使用动画状态机以及动画融合技术来制作动画效果。</p>
<p>一个表现效果可能由多个动画clip融合而成。使用这种方案来做动画表现，产出的动画资源一般都不少。</p>
<p>如果某个模型的动画表现比较细腻的话，它的动画状态机也会很复杂。我曾经见过一个动画状态机打开之后整个屏幕都是密密麻麻的transition连线。</p>
<h1 id="人体学接口设备hid引擎">人体学接口设备(HID)引擎</h1>
<p>HID引擎会将游戏外设和游戏引擎对接起来。比较常见的游戏外设有键盘、鼠标、手柄。还有一些比较小众的游戏外设，例如赛车模拟设备（方向盘+踏板+挡杆+手刹）、飞行摇杆、VR控制器。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023604.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023609.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023615.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023621.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023625.png?x-oss-process=style/WaterMask" /></p>
<p>游戏外设的输入信号会先被映射为输入代码，再映射为游戏的具体操作。</p>
<h1 id="音频">音频</h1>
<p>游戏的音频也同样重要，好的音频效果可以营造良好的游戏氛围。一般游戏引擎都有自己研发的音频功能，例如cocos、unity、unreal都有。但是在游戏开发过程中一般不会直接使用引擎提供的功能，而是会使用第三方SDK，例如<a
href="https://www.fmod.com/">FMOD</a>、<a
href="https://www.audiokinetic.com/zh/products/wwise/">Wwise</a>。因为第三方SDK功能更加完备。</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102024059.png?x-oss-process=style/WaterMask" /></p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102023711.png?x-oss-process=style/WaterMask" /></p>
<h1 id="网络">网络</h1>
<p>游戏引擎提供基本网络通信功能并不是什么特别难的事情，但是要提供一套成熟通用的网络同步功能非常困难。不同游戏对网络同步的需求由很大的区别，所以游戏项目组一般都会开发自己的网络同步功能以匹配自己的游戏业务需求。
# 数字内容创作(digital content creation, DCC)应用软件及资产调节管道
设计师会通过DCC工具将模型、材质、贴图、音频等工具生产游戏素材。团队一般都会使用市面上以由的DCC工具，例如3DMax、Maya、PhotoShop、FMOD
Studio等。这些工具输出的资源格式在大部分情况下没有办法被游戏引擎直接使用，需要游戏引擎对这些资源进行一次转换，转换为游戏引擎方便使用的格式。这个转换过程有资产调节管道来完成。例如每次往unity中拖入fbx模型资源的时候都会出现一个import进度条，正是在进行资源转换。
# 最后
这节只是简单带过了各种模块的知识，由于部分内容展开之后量会非常大，所以会在该系列的后续文章中单独讲，也可能会另开一个专栏。希望能帮助到想要从事游戏研发的人。
# 参考资料 《游戏引擎架构》 《游戏编程权威指南》
《GAMES104-现代游戏引擎：从入门到实践》</p>
]]></content>
      <categories>
        <category>游戏引擎</category>
      </categories>
      <tags>
        <tag>游戏引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>番外篇--深扒C++函数</title>
    <url>/posts/f02e98d5.html</url>
    <content><![CDATA[<h1 id="函数指针">函数指针</h1>
<p>获取函数的地址：函数的名字就是地址</p>
<p>函数指针声明与使用：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//函数原型</span><br><span class="hljs-built_in">double</span> pam(<span class="hljs-built_in">int</span>);			<br><br><span class="hljs-comment">//函数指针声明和赋值</span><br><span class="hljs-built_in">double</span> (*pf)(<span class="hljs-built_in">int</span>);		<span class="hljs-comment">//函数指针声明</span><br>pf=pam;				<span class="hljs-comment">//函数指针赋值</span><br><span class="hljs-built_in">double</span> (*pf)(<span class="hljs-built_in">int</span>)=pam;		<span class="hljs-comment">//函数指针声明和赋值</span><br><span class="hljs-built_in">auto</span> pf=pam;			<span class="hljs-comment">//使用C++11的自动类型推断来声明和赋值</span><br><br><span class="hljs-comment">//使用</span><br>pf(<span class="hljs-number">123</span>);<br>(*pf)(<span class="hljs-number">123</span>);			<span class="hljs-comment">//注意(*pf)的括号一定要保留下来，不然意义就不同了</span><br>pam(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//这三种形式等价,之所以会这样是因为两种学派的理解不同；而我个人认为第一种用法比第二种用法合理；以后在使用时看到(*pf)(123)，你直接看成pf(123)即可，将(*)看成多余的就好</span><br><br>---------------------------------------------------------------------------------------<br><br><span class="hljs-comment">//函数原型</span><br><span class="hljs-built_in">double</span> f1(<span class="hljs-built_in">int</span>);<br><span class="hljs-built_in">double</span> f2(<span class="hljs-built_in">int</span>);	<br><span class="hljs-built_in">double</span> f3(<span class="hljs-built_in">int</span>);				<br><br><span class="hljs-comment">//函数指针数组的声明和赋值</span><br><span class="hljs-built_in">double</span> (*pfa[<span class="hljs-number">3</span>])(<span class="hljs-built_in">int</span>);			<span class="hljs-comment">//函数指针数组的声明</span><br>pfa[<span class="hljs-number">0</span>]=f1;				<span class="hljs-comment">//函数指针数组的赋值示例</span><br><span class="hljs-built_in">double</span> (*pfa[<span class="hljs-number">3</span>])(<span class="hljs-built_in">int</span>)=&#123;f1,f2,f3&#125;;	<span class="hljs-comment">//函数指针数组的声明和赋值</span><br><span class="hljs-comment">//不可以使用auto来自动初始化，因为auto只能用于单值初始化,而不能初始化列表</span><br><span class="hljs-comment">//ps：初始化=声明+赋值；初始化列表就是&#123;&#125;</span><br><br>---------------------------------------------------------------------------------------<br><br><span class="hljs-comment">//老实说，C++的指针声明挺复杂，如果能够很好的理解下面的声明，就证明你对C++的声明了如指掌了</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> *(*(*pd)[<span class="hljs-number">3</span>])(<span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> *,<span class="hljs-built_in">int</span>);<br><span class="hljs-comment">//理解所有指针声明的要点是，从里向外去解读；注意[]的优先级比*高</span><br><br>---------------------------------------------------------------------------------------<br><span class="hljs-comment">//要简化函数指针的声明过程，除了使用auto之外，还可以使用typedef，例如：</span><br><br><span class="hljs-comment">//函数原型</span><br><span class="hljs-built_in">double</span> pam(<span class="hljs-built_in">int</span>);<br><br><span class="hljs-comment">//将函数指针类型弄成标识符形式</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">double</span> (*p_func)(<span class="hljs-built_in">int</span>);<br><br><span class="hljs-comment">//函数指针声明</span><br>p_func pf;<br></code></pre></td></tr></table></figure>
<h2 id="非静态类成员函数指针">非静态类成员函数指针</h2>
<p>与类的非静态数据成员变量不同，类的非静态成员函数不会在运行时为每个类的实例对象生成一份专有的机器语言代码，类的非静态成员函数在内存中只有一份，即类的非静态成员函数的地址也是唯一的。那么为什么不同的实例调用非静态成员函数的时可以访问到属于实例本身的数据呢？这是因为非静态成员函数默认的第一个参数就是this指针，只是没有明写出来罢了</p>
<p>类的非静态成员函数默认的第一参数就是this</p>
<p>受this指针的影响， 非静态类成员函数指针 的声明和使用与
一般的函数指针（含静态成员函数指针） 都不同</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>类的非静态成员函数指针 声明、赋值、使用 都跟普通情况不同<br><span class="hljs-regexp">//</span>声明时需要添加类名<br>int (classA::*pFun)(int);		<span class="hljs-regexp">//</span>注意类名放置的位置，类名是用来指明this指针的类型的<br><span class="hljs-regexp">//</span>赋值时需要添加类名和&amp;<br>pFun=&amp;classA::Fun;<br><span class="hljs-regexp">//</span>使用时需要加上实例对象<br>(classAInstance-&gt;*pFun)(<span class="hljs-number">12345</span>);		<span class="hljs-regexp">//</span>注意一个<span class="hljs-string">&#x27;(&#x27;</span>、<span class="hljs-string">&#x27;)&#x27;</span>，<span class="hljs-string">&#x27;*&#x27;</span>都不能少，格式就这样死死固定住了；<br>					<span class="hljs-regexp">//</span>如果这个语句出现在非静态成员函数中，不要认为classAInstance不写系统会自动加上this;如果你是想调用this的pFun就自己手动加上，不然会报错，<br><br><br><span class="hljs-regexp">//</span>类的静态成员函数指针 声明、赋值、使用<br><span class="hljs-regexp">//</span>声明时<br>int (*pFun)(int);<br><span class="hljs-regexp">//</span>赋值时需要添加类名<br>pFun=classA::Fun;<br><span class="hljs-regexp">//</span>使用时<br>pFun(<span class="hljs-number">12345</span>);		<span class="hljs-regexp">//</span>或<br>(*pFun)(<span class="hljs-number">12345</span>);<br></code></pre></td></tr></table></figure>
<h1 id="函数模板">函数模板</h1>
<p>函数模板将类型作为参数传递给函数模板，使编译器生成该类型的函数；又叫通用编程或参数化类型；</p>
<p>由函数模板对应的具体函数称为称为模板实例(instantiation)</p>
<p>隐式实例化、显式实例化、显式具体化统称为具体化(specialization)</p>
<p>类型参数不能有默认值，但是非类型参数可以有默认值</p>
<h2 id="函数模板的声明格式">函数模板的声明格式</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// T 叫做类型参数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;			<span class="hljs-comment">//可以写成 template&lt;class T&gt;，但是这个是C++98之前的写法；typename这个关键字是C++98定义的；函数模板参数列表中可以有多个参数，如template&lt;typename T1,typename T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;a,T &amp;b)</span></span>;			<span class="hljs-comment">//返回类型可以不可也写成T？？？</span><br></code></pre></td></tr></table></figure>
<h2 id="函数模板的定义格式">函数模板的定义格式</h2>
<p>这只是一个函数模板，并不是函数；函数模板用于告诉编译器如何定义函数；只有在编译时检测到代码中需要用到这个模板，编译器才会依据具体类型按照模板格式生成模板实例，这个过程称为隐式实例化(implicit
instantiation)</p>
<p>编译结束之后机器码中并没有函数模板，只可能存在模板实例的机器码</p>
<p>模板函数的定义可以放在使用到函数模板的函数后面</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">template&lt;typename T&gt;			<br>void Swap(T &amp;a,T &amp;b)<br>&#123;<br>	T temp;<br>	<span class="hljs-attribute">temp</span>=a;<br>	<span class="hljs-attribute">a</span>=b;<br>	<span class="hljs-attribute">b</span>=temp;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="模板函数的使用">模板函数的使用</h2>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>使用时都不用指明类型，编译器会自动检测参数列表的数据类型来确定函数的类型<br>int main()<br>&#123;<br>	int i=<span class="hljs-number">10</span>;<br>	int j=<span class="hljs-number">20</span>;<br>	<br>	Swap(i,j);		<span class="hljs-regexp">//</span>隐式实例化<br>	Swap&lt;&gt;(i,j);	<span class="hljs-regexp">//</span>不带参数的显式实例化，确保编译器使用函数模板的实例化版本<br><br>	double x=<span class="hljs-number">1.3</span>;<br>	double y=<span class="hljs-number">3.6</span>;<br><br>	Swap(x,y);		<span class="hljs-regexp">//</span>隐式实例化<br>	Swap&lt;&gt;(x,y);	<span class="hljs-regexp">//</span>不带参数的显式实例化，确保编译器使用函数模板的实例化版本<br><br>	<span class="hljs-regexp">//</span>疑问：<br>	<span class="hljs-regexp">//</span>Swap(i,x);	<span class="hljs-regexp">//</span>会怎样？<br><br>	return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="函数模板的重载">函数模板的重载</h1>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">template&lt;typename T&gt;			<br>void <span class="hljs-constructor">Swap(T &amp;<span class="hljs-params">a</span>,T &amp;<span class="hljs-params">b</span>)</span><br>&#123;<br>	T temp;<br>	temp=a;<br>	a=b;<br>	b=temp;<br>&#125;<br><br>template&lt;typename T&gt;<br>void <span class="hljs-constructor">Swap(T <span class="hljs-operator">*</span><span class="hljs-params">a</span>,T <span class="hljs-operator">*</span><span class="hljs-params">b</span>,<span class="hljs-params">int</span> <span class="hljs-params">n</span>)</span><br>&#123;<br>	T temep;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>	&#123;<br>		temp=a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>		a<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=b<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>		b<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=temp;<br>	&#125;<br>&#125;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span><br>&#123;<br>	<span class="hljs-built_in">int</span> i=<span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">int</span> j=<span class="hljs-number">20</span>;<br>	<br>	<span class="hljs-constructor">Swap(<span class="hljs-params">i</span>,<span class="hljs-params">j</span>)</span>;<br><br>	<span class="hljs-built_in">int</span> array1<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>	<span class="hljs-built_in">int</span> array2<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br><br>	<span class="hljs-constructor">Swap(<span class="hljs-params">array1</span>.<span class="hljs-params">array2</span>)</span>;<br><br>	return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="函数模板的局限性">函数模板的局限性</h1>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">template &lt;typename T&gt;<br>void f(T a,T b)<br>&#123;<br>	<span class="hljs-regexp">//</span>a=b;	<span class="hljs-regexp">//</span>原本是想做内容赋值操作的，但如果T类型是数组指针，那么最终只是a变成了b的指针，a并没有获得b数组的内容；又或者当前T类型并没有<span class="hljs-string">&#x27;=&#x27;</span>操作;<br>	<span class="hljs-regexp">//</span>a&gt;b;	<span class="hljs-regexp">//</span>原本是想做内容比较操作的，但如果T类型是数组指针，那么最终只是比较了a指针和b指针，并没有进行内容比较；又或者当前T类型并没有<span class="hljs-string">&#x27;&gt;&#x27;</span>操作;<br>	<span class="hljs-regexp">//</span>以后注意T只处理非数组类型，T*才是用来处理数组类型的；<br>&#125;<br></code></pre></td></tr></table></figure>
<h1
id="函数模板的显式具体化explicit-specialization">函数模板的显式具体化(explicit
specialization)</h1>
<p>所谓的显式具体化就是手动写一个函数模板的模板实例</p>
<p>函数模板显式具体化的声明格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;,T &amp;)</span></span>;<br><br><span class="hljs-comment">//函数模板的显式具体化，第一种写法</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;job&gt;(job &amp;,job &amp;);	<span class="hljs-comment">//注意参数列表一定要和对应的模板相同；</span><br><br><span class="hljs-comment">//函数模板的显式具体化，第二种写法</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(job &amp;,job &amp;)</span></span>;			<span class="hljs-comment">//注意参数列表一定要和对应的模板相同；</span><br></code></pre></td></tr></table></figure>
<p>如果一个名称f同时存在非模板函数、
显式具体化函数、常规模板，将遵循第三代函数使用优先顺序(C++98标准)：非模板函数
&gt; 显式具体化函数 &gt; 常规模板</p>
<h1 id="实例化和具体化">实例化和具体化</h1>
<ul>
<li>实例化和具体化是不同的概念：
<ul>
<li>实例化是由编译器自动生成模板实例的过程</li>
<li>具体化是手动写出一个模板实例的过程</li>
<li>实例化 template 后面没有 &lt;&gt;</li>
<li>具体化 template 后面有 &lt;&gt;</li>
</ul></li>
</ul>
<h2 id="显式实例化explicit-instantiation的方法">显式实例化(explicit
instantiation)的方法</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(T &amp;,T &amp;)</span></span>;<br><br><span class="hljs-comment">//函数模板的显式实例化，第一种方式</span><br><span class="hljs-keyword">template</span> <span class="hljs-type">void</span> <span class="hljs-built_in">Swap</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>);	<span class="hljs-comment">//编译器看到这条指令将马上自动生成Swap的int版本，不必等到调用；这样做有什么用？</span><br><br><span class="hljs-comment">//函数模板的显式实例化，第二种方式</span><br>...主函数中<br>	<span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>	<span class="hljs-type">double</span> x=<span class="hljs-number">1.3</span>;<br>	<span class="hljs-built_in">Swap</span>&lt;<span class="hljs-type">double</span>&gt;(i,x);				<span class="hljs-comment">//生成Swap的double类型的实例以备调用，如果没有显式实例化的话，到这里会报错；因为没有办法隐式实例化；	</span><br>									<span class="hljs-comment">//ps：但是其实即使使用了显式化，这里由于Swap的参数是double引用类型，可是变量i是int类型；同样会报错，除非Swap函数参数列表改成Swap(const T &amp;,T &amp;)，[笑哭.jpg]这样有意思吗</span><br>...<br></code></pre></td></tr></table></figure>
<p>ps：同一个文件中如果同时出现同一类型函数的 显式实例化 和 显式具体化
，将出错</p>
<h1 id="编译器选择使用哪个函数版本">编译器选择使用哪个函数版本</h1>
<p>重载解析(overloading
resolution)：面对函数重载、函数模板、函数模板重载时，C++决定使用哪一个函数的过程</p>
<p>详细解释这个策略需要将近一章的篇幅= =，下面只讲大致步骤</p>
<h2
id="函数调用的步骤假设函数调用为mayb">函数调用的步骤(假设函数调用为may('B'))</h2>
<ol type="1">
<li>先找出所有名称为may的函数</li>
<li>再从这些函数中找出可以只接受一个参数'B'的may函数(实参类型可强转为形参类型的也算)</li>
<li>再从这些函数中选择一个最佳函数，优先级为： 常规函数完全匹配 &gt;
模板函数完全匹配 &gt;
提升转换(例：char和short自动转为int，float自动转为double) &gt;
标准转换(例：int转换为char，long转换为double) &gt; 用户定义的转换</li>
</ol>
<p>完全匹配：实参类型与形参类型完全等价，等价表如下所示：</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221108011130.png?x-oss-process=style/WaterMask" /></p>
<p>ps：倒数第二列是不是错了？？？</p>
<ul>
<li>如果使用以上优先级选择之后还是剩下一个以上的完全匹配函数，那么将要使用以下规则继续筛选：
<ul>
<li>非模板函数优先于模板函数</li>
<li>非const的指针和引用的实参优先与非const的指针和引用的形参配对</li>
<li>如果剩下的都是完全匹配的模板函数，则使用函数模板的部分排序规则(partial
ordering
rules)(C++98特性，主要是处理指针与非指针的问题)来选择最具体的</li>
</ul></li>
</ul>
<p>如果使用以上规则选择之后还是剩下一个以上的候选函数，那么编译器将报错；</p>
<p>例子：调用函数map('B');</p>
<table>

<thead>
<tr class="header">
<th style="text-align: center;">编号</th>
<th style="text-align: left;">候选函数</th>
<th style="text-align: center;">第一步结果</th>
<th style="text-align: center;">第二部结果</th>
<th style="text-align: center;">优先级</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: left;">void may(int);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: left;">void may(double,double);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: left;">float may(float,float = 3);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: left;">void may(char);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: left;">char * may(const char *);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: left;">char may(const char &amp;);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: left;">template&lt; typename T &gt; void
may(const T &amp;);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">8</td>
<td style="text-align: left;">template&lt; typename T &gt; void may(T
*);</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>ps：整数类型是不会隐式转换成指针的</p>
<p>以上只是介绍了单参函数调用的函数原型匹配问题，若是有多个参数，情况将非常复杂；这里不再介绍</p>
<h1 id="模板函数的发展">模板函数的发展</h1>
<h2 id="问题一">问题一</h2>
<p>在C++98标准下的函数模板存在着很多不完美的地方，有时候由于不知道具体的类型是什么，导致无法正常编写函数模板定义,例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ft</span><span class="hljs-params">(T1 x,T2 y)</span></span><br><span class="hljs-function"></span>&#123;<br>	...<br>	?type? xpy = x + y;		<span class="hljs-comment">//这时不知道xpy要定义为什么类型才能正确接收到结果</span><br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了解决上面的问题，C++11引入了一种新的声明数据类型方式,使用关键字decltype</p>
<p>decltype是在运行时确定变量类型的</p>
<p>decltype确定类型的方式，满足以下哪个形式就用哪个形式的判定方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//形式一：</span><br>...<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">decltype</span>&#123;x&#125; y;			<span class="hljs-comment">//判定方法：y的类型将为&#123;&#125;中的**数值**类型；这里y的类型将会是int</span><br><br><span class="hljs-comment">//更多例子：</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> &amp;k = j;<br><span class="hljs-type">int</span> &amp;n = j;<br><span class="hljs-keyword">decltype</span>(j+<span class="hljs-number">6</span>) i1;		<span class="hljs-comment">//i1的类型为	int		</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-number">100L</span>) i2;		<span class="hljs-comment">//i2的类型为	long	</span><br><span class="hljs-keyword">decltype</span>(k+n) i3;		<span class="hljs-comment">//i3的类型为 int</span><br>...<br></code></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//形式二：</span><br>...<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">indeed</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;		<span class="hljs-comment">//函数声明</span><br><span class="hljs-keyword">decltype</span>&#123;<span class="hljs-built_in">indeed</span>(<span class="hljs-number">3</span>)&#125; y;	<span class="hljs-comment">//判定方法：y的类型将为&#123;&#125;中函数的返回值类型；这里y的类型将会是long（书上写说y的类型是int，错了吧？）</span><br>						<span class="hljs-comment">//注意：indeed(3)并不会真的被调用</span><br>...<br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>形式三：<br>...<br>double xx = <span class="hljs-number">4.4</span>;<br>decltype&#123;(xx)&#125; y;		<span class="hljs-regexp">//</span>判定方法：y的类型将为&#123;&#125;中变量类型的引用；这里y的类型将会是double &amp;<br>						<span class="hljs-regexp">//</span>注意：这里的括号不能省略且括号中必须是变量(左值)<br><br><br><span class="hljs-regexp">//</span>这里引入一个和函数模板话题不沾边的小概念：<br><span class="hljs-regexp">//</span>xx = <span class="hljs-number">98.6</span>;<br><span class="hljs-regexp">//</span>(xx) = <span class="hljs-number">98.6</span>;<br><span class="hljs-regexp">//</span>以上的两条表达式的作用是一样的，就是赋值，无差别<br>...<br></code></pre></td></tr></table></figure>
<p>于是上面的问题就可以解决：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ft</span><span class="hljs-params">(T1 x,T2 y)</span></span><br><span class="hljs-function"></span>&#123;<br>	...<br>	<span class="hljs-keyword">decltype</span>&#123;x + y&#125; xpy = x + y;	<span class="hljs-comment">//xpy的类型就是x+y得到的结果数值的类型</span><br>	...<br><br>	<span class="hljs-comment">//如果要多次使用上面这种类型，每次都要写这么长，会觉得很麻烦，那么可以使用关键字typedef，例：</span><br>	typrdef <span class="hljs-keyword">decltype</span>&#123;x + y&#125; xpytype;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="问题二">问题二</h2>
<p>但是即使有了decltype还是存在问题，有时函数返回类型不能确定，例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">template</span>&lt;typename <span class="hljs-type">T1</span>,typename <span class="hljs-type">T2</span>&gt;<br>?<span class="hljs-class"><span class="hljs-keyword">type</span>? gt(<span class="hljs-type">T1</span> <span class="hljs-title">x</span>,<span class="hljs-type">T2</span> <span class="hljs-title">y</span>)					//返回类型无法确定，无法将?<span class="hljs-keyword">type</span>?改为decltype&#123;<span class="hljs-title">x</span> + <span class="hljs-title">y</span>&#125;，因为那时x和y还没有声明</span><br>&#123;<br>	&#x27;&#x27;&#x27;<br>	return x + y;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了解决上面的问题，C++11引入了一个新语法后置返回类型，格式为：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">auto</span> h(<span class="hljs-built_in">int</span> x,<span class="hljs-built_in">float</span> y) -&gt; <span class="hljs-built_in">double</span>;<br><span class="hljs-comment">//该函数的返回类型是double，auto只是占位用的</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>算法题--旋转数组的最小数字</title>
    <url>/posts/2bc2b764.html</url>
    <content><![CDATA[<p>8 # 要求</p>
<p>时间限制：3秒 空间限制：32768K</p>
<h1 id="题目描述">题目描述</h1>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h1 id="解题思路">解题思路</h1>
<p>首先对数组进行观察，发现最小的那个数一定在两个子数组的交界处。并且左边的子数组一定比右边的子数组要大</p>
<p>根据上面找到的性质，可以简单的想到顺序搜索，找出它们交界处即可；但是时间复杂度为O(n)</p>
<p>如果要求时间复杂度更低，这里可以采用二分查找法，这样时间复杂度就可以变成O(logn)</p>
<p>算法执行过程如下图所示：</p>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221109014437.png?x-oss-process=style/WaterMask"
alt="每次循环都会计算出P1和P2的中间位置mid，对比P1、mid、P2之间的大小就可以确定mid所在的子数组，然后相应的修改P1或者P2为mid。这么做是为了让P1和P2向交界处逼近。" />
<figcaption
aria-hidden="true">每次循环都会计算出P1和P2的中间位置mid，对比P1、mid、P2之间的大小就可以确定mid所在的子数组，然后相应的修改P1或者P2为mid。这么做是为了让P1和P2向交界处逼近。</figcaption>
</figure>
<p>这道题还要考虑一些特殊情况：</p>
<ol type="1">
<li><span
class="math inline">\(a[P1]==a[mid]==a[P2]\)</span>，如下图所示</li>
</ol>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221109014522.png?x-oss-process=style/WaterMask"
alt="20221109014522" />
<figcaption aria-hidden="true">20221109014522</figcaption>
</figure>
<ol start="2" type="1">
<li><p>数组本身就是排好序的，没有旋转也算是一种旋转</p></li>
<li><p>数组只有一个数字的情况</p></li>
</ol>
<h1 id="c代码">C++代码</h1>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>  <span class="hljs-built_in">int</span> min<span class="hljs-constructor">NumberInRotateArray(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; <span class="hljs-params">rotateArray</span>)</span> &#123;<br>  <span class="hljs-built_in">int</span> size = rotateArray.size<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span>(size<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)&#123;<br>      return <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">int</span> leftIdx = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> rightIdx = size - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//特殊情况，没有旋转</span><br>    <span class="hljs-keyword">if</span>(rotateArray<span class="hljs-literal">[<span class="hljs-identifier">leftIdx</span>]</span> &lt; rotateArray<span class="hljs-literal">[<span class="hljs-identifier">rightIdx</span>]</span>)<br>      return rotateArray<span class="hljs-literal">[<span class="hljs-identifier">leftIdx</span>]</span>;<br>    <br>    <span class="hljs-built_in">int</span> midIdx=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(rightIdx - leftIdx != <span class="hljs-number">1</span>)&#123;<br>      midIdx = (leftIdx + rightIdx)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">if</span>(rotateArray<span class="hljs-literal">[<span class="hljs-identifier">leftIdx</span>]</span><span class="hljs-operator"> == </span>rotateArray<span class="hljs-literal">[<span class="hljs-identifier">midIdx</span>]</span><span class="hljs-operator"> &amp;&amp; </span>rotateArray<span class="hljs-literal">[<span class="hljs-identifier">midIdx</span>]</span><span class="hljs-operator"> == </span>rotateArray<span class="hljs-literal">[<span class="hljs-identifier">rightIdx</span>]</span>)&#123;<br>        <span class="hljs-comment">//直接用顺序查找</span><br>        return order<span class="hljs-constructor">Search(<span class="hljs-params">rotateArray</span>, <span class="hljs-params">leftIdx</span>, <span class="hljs-params">rightIdx</span>)</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rotateArray<span class="hljs-literal">[<span class="hljs-identifier">midIdx</span>]</span> &gt; rotateArray<span class="hljs-literal">[<span class="hljs-identifier">rightIdx</span>]</span>)&#123;<br>        leftIdx = midIdx;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rotateArray<span class="hljs-literal">[<span class="hljs-identifier">leftIdx</span>]</span> &gt; rotateArray<span class="hljs-literal">[<span class="hljs-identifier">midIdx</span>]</span>)&#123;<br>        rightIdx = midIdx;<br>      &#125;<br>    &#125;<br>    <br>    return rotateArray<span class="hljs-literal">[<span class="hljs-identifier">rightIdx</span>]</span>;<br>  &#125;<br>  <br>  <span class="hljs-built_in">int</span> order<span class="hljs-constructor">Search(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt; &amp;<span class="hljs-params">rotateArray</span>, <span class="hljs-params">int</span> <span class="hljs-params">leftIdx</span>, <span class="hljs-params">int</span> <span class="hljs-params">rightIdx</span>)</span>&#123;<br>    <span class="hljs-built_in">int</span> minVal=rotateArray<span class="hljs-literal">[<span class="hljs-identifier">leftIdx</span>]</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = leftIdx + <span class="hljs-number">1</span>;i &lt;= rightIdx;++i)&#123;<br>      <span class="hljs-keyword">if</span>(rotateArray<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt; minVal)<br>        minVal=rotateArray<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    &#125;<br>    return minVal;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法题--斐波那契数列</title>
    <url>/posts/3af7c65a.html</url>
    <content><![CDATA[<p>9</p>
<h1 id="要求">要求</h1>
<p>时间限制：1秒 空间限制：32768K</p>
<h1 id="题目描述">题目描述</h1>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。</p>
<p>n&lt;=39</p>
<h1 id="解题思路">解题思路</h1>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221109014742.png?x-oss-process=style/WaterMask" /></p>
<p>这道题可以直接用递归来解决，但是递归速度慢(函数调用、重复计算)、容易导致栈溢出(函数调用层级多)
重复计算如下图所示：</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221109014758.png?x-oss-process=style/WaterMask" /></p>
<p>重复计算的问题可以用一个memory来解决，也就变成了top-down形式的动态规划</p>
<p>为了减少函数调用，使用down-top形式的动态规划来解决</p>
<p>一般只要能写出状态转换方程就可以写出down-top动态规划</p>
<h1 id="c代码">C++代码</h1>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//斐波那契数列：f(n)=f(n-1)+f(n-2),n&gt;=2,f(0)=0,f(1)=1</span><br><span class="hljs-comment">//此代码已经降维，由一维数组降成了两个点(last和lastlast)，因为每一个状态都只用到了之前的两个状态</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">int</span> Fibonacci(<span class="hljs-built_in">int</span> n) &#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">int</span> lastlast = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> last = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>;i &lt;= n;++i)&#123;<br>      cur = last + lastlast;<br>      lastlast = last;<br>      last = cur;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> cur;<br>  &#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>常用设计模式讲解(史上最简短)</title>
    <url>/posts/517ed801.html</url>
    <content><![CDATA[<blockquote>
<p>这篇文章会简单粗暴地讲解一下常用设计模式，算是一个汇总，不会作详细地讲解</p>
</blockquote>
<p>系统设计从设计原则开始，在过程中会自然而然发现需要加入模式的地方。所有的原则都不是必须遵守的，要考虑全局进行舍取，常常要折中。</p>
<p>所有的设计模式都是一种思想，即使在某种场合下没有办法实现常规的写法，但是用到它们的思想就可以了。尽可能保持设计的简单，只有真正需要模式时才使用，复杂度一般与灵活性正相关。</p>
<p>使用设计模式的目的:在不改变设计好的运行框架的前提下，需增加功能是只需要额外添加一个类，然后就可以在系统运行时增加功能</p>
<h1 id="适配器模式">适配器模式</h1>
<p>能够被适配的目标类一定有着可重写的接口，能够被适配的目标函数一定是虚函数</p>
<h2 id="代码">代码</h2>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Adapter</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">absClassA</span><br>&#123;<br>  absClassB* realInstance;   <span class="hljs-comment">//被适配</span><br>  def func() <span class="hljs-keyword">override</span><br>  &#123;<br>    <span class="hljs-comment">//Todo：调用realInstance的一些方法</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="设计原则">设计原则</h2>
<p>尽量减少一个类中对于其它类的引用，以减少调用一个功能需要.出来的次数</p>
<h1 id="装饰者模式">装饰者模式</h1>
<blockquote>
<p>这个模式中使用继承是为了能够做到类型匹配，因为一个对象在被装饰之后还必须是原来的那个对象类型。不能因为装饰而改变自己的类型。一个化了妆的人还是一个人</p>
</blockquote>
<p>能够被装饰的类一定有着可重写的接口，能够被装饰的函数一定是虚函数</p>
<h2 id="代码-1">代码</h2>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">class Decorator : absClass<br>&#123;<br>  absClass* realInstance;    <span class="hljs-regexp">//</span>被装饰者<br>  def <span class="hljs-keyword">func</span>() override<br>  &#123;<br>    realInstance-&gt;<span class="hljs-keyword">func</span>();<br>    <span class="hljs-regexp">//</span>Todo：<span class="hljs-keyword">do</span> more something<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="设计原则-1">设计原则</h2>
<p>对扩展开放，对修改关闭</p>
<h1 id="代理模式">代理模式</h1>
<blockquote>
<p>代理（proxy）：代表特定实例</p>
</blockquote>
<p>能够被代理的类一定有着可重写的接口，能够被代理化的函数一定是虚函数</p>
<p>创建代理通常会使用工厂方法</p>
<h2 id="代码-2">代码</h2>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">class Proxy : absClass<br>&#123;<br>  absClass* realInstance;<br>  void <span class="hljs-keyword">func</span>() override<br>  &#123;<br><span class="hljs-comment">#if 0</span><br>    <span class="hljs-regexp">//</span>保护代理<br>    <span class="hljs-regexp">//</span>通过一些条件控制对realInstance的访问<br>    <span class="hljs-keyword">if</span>(满足条件)<br>      realInstance-&gt;<span class="hljs-keyword">func</span>();<br><span class="hljs-comment">#elif 0</span><br>    <span class="hljs-regexp">//</span>虚拟代理<br>    <span class="hljs-keyword">if</span>(realInstance != NULL)<br>      realInstance-&gt;<span class="hljs-keyword">func</span>();<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-regexp">//</span>开启异步线程创建absClass实例<br>      <span class="hljs-regexp">//</span>或 执行默认操作<br><span class="hljs-comment">#else</span><br>    <span class="hljs-regexp">//</span>远程代理<br>    realInstance-&gt;<span class="hljs-keyword">func</span>();  <span class="hljs-regexp">//</span><span class="hljs-keyword">func</span>通过网络和远程实例通信<br><span class="hljs-comment">#endif</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="对比">对比</h2>
<p>装饰者模式的目的是为对象加上行为，而代理模式的目的是控制对对象的访问</p>
<h2 id="其他代理">其他代理</h2>
<ul>
<li>远程代理：代表特定远程实例</li>
<li>防火墙代理：公司防火墙系统</li>
<li>智能引用代理：引用计数</li>
<li>缓存代理：Web服务器</li>
<li>同步代理：JavaSpace</li>
<li>复杂隐藏代理（外观理解）：字典</li>
<li>写入时复制代理：Java5的CopyOnWriteArrayList</li>
</ul>
<h1 id="观察者模式">观察者模式</h1>
<blockquote>
<p>观察感兴趣的事物 或者 事情</p>
</blockquote>
<h2 id="代码-3">代码</h2>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">class Subject	<span class="hljs-regexp">//</span>可以被包含<br>&#123;<br>  absClass*[] observers;	<span class="hljs-regexp">//</span>核心数据结构<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="设计原则-2">设计原则</h2>
<p>对象之间保持松耦合</p>
<h1 id="迭代器与组合模式">迭代器与组合模式</h1>
<h2 id="组合模式代码">组合模式代码</h2>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">xxx:<span class="hljs-symbol">absClass</span></span><br>&#123;<br>  absClass*[] a;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="迭代器模式代码">迭代器模式代码</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span><br>&#123;<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasNext</span>() = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">next</span>() = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="组合迭代器模式代码">组合迭代器模式代码</h2>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">class xxx:<span class="hljs-type">Iterator</span><br>&#123;<br>  <span class="hljs-type">Iterator</span>*[] it;<br>  def hasNext() override <span class="hljs-meta">&#123;...&#125;</span><br>  def next() override <span class="hljs-meta">&#123;...&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="设计原则-3">设计原则</h2>
<p>每个类保持单一的责任</p>
<h1 id="策略模式">策略模式</h1>
<blockquote>
<p>多用接口</p>
</blockquote>
<h2 id="代码-4">代码</h2>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">class xxx<br>&#123;<br>  absClassA* a<span class="hljs-comment">;</span><br>  absClassB* b<span class="hljs-comment">;</span><br>  absClassC* c<span class="hljs-comment">;</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="设计原则-4">设计原则</h2>
<ul>
<li>多用组合，少用继承
<ul>
<li>使用组合可以拥有多个实例</li>
</ul></li>
<li>针对接口编程，不针对具体实现编程</li>
<li>将变和不变的内容分开</li>
</ul>
<h1 id="状态模式">状态模式</h1>
<blockquote>
<p>基于有限状态机；允许对象在内部状态改变时改变它的行为，对象好像在运行过程中修改了它的类定义</p>
</blockquote>
<ul>
<li>让一个类具有状态机功能的方法:
<ul>
<li>让类中拥有一个State成员
<ul>
<li>较简单</li>
</ul></li>
<li>让类中拥有一个StateMachine成员
<ul>
<li>较复杂</li>
<li>state &lt;--&gt; stateMachine &lt;--&gt; object</li>
</ul></li>
</ul></li>
</ul>
<h2 id="代码-5">代码</h2>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span><br>&#123;<br>  <span class="hljs-function">def <span class="hljs-title">Enter</span>()</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-function">def <span class="hljs-title">Exit</span>()</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//其它纯虚函数</span><br>  <span class="hljs-function">def <span class="hljs-title">DoSomethingA</span>()</span> = <span class="hljs-number">0</span>;<br>  ...<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">StateMachine</span><br>&#123;<br>  State* curState;          <span class="hljs-comment">//核心数据结构</span><br>  <span class="hljs-function">def <span class="hljs-title">changeState</span>(<span class="hljs-params">State* newState</span>)  <span class="hljs-comment">//核心函数</span></span><br>  &#123;<br>    curState-&gt;Exit();<br>    curState = newState;<br>    curState-&gt;Enter();<br>  &#125;<br><br>  <span class="hljs-comment">//其他纯虚函数的实现</span><br>  <span class="hljs-function">def <span class="hljs-title">DoSomethingA</span>()</span><br>  &#123;<br>    curState-&gt;DoSomethingA();<br>  &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="对比-1">对比</h2>
<p>策略模式和状态模式本质上是相同的，只是状态模式在执行逻辑时，状态可以自动发生改变</p>
<h2 id="适用条件">适用条件</h2>
<ul>
<li>实体的行为基于一些内在状态</li>
<li>状态可以被严格的分割为相对较少的不相干项目</li>
<li>实体响应一系列输入或事件</li>
<li>状态的跳转呈现出复杂的图结构</li>
</ul>
<h2 id="应用场景">应用场景</h2>
<ul>
<li>玩家输入</li>
<li>导航菜单界面</li>
<li>分析文字</li>
<li>网络协议</li>
<li>其他异步行为</li>
</ul>
<h2 id="并发状态机">并发状态机</h2>
<blockquote>
<p>降低了状态的数量</p>
</blockquote>
<p>一个对象拥有两个状态机，分别负责m种A类状态、n种B类状态，实现A类状态和B类状态的组合</p>
<h2 id="分层状态机">分层状态机</h2>
<blockquote>
<p>实现了代码重用</p>
</blockquote>
<p>用继承来实现：子类不处理的输入交给来父类处理</p>
<p>用栈来实现：每一个元素都是它下一个元素的子状态，接收到输入时，从栈顶开始向下查找可以处理输入的那个状态来处理该输入</p>
<h2 id="下推状态机">下推状态机</h2>
<blockquote>
<p>实现了状态回退功能</p>
</blockquote>
<p>状态机使用一个栈来记录历史状态，栈顶代表当前状态</p>
<h2 id="meyers单例模式">Meyers单例模式</h2>
<blockquote>
<p>C++11标准之后的最佳选择</p>
<p>全局唯一、有全局访问点，但延迟构建不是必须的</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-type">static</span> Singleton s;<br>    <span class="hljs-keyword">return</span> &amp;s;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>缺点
<ul>
<li>不可控制创建时间</li>
<li>不可控制析构顺序</li>
<li>getInstance的开销可能很大</li>
</ul></li>
</ul>
<p>一般类的构造和析构函数可以不做任何事情，定义额外的startUp和shutDown函数</p>
<ul>
<li>管理多个单例的启动和终止的方法
<ul>
<li>手动控制启动和终止</li>
<li>把各个单例类登记在一个列表中，逐一启动</li>
<li>建立各个单例类之间的依赖关系图(dependency
graph)，自动计算出最优启动顺序和终止顺序</li>
</ul></li>
</ul>
<h1 id="命令模式">命令模式</h1>
<blockquote>
<p>将发出请求的对象和执行请求的对象进行解耦</p>
</blockquote>
<p>命令模式的一个强大功能就是撤销</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span><br>&#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">undo</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Remote</span><br>&#123;<br>  map&lt;<span class="hljs-type">int</span>, Command*&gt; commands;    <span class="hljs-comment">//核心数据结构</span><br>  statck&lt;Command*&gt; historyCommands;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="应用场景-1">应用场景</h2>
<ul>
<li>控制器按键映射</li>
<li>模拟闭包：让函数有变量</li>
</ul>
<h1 id="模板方法模式">模板方法模式</h1>
<h2 id="代码-6">代码</h2>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Template</span><br>&#123;<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">mainProcess</span>()<br>  &#123;<br>    funcA();<br>    funcB();<br>    <span class="hljs-keyword">if</span>(funcC())<br>      funcD();<br>    ...<br>  &#125;<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">funcA</span>() = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">funcB</span>() = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">funcC</span>() = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">funcD</span>() = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="设计原则-5">设计原则</h2>
<p>低层组件不可以调用高层组件，但是高层组件可以调用低层组件</p>
<h1 id="工厂模式">工厂模式</h1>
<blockquote>
<p>抽象类的具体类比较多、需要分类或创建过程比较复杂时，可以用工厂模式将创建它们的函数封装起来</p>
</blockquote>
<h2 id="简单工厂模式simple-factory">简单工厂模式(Simple Factory)</h2>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbsProduct</span></span><br><span class="hljs-class"></span>&#123;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product1</span> : <span class="hljs-title">AbsProduct</span></span><br><span class="hljs-class"></span>&#123;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product2</span> : <span class="hljs-title">AbsProduct</span></span><br><span class="hljs-class"></span>&#123;<br><br>&#125;<br><br>AbsProduct* create(string name)<br>&#123;<br>  <span class="hljs-keyword">if</span>(...)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Product1</span>();<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(...)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Product2</span>();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="工厂方法模式factory-method">工厂方法模式(Factory Method)</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbsProduct</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product1</span> : <span class="hljs-type">AbsProduct</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product2</span> : <span class="hljs-type">AbsProduct</span><br>&#123;<br><br>&#125;<br><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbsFactory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  virtual AbsProduct createProduct() = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory1</span> : <span class="hljs-type">AbsFactory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">override</span> AbsProduct createProduct()<br>  &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> new Product1();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory2</span> : <span class="hljs-type">AbsFactory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">override</span> AbsProduct createProduct()<br>  &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> new Product2();<br>  &#125;<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure>
<h2 id="抽象工厂模式abstract-factory">抽象工厂模式(Abstract
Factory)</h2>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbsProductA</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA1</span> : <span class="hljs-type">AbsProductA</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA2</span> : <span class="hljs-type">AbsProductA</span><br>&#123;<br><br>&#125;<br><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbsProductB</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB1</span> : <span class="hljs-type">AbsProductB</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB2</span> : <span class="hljs-type">AbsProductB</span><br>&#123;<br><br>&#125;<br><br>...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbsFactory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  virtual AbsProductA createProductA() = <span class="hljs-number">0</span>;<br>  virtual AbsProductB createProductB() = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory1</span> : <span class="hljs-type">AbsFactory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">override</span> AbsProductA createProductA()<br>  &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> new ProductA1();<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> AbsProductB createProductB()<br>  &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> new ProductB1();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory2</span> : <span class="hljs-type">AbsFactory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">override</span> AbsProductA createProductA()<br>  &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> new ProductA2();<br>  &#125;<br><br>  <span class="hljs-keyword">override</span> AbsProductB createProductB()<br>  &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> new ProductB2();<br>  &#125;<br>&#125;<br><br>...<br></code></pre></td></tr></table></figure>
<h2 id="设计原则-6">设计原则</h2>
<p>依赖倒置原则：要依赖抽象类，不要依赖具体类</p>
<h1 id="mvc">MVC</h1>
<blockquote>
<p>复合模式：结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题</p>
</blockquote>
<p>MVC的本质就是将数据、显示、逻辑分开，一切以实现这个目标为目的的设计都可以说是MVC，以下是其中一种设计：</p>
<ul>
<li>controller响应view的调用来控制view和model</li>
<li>model利用观察者通知controller和view</li>
<li>view利用策略模式接上controller</li>
<li>view利用组合模式管理所有组件。由于现在的GUI系统都比较先进，所以一般不用再使用组合模式进行管理了</li>
</ul>
<p>view和controller之间的关系可以是1对1、1对n、n对1</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>番外篇--C++中的代码重用</title>
    <url>/posts/7230a012.html</url>
    <content><![CDATA[<ul>
<li>实现代码重用的一些方法（这里并不是全部）：
<ul>
<li>包含（组合、层次化）：类包含另一个类的对象</li>
<li>使用私有继承或保护继承</li>
</ul></li>
<li>以上两种方法都用于实现has-a关系，常用第一种方法</li>
<li>多重继承可以使多个基类派生出一个新类，将基类的功能组合到一起</li>
</ul>
<h1 id="包含对象成员的类">包含对象成员的类</h1>
<ul>
<li>公有继承实现is-a模型，没有增加新接口，可增加新实现</li>
<li>包含（组合、层次化）、私有继承、保护继承实现has-a模型，没有增加新接口，可增加新实现；</li>
<li>接口：直接暴露在外的函数；实现：函数定义；注意：这两个概念不是互斥的</li>
</ul>
<h1 id="私有继承">私有继承</h1>
<p>要区分开 类成员的访问类型 和 类的继承类型 之间的关系 类成员的访问类型
决定 类成员的可访问性和可继承性：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">访问类型</th>
<th style="text-align: center;">外部可访问性</th>
<th style="text-align: center;">可继承性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">public</td>
<td style="text-align: center;">可访问</td>
<td style="text-align: center;">可继承</td>
</tr>
<tr class="even">
<td style="text-align: center;">protect</td>
<td style="text-align: center;">不可访问</td>
<td style="text-align: center;">可继承</td>
</tr>
<tr class="odd">
<td style="text-align: center;">private</td>
<td style="text-align: center;">不可访问</td>
<td style="text-align: center;">不可继承</td>
</tr>
</tbody>
</table>
<p>类的继承类型 决定 继承下来的成员 的访问类型会变成什么：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">继承类型</th>
<th style="text-align: center;">变化</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">公有继承</td>
<td style="text-align: center;">不改变继承下来内容的访问类型</td>
</tr>
<tr class="even">
<td style="text-align: center;">保护继承</td>
<td
style="text-align: center;">将继承下来的内容的访问类型都变为protect</td>
</tr>
<tr class="odd">
<td style="text-align: center;">私有继承</td>
<td
style="text-align: center;">将继承下来的内容的访问类型都变为private</td>
</tr>
</tbody>
</table>
<p>派生类的指针(引用)要赋值给私有继承下来的基类类型指针(引用)，必要强转派生类的指针(引用)</p>
<hr />
<p>包含将对象作为一个有名字的成员添加到类中，私有继承将一个没有名字的成员添加到类中；这些成员称为子对象(subobject)</p>
<p>私有继承是默认继承方式</p>
<p>访问基类成员的格式：类名::基类成员</p>
<p>ps：友元函数不是类成员</p>
<p>若要直接获得子对象，则只需要对this(*this)进行强制类型转换即可，转换成你想要的子对象类型的指针(引用)</p>
<hr />
<ul>
<li>包含 与 私有继承 实现has-a关系的对比：
<ul>
<li>包含易于理解，可包含多个同类子对象，不可访问子对象的保护成员、不可重新定义虚函数</li>
<li>私有继承比较抽象，不易包含多个同类子对象，容易出问题(多重继承)；但是特性多：可访问子对象的保护成员、可重新定义虚函数</li>
</ul></li>
<li>一般来说，能用包含就用包含，实在不行再用私有继承</li>
<li>如果想要改变私有继承（或保护继承（可以吗？））下来的基类成员的访问属性，可以使用using关键字，将那些成员强行引入到特性的访问区块：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Student</span> : <span class="hljs-symbol">private</span> <span class="hljs-symbol">std::<span class="hljs-symbol">string</span>, <span class="hljs-symbol">private</span></span> <span class="hljs-symbol">std::<span class="hljs-symbol">valarray</span></span>&lt;<span class="hljs-symbol">double</span>&gt;<br>&#123;<br>...<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//使用using将那些继承下来的成员强行引入到public中，min和max函数的访问属性由private改成了public</span><br>  using std::valarray&lt;<span class="hljs-built_in">double</span>&gt;::min;<br>  using std::valarray&lt;<span class="hljs-built_in">double</span>&gt;::max;<br>  <span class="hljs-comment">//注意：using声明只需要成员名</span><br><br>  <span class="hljs-comment">//实现这个功能的一种更老的方法，但即将停用</span><br>  <span class="hljs-comment">//std::valarray&lt;double&gt;::min;</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1 id="多重继承">多重继承</h1>
<p>多重继承(MI)：有多个直接基类的类，每一个基类都要写上自己的继承属性</p>
<p>以下面的继承关系图为例介绍MI：</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221112010046.png?x-oss-process=style/WaterMask" /></p>
<p>如果上图中所有的继承关系都是公有继承，那么SingingWaiter实例就会有两个Worker基类对象：</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221112010102.png?x-oss-process=style/WaterMask" /></p>
<h2 id="多重继承引入的问题">多重继承引入的问题</h2>
<ul>
<li>派生类对象(SingingWaiter)指针(引用)无法自动上转为相同基类类型(Worker)的指针(引用)
<ul>
<li>解决方法：手动强转下派生类对象(SingingWaiter)指针(引用)到上一级基类(Singer或Waiter)就好了</li>
</ul></li>
<li>从不同的基类继承同名的方法
<ul>
<li>解决方法：可在调用同名函数时，通过类名指定</li>
</ul></li>
</ul>
<h1
id="从不同继承路线上继承相同的基类">从不同继承路线上继承相同的基类</h1>
<p>为了删除多个相同基类，有点像融合，C++引入了新技术— 虚基类 ；</p>
<p>要指定哪条继承线的相同基类进行融合，则继承这个相同类(Worker)的直接派生类(Singer和Waiter)都要在继承时加上virtual关键字:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Singer</span> : <span class="hljs-symbol">public</span> <span class="hljs-symbol">virtual</span> <span class="hljs-symbol">Worker</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">Waiter</span> : <span class="hljs-symbol">virtual</span> <span class="hljs-symbol">public</span> <span class="hljs-symbol">Worker</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>
<p>然后派生类(SingingWaiter)的基类对象情况就会变成这样：</p>
<p><img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221112010201.png?x-oss-process=style/WaterMask" /></p>
<h2
id="引入虚基类的多重继承需要解决的问题">引入虚基类的多重继承需要解决的问题</h2>
<p><strong>构造函数的问题</strong></p>
<p>只能在类(SingingWaiter)在构造函数 初始化列表
中调用虚基类(Worker)的构造函数，类(SingingWaiter)的所有基类(Singer和Waiter)都不能在构造函数
初始化列表 中调用虚基类(Worker)的构造函数；</p>
<p>只能由类(SingingWaiter)来 自动
调用虚基类(Worker)的构造函数，类(SingingWaiter)的所有基类(Singer和Waiter)都不能再
自动 调用虚基类(Worker)的构造函数；</p>
<p>总的来说就是：类(SingingWaiter)的所有基类(Singer和Waiter)已无权调用虚基类(Worker)的构造函数，只能由类(SingingWaiter)调用虚基类(Worker)的构造函数；</p>
<p><strong>虚基类中虚函数的问题</strong></p>
<p>如果一个类(SingingWaiter)继承了虚基类(Worker)但是没有实现虚基类(Worker)的虚函数vfun，会出现下面两种情况：</p>
<p>如果有两个以上 虚基类(Worker)的派生类(Singer和Waiter)
都实现了虚基类(Worker)的虚函数vfun；这个时候如果通过这个类(SingingWaiter)的对象指针去调用虚函数vfun，那么将出现二义性；因为虚函数从虚基类(Worker)开始往下走会有两个最新版本出现；因此这个类(SingingWaiter)最好重写(override)虚函数vfun，否则多态性就会异常；</p>
<p>如果只有一个 虚基类(Worker)的派生类(Singer或Waiter)
实现了虚基类(Worker)的虚函数vfun；这个时候如果通过这个类(SingingWaiter)的对象指针去调用虚函数vfun，那么不会有任何问题；</p>
<p><strong>重写虚函数的问题</strong></p>
<p>在重写(override)虚基类(Worker)的虚函数vfun时最好不要以 递增
的方式去写；所谓的 递增
指的是：在重写(override)的时候调用了基类的虚函数vfun；</p>
<h2 id="后记">后记</h2>
<p>虚函数的调用规则不受访问类型的影响，该调用哪个就调用哪个，如果调到了私有函数或者保护函数，那运行时就报错；</p>
<p>基类普通函数的调用规则也不受访问类型的影响，如果基类出现两个同名普通函数函数，即使一个是私有的、一个是公有的，那么一样存在调用的二义性；</p>
<h1 id="类模板">类模板</h1>
<h2 id="类模板的声明与定义">类模板的声明与定义</h2>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//T是类型参数</span><br><span class="hljs-comment">//typename和class是等价的，但是class是C++98之前的版本</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//do something &#125;</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function">A&lt;T&gt; <span class="hljs-title">fun3</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//do something &#125;</span><br>  <span class="hljs-function">A <span class="hljs-title">fun4</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">//注意：fun3和fun4的返回类型其实是等价的，没有差别；在类的块中，所有的A&lt;T&gt;和A都是等价的</span><br>&#125;;<br><br><span class="hljs-comment">//如果函数定义与函数声明分开，那么定义格式如下：</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> A&lt;T&gt;::<span class="hljs-built_in">fun2</span>()<br>&#123;<br>  <span class="hljs-comment">//do something</span><br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>A&lt;T&gt; A&lt;T&gt;::<span class="hljs-built_in">fun4</span>()      <span class="hljs-comment">//注意：返回值的写法与函数原型不同，因为在类的块外面</span><br>&#123;<br>  <span class="hljs-comment">//do something</span><br>&#125;<br><br><span class="hljs-comment">//跟函数模板一样，以上只是类模板，机器码中不会包含类模板的信息；编译器会根据类模板来生成相应类定义机器码</span><br><span class="hljs-comment">//注意：类模板函数声明与定义不能放在两个独立的文件中</span><br></code></pre></td></tr></table></figure>
<h2 id="类模板的使用">类模板的使用</h2>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">A&lt;<span class="hljs-built_in">int</span>&gt; test1;<br>A&lt;<span class="hljs-built_in">string</span>&gt; test2<br><span class="hljs-comment">//注意：类型参数必须要手动确定，编译器不会像函数模板一样自动识别</span><br></code></pre></td></tr></table></figure>
<h2 id="数组模板实例和非类型参数">数组模板实例和非类型参数</h2>
<p>非类型(non-type)参数or表达式(expression)参数：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//数组模板</span><br>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T,<span class="hljs-symbol">int</span></span> <span class="hljs-symbol">n</span>&gt;    //<span class="hljs-symbol">n</span>就是非类型参数；看起来像是一个变量，但我觉得是一个可以指定类型的宏定义，编译生成具体模板实例的时候，类成员的声明和定义中的<span class="hljs-symbol">n</span>标识符将全部被替换为<span class="hljs-symbol">n</span>的具体数值<br><span class="hljs-symbol">class</span> <span class="hljs-symbol">ArrayTP</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  T ar[n];          <span class="hljs-comment">//由于是宏定义，所以编译时可以确定数组大小</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-built_in">void</span> <span class="hljs-keyword">set</span>()&#123;&#125;;<br>&#125;;<br><br>template &lt;<span class="hljs-keyword">class</span> <span class="hljs-symbol">T, <span class="hljs-symbol">int</span></span> <span class="hljs-symbol">n</span>&gt;<br><span class="hljs-symbol">void</span> <span class="hljs-symbol">ArrayTP</span>&lt;<span class="hljs-symbol">T,<span class="hljs-symbol">n</span></span>&gt;::<span class="hljs-symbol">set</span>()<br>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>    ar[i]=i;<br>&#125;<br><br><span class="hljs-built_in">int</span> main()<br>&#123;<br>  ...<br>  ArrayTP&lt;<span class="hljs-built_in">double</span>,<span class="hljs-number">12</span>&gt; example1;<br>  ArrayTP&lt;<span class="hljs-built_in">double</span>,<span class="hljs-number">20</span>&gt; example2;<br>  <span class="hljs-comment">//注意：上面将生产两个模板实例，因为非类型参数不同</span><br><br>  example1.<span class="hljs-keyword">set</span>();<br>  example2.<span class="hljs-keyword">set</span>();<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>非类型参数的限制：
<ul>
<li>类型只能是整形、枚举、引用、指针</li>
<li>模板中的代码不能修改非类型参数的值，也不能获取参数的地址(引用也不行吧？)(因为非类型参数没有内存空间？)</li>
<li>在实例化模板的时候，用作非类型参数的值必须是常量表达式</li>
</ul></li>
<li>非类型参数数组模板的优点：
<ul>
<li>使用非类型参数来创建数组速度更快，因为数组是自动变量；而且不需要手动new和delete；</li>
</ul></li>
<li>非类型参数数组模板的缺点：
<ul>
<li>不同的非类型参数数值都会生成自己的模板实例，占用内存增加；</li>
<li>无法将一种尺寸的数组模板实例赋给另一种尺寸的数组模板实例；</li>
</ul></li>
</ul>
<h2 id="模板多功能性">模板多功能性</h2>
<p>类模板也可以用作基类、派生类、组件类、其它模板的类型参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	T entry;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrowArray</span>:<span class="hljs-keyword">public</span> Array&lt;type&gt;		<span class="hljs-comment">//派生类模板 继承 基类模板</span><br>&#123; ... &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tp&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>	Array&lt;TP&gt; ar;			<span class="hljs-comment">//类模板 作为 组件</span><br>&#125;;<br><br>Array&lt;Stack&lt;<span class="hljs-type">int</span>&gt; &gt; asi;		<span class="hljs-comment">//类模板 作为 其它类模板的 类型参数；C++98要求后面两个 &gt; 分开，但是C++11不用</span><br></code></pre></td></tr></table></figure>
<p>递归使用类模板：一个类模板的类型参数还是类模板，例如：<code>vector&lt;vector&lt;int,6&gt;,7&gt;</code></p>
<p>模板可以包含多个类型参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;typaname T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  T1 a;<br>  T2 b;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">const</span> T1 &amp;aa,<span class="hljs-type">const</span> T2 &amp;bb)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,typrname T2&gt;<br><span class="hljs-type">void</span> Pair&lt;T1,T2&gt;::<span class="hljs-built_in">set</span>(<span class="hljs-type">const</span> T1 &amp;aa,<span class="hljs-type">const</span> T2 &amp;bb)<br>&#123;<br>  a=aa;<br>  b=bb;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  Pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt; example1;<br>  Pair&lt;<span class="hljs-type">float</span>,string&gt; example2;<br><br>  example1.<span class="hljs-built_in">set</span>(<span class="hljs-number">3</span>,<span class="hljs-number">6.268</span>);<br>  example2.<span class="hljs-built_in">set</span>(<span class="hljs-number">3.1415</span>,<span class="hljs-string">&quot;hello world&quot;</span>);<br>  ...<br>&#125; <br></code></pre></td></tr></table></figure>
<p>默认模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2 = <span class="hljs-type">int</span>&gt;  <span class="hljs-comment">//一定要确保有默认值的类型参数右边的类型参数都是有默认值的</span><br><span class="hljs-keyword">class</span> Topo                                <span class="hljs-comment">//还可以为非类型参数设置默认值</span><br>&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  Topo&lt;<span class="hljs-type">double</span>&gt; m2;  <span class="hljs-comment">//由于没有给出第二个类型参数，所以默认第二个类型参数为int</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="模板的具体化">模板的具体化</h2>
<p>隐式实例化(implicit instantiation) 、 显式实例化(explicit
instantiation) 、 显式具体化(explicit specialization) 统称为
具体化(specialization)</p>
<p>假设有这样一个类模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTP</span><br>&#123;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>隐式实例化</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">ArrayTP&lt;<span class="hljs-type">int</span>,<span class="hljs-number">100</span>&gt; stuff;			<span class="hljs-comment">//隐式实例化</span><br>...<br><br>ArrayTP&lt;<span class="hljs-type">double</span>,<span class="hljs-number">30</span>&gt; *pt;			<span class="hljs-comment">//不会实例化</span><br>pt = <span class="hljs-keyword">new</span> ArrayTP&lt;<span class="hljs-type">double</span>,<span class="hljs-number">30</span>&gt;;	<span class="hljs-comment">//隐式实例化</span><br></code></pre></td></tr></table></figure>
<p>这种实例化在函数模板中是显式实例化的一种形式</p>
<p><strong>显式实例化</strong></p>
<figure class="highlight d"><table><tr><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> ArrayTP&lt;<span class="hljs-built_in">string</span>,<span class="hljs-number">100</span>&gt;;		<span class="hljs-comment">//显式实例化</span><br></code></pre></td></tr></table></figure>
<p><strong>显式具体化</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">ArrayTP</span>&lt;<span class="hljs-symbol">string,<span class="hljs-symbol">100</span></span>&gt;<br>&#123;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当同时存在具体化模板和通用模板时，编译器优先选择具体化模板；如果还存在普通函数，是不是普通函数最优先</p>
<p><strong>部分具体化</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">template &lt;typename T1&gt;		<span class="hljs-comment">//没有具体化的参数就保留下来了；是否要确保已具体化参数右边的函数都是被具体化了？？？</span><br><span class="hljs-keyword">class</span> <span class="hljs-symbol">ArrayTP</span>&lt;<span class="hljs-symbol">T1,<span class="hljs-symbol">int</span></span>&gt;<br>&#123;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>部分具体化的更多例子：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><code class="hljs nim">//general <span class="hljs-keyword">template</span><br><span class="hljs-keyword">template</span> &lt;class <span class="hljs-type">T1</span>, class <span class="hljs-type">T2</span>, class <span class="hljs-type">T3</span>&gt; class <span class="hljs-type">Trio</span><span class="hljs-meta">&#123;...&#125;</span>;<br>//specialization tith <span class="hljs-type">T3</span> <span class="hljs-type">set</span> to <span class="hljs-type">T2</span><br><span class="hljs-keyword">template</span> &lt;class <span class="hljs-type">T1</span>, class <span class="hljs-type">T2</span>&gt; class <span class="hljs-type">Trio</span>&lt;<span class="hljs-type">T1</span>, <span class="hljs-type">T2</span>, <span class="hljs-type">T2</span>&gt;<span class="hljs-meta">&#123;...&#125;</span>;<br>//specialization <span class="hljs-keyword">with</span> <span class="hljs-type">T3</span> <span class="hljs-keyword">and</span> <span class="hljs-type">T2</span> <span class="hljs-type">set</span> to <span class="hljs-type">T1</span>*<br><span class="hljs-keyword">template</span> &lt;class <span class="hljs-type">T1</span>&gt; class <span class="hljs-type">Trio</span>&lt;<span class="hljs-type">T1</span>, <span class="hljs-type">T1</span>*, <span class="hljs-type">T1</span>*&gt;<span class="hljs-meta">&#123;...&#125;</span>;<br><br>//给定上述声明，编译器将作出如下选择：<br><span class="hljs-type">Trio</span>&lt;<span class="hljs-type">int</span>, short <span class="hljs-type">char</span>*&gt; t1;    //use general <span class="hljs-keyword">template</span><br><span class="hljs-type">Trio</span>&lt;<span class="hljs-type">int</span>, short&gt; t2;          //use <span class="hljs-type">Trio</span>&lt;<span class="hljs-type">T1</span>, <span class="hljs-type">T2</span>, <span class="hljs-type">T2</span>&gt;<br><span class="hljs-type">Trio</span>&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*&gt; t3;  //use <span class="hljs-type">Trio</span>&lt;<span class="hljs-type">T1</span>, <span class="hljs-type">T1</span>*, <span class="hljs-type">T1</span>*&gt;<br></code></pre></td></tr></table></figure>
<p>函数调用时，模板匹配优先度：显式具体化&gt;部分具体化&gt;实例化</p>
<p>指针(引用)类型优先与T*(T&amp;)匹配，非指针(引用)类型优先与T匹配</p>
<h2 id="成员模板">成员模板</h2>
<p>老编译器不接受模板成员</p>
<p>可以在类模板中定义类模板或者函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">beta</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> V&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">hold</span><br>  &#123;<br>  <span class="hljs-keyword">private</span>:<br>    V val;<br>  &#125;;<br><br>  hold&lt;T&gt; q;<br>  hold&lt;<span class="hljs-type">int</span>&gt; n;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  <span class="hljs-function">U <span class="hljs-title">blad</span><span class="hljs-params">(U u,T t,hold&lt;T&gt; ht,hold&lt;<span class="hljs-type">int</span>&gt; hi)</span></span><br><span class="hljs-function">  </span>&#123; ... &#125;<br>&#125;;<br><br><span class="hljs-comment">//以上的类模板和函数模板都是在类中定义的，接下来看看在类外要怎么定义</span><br><span class="hljs-comment">//注意：部分编译器不接受类外定义</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">beta</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">template</span> &lt;typaneme V&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">hold</span>;          <span class="hljs-comment">//声明</span><br>  <br>  hold&lt;T&gt; q;<br>  hold&lt;<span class="hljs-type">int</span>&gt; n;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">U <span class="hljs-title">blad</span><span class="hljs-params">(U u,T t,hold&lt;T&gt; ht,hold&lt;<span class="hljs-type">int</span>&gt; hi)</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> V&gt;<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">beta</span>&lt;T&gt;::hold      <span class="hljs-comment">//注意作用域解析运算符</span><br>  &#123;<br>  <span class="hljs-keyword">private</span>:<br>    V val;<br>  &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>  U beta&lt;T&gt;::<span class="hljs-built_in">blad</span>(U u,T t,hold&lt;T&gt; ht,hold&lt;<span class="hljs-type">int</span>&gt; hi)    <span class="hljs-comment">//注意作用域解析运算符</span><br>  &#123; ... &#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>光照效果展示</title>
    <url>/posts/f65cb81a.html</url>
    <content><![CDATA[<h1 id="前向渲染">前向渲染</h1>
<blockquote>
<p>兰伯特漫反射+Blin-Phong高光反射</p>
</blockquote>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20230101192549.png"
alt="4个点光源、1个平行光" />
<figcaption aria-hidden="true">4个点光源、1个平行光</figcaption>
</figure>
<figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">Shader <span class="hljs-string">&quot;Forward Rendering&quot;</span> &#123;<br>	Properties &#123;<br>		<span class="hljs-variable">_Diffuse</span> (<span class="hljs-string">&quot;Diffuse&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>		<span class="hljs-variable">_Specular</span> (<span class="hljs-string">&quot;Specular&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>		<span class="hljs-variable">_Gloss</span> (<span class="hljs-string">&quot;Gloss&quot;</span>, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>	&#125;<br>	SubShader &#123;<br>		Tags &#123; <span class="hljs-string">&quot;RenderType&quot;</span>=<span class="hljs-string">&quot;Opaque&quot;</span> &#125;<br>		<br>		Pass &#123;<br>			Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br>		<br>			CGPROGRAM<br>			<br>			<span class="hljs-meta">#pragma multi_compile_fwdbase	</span><br>			<br>			<span class="hljs-meta">#pragma vertex vert</span><br>			<span class="hljs-meta">#pragma fragment frag</span><br>			<br>			<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br>			<br>			fixed4 <span class="hljs-variable">_Diffuse</span>;<br>			fixed4 <span class="hljs-variable">_Specular</span>;<br>			float <span class="hljs-variable">_Gloss</span>;<br>			<br>			struct a2v &#123;<br>				float4 vertex : <span class="hljs-built_in">POSITION</span>;<br>				float3 normal : NORMAL;<br>			&#125;;<br>			<br>			struct v2f &#123;<br>				float4 pos : SV_POSITION;<br>				float3 worldNormal : TEXCOORD0;<br>				float3 worldPos : TEXCOORD1;<br>			&#125;;<br>			<br>			v2f vert(a2v v) &#123;<br>				v2f o;<br>				o.pos = UnityObjectToClipPos(v.vertex);<br>				<br>				o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>				<br>				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>				<br>				return o;<br>			&#125;<br>			<br>			fixed4 frag(v2f i) : SV_Target &#123;<br>				fixed3 worldNormal = normalize(i.worldNormal);<br>				fixed3 worldLightDir = normalize(<span class="hljs-variable">_WorldSpaceLightPos0</span>.xyz);<br>				<br>				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>				<br>			 	fixed3 diffuse = <span class="hljs-variable">_LightColor0</span>.rgb * <span class="hljs-variable">_Diffuse</span>.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br><br>			 	fixed3 viewDir = normalize(<span class="hljs-variable">_WorldSpaceCameraPos</span>.xyz - i.worldPos.xyz);<br>			 	fixed3 halfDir = normalize(worldLightDir + viewDir);<br>			 	fixed3 specular = <span class="hljs-variable">_LightColor0</span>.rgb * <span class="hljs-variable">_Specular</span>.rgb * pow(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, dot(worldNormal, halfDir)), <span class="hljs-variable">_Gloss</span>);<br><br>				fixed atten = <span class="hljs-number">1.0</span>;<br>				<br>				return fixed4(ambient + (diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>			&#125;<br>			<br>			ENDCG<br>		&#125;<br>	<br>		Pass &#123;<br>			Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardAdd&quot;</span> &#125;<br>			<br>			Blend One One<br>		<br>			CGPROGRAM<br>			<br>			<span class="hljs-meta">#pragma multi_compile_fwdadd</span><br>			<br>			<span class="hljs-meta">#pragma vertex vert</span><br>			<span class="hljs-meta">#pragma fragment frag</span><br>			<br>			<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span></span><br>			<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;AutoLight.cginc&quot;</span></span><br>			<br>			fixed4 <span class="hljs-variable">_Diffuse</span>;<br>			fixed4 <span class="hljs-variable">_Specular</span>;<br>			float <span class="hljs-variable">_Gloss</span>;<br>			<br>			struct a2v &#123;<br>				float4 vertex : <span class="hljs-built_in">POSITION</span>;<br>				float3 normal : NORMAL;<br>			&#125;;<br>			<br>			struct v2f &#123;<br>				float4 pos : SV_POSITION;<br>				float3 worldNormal : TEXCOORD0;<br>				float3 worldPos : TEXCOORD1;<br>			&#125;;<br>			<br>			v2f vert(a2v v) &#123;<br>				v2f o;<br>				o.pos = UnityObjectToClipPos(v.vertex);<br>				<br>				o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>				<br>				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>				<br>				return o;<br>			&#125;<br>			<br>			fixed4 frag(v2f i) : SV_Target &#123;<br>				fixed3 worldNormal = normalize(i.worldNormal);<br>				<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USING_DIRECTIONAL_LIGHT</span><br>					fixed3 worldLightDir = normalize(<span class="hljs-variable">_WorldSpaceLightPos0</span>.xyz);<br>				<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>					fixed3 worldLightDir = normalize(<span class="hljs-variable">_WorldSpaceLightPos0</span>.xyz - i.worldPos.xyz);<br>				<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>				<br>				fixed3 diffuse = <span class="hljs-variable">_LightColor0</span>.rgb * <span class="hljs-variable">_Diffuse</span>.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, dot(worldNormal, worldLightDir));<br>				<br>				fixed3 viewDir = normalize(<span class="hljs-variable">_WorldSpaceCameraPos</span>.xyz - i.worldPos.xyz);<br>				fixed3 halfDir = normalize(worldLightDir + viewDir);<br>				fixed3 specular = <span class="hljs-variable">_LightColor0</span>.rgb * <span class="hljs-variable">_Specular</span>.rgb * pow(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, dot(worldNormal, halfDir)), <span class="hljs-variable">_Gloss</span>);<br>				<br>				<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> USING_DIRECTIONAL_LIGHT</span><br>					fixed atten = <span class="hljs-number">1.0</span>;<br>				<span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>					<span class="hljs-meta">#if defined (POINT)</span><br>				        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>)).xyz;<br>				        fixed atten = tex2D(<span class="hljs-variable">_LightTexture0</span>, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>				    <span class="hljs-meta">#elif defined (SPOT)</span><br>				        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>));<br>				        fixed atten = (lightCoord.z &gt; <span class="hljs-number">0</span>) * tex2D(<span class="hljs-variable">_LightTexture0</span>, lightCoord.xy / lightCoord.w + <span class="hljs-number">0.5</span>).w * tex2D(<span class="hljs-variable">_LightTextureB0</span>, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>				    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>				        fixed atten = <span class="hljs-number">1.0</span>;<br>				    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>				<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>				return fixed4((diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>			&#125;<br>			<br>			ENDCG<br>		&#125;<br>	&#125;<br>	FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br><span class="hljs-comment">//Unity Shader rumen</span><br></code></pre></td></tr></table></figure>
<h1 id="切线空间法线贴图">切线空间法线贴图</h1>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20230101205113.png"
alt="切线空间法线贴图" />
<figcaption aria-hidden="true">切线空间法线贴图</figcaption>
</figure>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Shader <span class="hljs-string">&quot;Normal Map In Tangent Space&quot;</span> &#123;<br>	Properties &#123;<br>		_Color (<span class="hljs-string">&quot;Color Tint&quot;</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>		_MainTex (<span class="hljs-string">&quot;Main Tex&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;white&quot;</span> &#123;&#125;<br>		_BumpMap (<span class="hljs-string">&quot;Normal Map&quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;bump&quot;</span> &#123;&#125;<br>		_BumpScale (<span class="hljs-string">&quot;Bump Scale&quot;</span>, Float) = <span class="hljs-number">1.0</span><br>	&#125;<br>	SubShader &#123;<br>		Pass &#123; <br>			Tags &#123; <span class="hljs-string">&quot;LightMode&quot;</span>=<span class="hljs-string">&quot;ForwardBase&quot;</span> &#125;<br>		<br>			CGPROGRAM<br>			<br>			#pragma vertex vert<br>			#pragma fragment frag<br>			<br>			#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Lighting.cginc&quot;</span><br>			<br>			fixed4 _Color;<br>			sampler2D _MainTex;<br>			float4 _MainTex_ST;<br>			sampler2D _BumpMap;<br>			float4 _BumpMap_ST;<br>			<span class="hljs-built_in">float</span> _BumpScale;<br>			<br>			<span class="hljs-keyword">struct</span> a2v &#123;<br>				float4 vertex : POSITION;<br>				float3 normal : NORMAL;<br>				float4 tangent : TANGENT;<br>				float4 texcoord : TEXCOORD0;<br>			&#125;;<br>			<br>			<span class="hljs-keyword">struct</span> v2f &#123;<br>				float4 pos : SV_POSITION;<br>				float4 uv : TEXCOORD0;<br>				float3 lightDir: TEXCOORD1;<br>				float3 viewDir : TEXCOORD2;<br>			&#125;;<br><br>			v2f vert(a2v v) &#123;<br>				v2f o;<br>				o.pos = <span class="hljs-constructor">UnityObjectToClipPos(<span class="hljs-params">v</span>.<span class="hljs-params">vertex</span>)</span>;<br>				<br>				o.uv.xy = v.texcoord.xy<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_MainTex_ST</span>.</span></span>xy + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_MainTex_ST</span>.</span></span>zw;<br>				o.uv.zw = v.texcoord.xy<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_BumpMap_ST</span>.</span></span>xy + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_BumpMap_ST</span>.</span></span>zw;<br><br>				fixed3 worldNormal = <span class="hljs-constructor">UnityObjectToWorldNormal(<span class="hljs-params">v</span>.<span class="hljs-params">normal</span>)</span>;  <br>				fixed3 worldTangent = <span class="hljs-constructor">UnityObjectToWorldDir(<span class="hljs-params">v</span>.<span class="hljs-params">tangent</span>.<span class="hljs-params">xyz</span>)</span>;  <br>				fixed3 worldBinormal = cross(worldNormal, worldTangent)<span class="hljs-operator"> * </span>v.tangent.w; <br><br>				float3x3 worldToTangent = float3x3(worldTangent, worldBinormal, worldNormal);<br><br>				o.lightDir = mul(worldToTangent, <span class="hljs-constructor">WorldSpaceLightDir(<span class="hljs-params">v</span>.<span class="hljs-params">vertex</span>)</span>);<br>				o.viewDir = mul(worldToTangent, <span class="hljs-constructor">WorldSpaceViewDir(<span class="hljs-params">v</span>.<span class="hljs-params">vertex</span>)</span>);<br>				<br>				return o;<br>			&#125;<br>			<br>			fixed4 frag(v2f i) : SV_Target &#123;				<br>				fixed3 tangentLightDir = normalize(i.lightDir);<br>				fixed3 tangentViewDir = normalize(i.viewDir);<br>				<br>				fixed4 packedNormal = tex2<span class="hljs-constructor">D(<span class="hljs-params">_BumpMap</span>, <span class="hljs-params">i</span>.<span class="hljs-params">uv</span>.<span class="hljs-params">zw</span>)</span>;<br>				fixed3 tangentNormal;<br><br>				<span class="hljs-comment">// 如果法线纹理没有设置为Normal map</span><br>				<span class="hljs-comment">// tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span><br>				<span class="hljs-comment">// tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br>				<br>				<span class="hljs-comment">// 如果法线纹理设置为Normal map</span><br>				tangentNormal = <span class="hljs-constructor">UnpackNormal(<span class="hljs-params">packedNormal</span>)</span>;<br>				tangentNormal.xy *= _BumpScale;<br>				tangentNormal.z = sqrt(<span class="hljs-number">1.0</span> - saturate(dot(tangentNormal.xy, tangentNormal.xy)));<br>				<br>				fixed3 albedo = tex2<span class="hljs-constructor">D(<span class="hljs-params">_MainTex</span>, <span class="hljs-params">i</span>.<span class="hljs-params">uv</span>)</span>.rgb<span class="hljs-operator"> * </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_Color</span>.</span></span>rgb;<br>				<br>				fixed3 diffuse = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_LightColor0</span>.</span></span>rgb<span class="hljs-operator"> * </span>albedo<span class="hljs-operator"> * </span>max(<span class="hljs-number">0</span>, dot(tangentNormal, tangentLightDir));<br>				<br>				return fixed4(diffuse, <span class="hljs-number">1.0</span>);<br>			&#125;<br>			<br>			ENDCG<br>		&#125;<br>	&#125; <br>	FallBack <span class="hljs-string">&quot;Specular&quot;</span><br>&#125;<br><span class="hljs-comment">//Unity Shader rumen</span><br></code></pre></td></tr></table></figure>
<h1 id="ao-map">AO Map</h1>
<h1 id="specular-map">Specular Map</h1>
<h1 id="parallax-map">Parallax Map</h1>
<h1 id="cascaded-shadow-map">Cascaded Shadow Map</h1>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>图形学</tag>
        <tag>光照</tag>
      </tags>
  </entry>
  <entry>
    <title>材质特效展示</title>
    <url>/posts/c4d9d82.html</url>
    <content><![CDATA[<h1 id="dissolve">Dissolve</h1>
<blockquote>
<p>使用UV坐标和时间信息对噪声图进行采样，采样的结果作为clip的其中一个参考值</p>
</blockquote>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/Dissolve.gif"
alt="Dissolve" />
<figcaption aria-hidden="true">Dissolve</figcaption>
</figure>
<h1 id="rim">Rim</h1>
<blockquote>
<p>菲涅尔效应的近似实现</p>
</blockquote>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20230101180140.png"
alt="Rim" />
<figcaption aria-hidden="true">Rim</figcaption>
</figure>
<h1 id="scan">Scan</h1>
<blockquote>
<p>将模型空间坐标作为UV坐标进行纹理采样</p>
</blockquote>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/Scan.gif"
alt="Scan" />
<figcaption aria-hidden="true">Scan</figcaption>
</figure>
<h1 id="matcap">MatCap</h1>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20230101180824.png"
alt="MatCap" />
<figcaption aria-hidden="true">MatCap</figcaption>
</figure>
<h1 id="薄膜干涉">薄膜干涉</h1>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20230101180932.png"
alt="ThinfilmInterference" />
<figcaption aria-hidden="true">ThinfilmInterference</figcaption>
</figure>
<h1 id="天牛">天牛</h1>
<blockquote>
<p>两层MatCap+薄膜干涉</p>
</blockquote>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20230101181101.png"
alt="天牛" />
<figcaption aria-hidden="true">天牛</figcaption>
</figure>
<h1 id="藤曼生长">藤曼生长</h1>
<figure>
<img
src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/Grow.gif"
alt="Grow" />
<figcaption aria-hidden="true">Grow</figcaption>
</figure>
]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>shader</tag>
        <tag>图形学</tag>
        <tag>特效</tag>
      </tags>
  </entry>
</search>
