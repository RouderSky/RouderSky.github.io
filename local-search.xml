<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GDC 2019 Evolving Combat in &#39;God of War&#39; for a New Perspective ⸺ “战神”战斗模式的全新变革 上篇</title>
    <link href="/posts/238c8259.html"/>
    <url>/posts/238c8259.html</url>
    
    <content type="html"><![CDATA[<p>该GDC分享只免费公开PPT，视频需要GDC VAULT会员</p><p>分享的PPT下载地址：<a href="https://www.gdcvault.com/play/1026423/Evolving-Combat-in-God-of">Evolving Combat in ‘God of War’ for a New Perspective</a><br>没有梯子的可以到这里下载：<br><a href="https://pan.baidu.com/s/1a1FGedhthon0yK7BTnlVbQ">https://pan.baidu.com/s/1a1FGedhthon0yK7BTnlVbQ</a> 提取码：6kjs</p><p>演讲者：Mihir Sheth（圣莫尼卡工作室首席战斗设计师）<br>辅助问答：Jeet Shroff（游戏总监和前游戏工程主管）</p><h1 id="战神的新旧更替"><a href="#战神的新旧更替" class="headerlink" title="战神的新旧更替"></a>战神的新旧更替</h1><p>《战神》是⼀个第三人称动作冒险游戏，玩家扮演斯巴达半神奎托斯，传说中的武器披荆斩棘，同时获得⼀些⼼灵的启迪。</p><p>为了方便不熟悉《战神》系列作品的同学，在这里对比一下老战神和新战神的战斗效果。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005052.png?x-oss-process=style/WaterMask"></p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005059.png?x-oss-process=style/WaterMask"></p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=713569276&bvid=BV1NX4y1K7Vc&cid=277325769&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div></br><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=22318492&bvid=BV1MW41157Jf&cid=36955509&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p>可以看到这是两种看起来截然不同的游戏，但是它们内在的玩法都包含了战神的精髓，游戏设计有着共同的基因。</p><h1 id="旧战斗风格"><a href="#旧战斗风格" class="headerlink" title="旧战斗风格"></a>旧战斗风格</h1><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005433.png?x-oss-process=style/WaterMask"></p><ol><li>激烈与技巧</li><li>满满的乐趣</li><li>强大的力量感</li></ol><p>开发组一直想将日本动作游戏的烈度和技巧带到西方背景中。通过简易的玩法来扩大受众，同时将顶级的视觉体验带到玩家⾯前。</p><p>奎托斯是一个充满进攻性的角色，所以整体的战斗都充满力量感。对敌人对战时带给玩家一种在玩弄猎物的感觉。</p><p>在战神1~3中都是使用⼀个拉远的摄像机来完成的，在较远的地方可以看到奎托斯所有的动作。系列中的每一步作品都在不停地完善战斗机制、增强视觉效果以达到史诗般的效果。</p><h1 id="新战斗风格"><a href="#新战斗风格" class="headerlink" title="新战斗风格"></a>新战斗风格</h1><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005503.png?x-oss-process=style/WaterMask"></p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005511.png?x-oss-process=style/WaterMask"></p><ol><li>视角需具备踏实和亲密的感觉，需要适用于游戏的所有情景</li><li>利维坦之斧</li><li>玩家控制的第三人称镜头</li></ol><p>在这个视角下将呈现很多新事物，例如北欧神话、同时兼顾近战和远战的利维坦之斧头、一个玩家控制的第三人称近距离相机且从不瞬切。</p><p>这个新相机的目的是让玩家拥有更加具备沉浸感的体验，让玩家更加靠近奎托斯，让战斗更细致严谨。</p><p>这么做将完全改变战神的战斗体验，而且必须要做得更好。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005537.png?x-oss-process=style/WaterMask"></p><p>开发组要做两件事情：</p><ol><li>为新摄像机重新定义战斗</li><li>保留战神系列的核心战斗特性</li></ol><h1 id="矛盾与战斗风格分析"><a href="#矛盾与战斗风格分析" class="headerlink" title="矛盾与战斗风格分析"></a>矛盾与战斗风格分析</h1><p>用一个近距离相机来展现快速、激烈、充满力量感的史诗场景是一件很不可思议的事情。近距离和史诗两者本身就很矛盾，莫非要玩家达到”一花一世界，一叶一菩提“的境界才能欣赏这个游戏。首次在E3演示游戏时，玩家们都很惊讶这个设定，经常会说看不见东西。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005608.png?x-oss-process=style/WaterMask"></p><p>构成战神战斗风格的元素：</p><ol><li>玩家及时响应式和combo式的出招，敌人各种夸张的受击反应</li><li>充满力量感的向前位移式攻击</li><li>轻松地同时与多个敌人进行战斗</li><li>主角可以被轻易控制</li></ol><h1 id="对比其他动作游戏"><a href="#对比其他动作游戏" class="headerlink" title="对比其他动作游戏"></a>对比其他动作游戏</h1><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005634.png?x-oss-process=style/WaterMask"></p><p>大部分其他拥有类似相机系统的游戏带有视角锁定系统，注重一对一战斗，而不是打群架。这种游戏的战斗风格都偏向于保守和谨慎，因为这种镜头难以看清周围的局势。主角的攻击动作也不会向前位移太多。攻击会以攻击距离和攻击时机为考量点，而不是触发有趣的敌人受击反应。</p><p>这些游戏这么做也是合理的，因为战斗系统和镜头是相互配合的。玩家也喜欢这些游戏。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005648.png?x-oss-process=style/WaterMask"></p><p>《战神4》没有办法参照其他动作游戏的做法，因为战斗的核心体验和其他游戏不一样。《战神4》的玩家在战斗时是充满自信和攻击性的，和其它游戏的保守谨慎形成鲜明对比。</p><p>研发组一开始反对新镜头也正是因为这个矛盾。</p><p>核心矛盾：近距离镜头 vs 主角的自信感、攻击性以及场景的史诗感</p><p>但是Mihir Sheth坚持认为这个新镜头设计是正确的，便一直朝着这个方向前进。</p><h1 id="追踪怪物-Tracking-Enemies"><a href="#追踪怪物-Tracking-Enemies" class="headerlink" title="追踪怪物(Tracking Enemies)"></a>追踪怪物(Tracking Enemies)</h1><h2 id="敌人的战斗状态划分"><a href="#敌人的战斗状态划分" class="headerlink" title="敌人的战斗状态划分"></a>敌人的战斗状态划分</h2><p>威胁可以分为以下两种：</p><ol><li>Aggressive：积极进攻</li><li>Non-Aggressive：后退和等待中</li></ol><p>这两种状态会对敌人的行为和位置产生不同的影响。Aggressive的敌人会积极尝试攻击玩家，Non-Aggressive的敌人会在离玩家有点距离的地方徘徊，等着切换为Aggressive状态。</p><p>敌人的状态可以是这两种状态的其中一种，可以想象一下功夫电影种的打斗场景，敌人都是一个接一个来进攻，而不是多个敌人一起进攻。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/%E6%88%90%E9%BE%99%E6%89%93%E6%96%97.gif"></p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/%E7%94%84%E5%AD%90%E4%B8%B9%E6%89%93%E6%96%97.gif"></p><p>为了能够追踪正确的敌人，即使玩家可以一次性和多个敌人进行战斗，玩家也必须要有办法知道哪个敌人是更具有威胁性的。</p><h2 id="Aggressive-Score"><a href="#Aggressive-Score" class="headerlink" title="Aggressive Score"></a>Aggressive Score</h2><blockquote><p>攻击性评分</p></blockquote><p>Aggressive Score由四个部分组成：0-00-0-000</p><ol><li>是否可以切换到Aggressive状态：用于确保当前不处于受击或相关状态</li><li>优先级：由策划为每一个敌人类型设置的一个数字，同时还要设置优先级的生效距离。如果超过了这个距离，那么优先级就将为了最低(应该是这么理解吧？)</li><li>是否被玩家瞄准</li><li>行动等级：依据当前是否在相机可视范围内、与相机的角度、与玩家的距离综合得出</li></ol><h2 id="Aggressive-Token"><a href="#Aggressive-Token" class="headerlink" title="Aggressive Token"></a>Aggressive Token</h2><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005924.png?x-oss-process=style/WaterMask"></p><p>为每种敌人类型设置一个数字作为Aggression token。</p><p>为当前可变为Aggressive状态的所有敌人的Aggression token值总和设置一个初始值M。每当由一个敌人变为Aggressive状态，则M减去该敌人的Aggression token值。若该敌人切出Aggressive状态，则M加上该敌人的Aggression token值。</p><p>敌人按照Aggressive Score从高到低进行排序，从排名高的敌人开始切换为Aggressive状态，直到M&lt;&#x3D;0。</p><p>上图的示例中，M的初始值为14。左列红框打了星号的代表切换为Aggressive状态，右列红框的数值就是Aggression token。从图中可以看出，当前只有最底下的哪个敌人不处于Aggressive状态。</p><p>这种方式可以很容易控制切换为Aggressive状态的敌人数量，可以通过调整M初始值的大小来调整游戏难度。</p><h2 id="敌人的站位"><a href="#敌人的站位" class="headerlink" title="敌人的站位"></a>敌人的站位</h2><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102005951.png?x-oss-process=style/WaterMask"></p><p>敌人站位方式需要切换的改革，需要配合新相机从头开始设计。</p><h2 id="确定设计方向"><a href="#确定设计方向" class="headerlink" title="确定设计方向"></a>确定设计方向</h2><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010021.png?x-oss-process=style/WaterMask"></p><p>在1~3部作品中，敌人的状态决定敌人事在站在玩家附近还是远离玩家，这样敌人就被放在两个同心圆中。没有做任何分散敌人的处理，没有地形分区的概念。较远的镜头可以让玩家看到每一个敌人，可以很容易感知到敌人的威胁。不太有攻击性的敌人偶尔会在地图边缘移动，让战斗看起来好像很智能。</p><p>但是现在的敌人可能在屏幕内也可能在屏幕外，远的敌人容易被近的敌人遮挡，因此需要确保敌人合理地分散开来。</p><h2 id="第一次尝试：基于权重的站位系统为每个敌人找到最佳位置"><a href="#第一次尝试：基于权重的站位系统为每个敌人找到最佳位置" class="headerlink" title="第一次尝试：基于权重的站位系统为每个敌人找到最佳位置"></a>第一次尝试：基于权重的站位系统为每个敌人找到最佳位置</h2><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010043.png?x-oss-process=style/WaterMask"></p><p>在玩家周围铺设多个检查点，所有检查点跟随玩家移动。每个检查点的权重根据是否在navmesh上以及是否存在通往主角的路径来评定。处于Aggressive状态的敌人会到权重较高的检查点。这样敌人会分布在主角周围，类似老版战神。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010055.png?x-oss-process=style/WaterMask"></p><p>这个方案前期使用着还行，随着时间的推移发现了一些问题，需要更有效的方案。</p><p>存在的问题：</p><ol><li>检查点权重评定变得单⼀、复杂、凌乱，难以debug</li><li>玩家和敌人不断移动，检查权重经常变得无效，敌人经常聚集在一起</li><li>玩家无法在大脑中构建敌人位置地图（mantal map）。敌人一旦不可见，玩家就会感到害怕，然后就不在变得自信和具有攻击性。这样就没战神内味了。</li></ol><h2 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h2><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010117.png?x-oss-process=style/WaterMask"></p><p>不再为每个敌人选择最佳位置，而是不让敌人进⼊糟糕的位置。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010145.png?x-oss-process=style/WaterMask"></p><p>Aggressive状态的敌人需要被约束在玩家面前的红色扇形中，让他们保持在镜头中。</p><p>Non-Aggressive状态的敌人会在玩家周围围成一个圈，像老版战神⼀样。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010258.png?x-oss-process=style/WaterMask"></p><p>每个敌人都有自己的空间，跟随自己移动，其它敌人不可以进入这个空间中。</p><p>Aggressive状态的敌人拥有一个圆柱形空间。</p><p>Non-Aggressive状态的敌人拥有一个略微弯曲的矩形空间。有利于将敌人横向散落，又不会占用过多与玩家间隔的那块空间，因为大部分情况下Non-Aggressive状态的敌人比Aggressive状态的敌人要多。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010320.png?x-oss-process=style/WaterMask"></p><p>比上一版好的地方：</p><ol><li>算法更简单</li><li>算法不容易失效</li><li>敌人的站位更好看</li></ol><p>仍然存在的问题：</p><ol><li>突然切换为Aggressive状态的敌人可能会从玩家身后走到身前，可能会吓玩家一跳，而怪怪的，好像是专门过来找打的。</li><li>玩家无法在⼤脑中构建敌人位置地图（mantal map），这个问题直到游戏快要发布的前几个月才被解决。</li></ol><h2 id="解决关键问题"><a href="#解决关键问题" class="headerlink" title="解决关键问题"></a>解决关键问题</h2><p>关键问题：敌人如何以玩家想要的方式站位</p><p>解决思路：一个敌人要么一直在镜头中，要么一直在镜头外，除非是玩家操作导致切换</p><p>额外设计：一旦一个敌人掉到的镜头外，该敌人当前处于世界空间的哪个象限就要一直在这个象限中。这样即使敌人不在玩家视野内，也可以知道它大概在什么位置（ps：问题是玩家怎么知道敌人会被固定在一个时间空间的象限中呢？）</p><p>在这之后的测试中，玩家的操作变得自信和充满攻击性，这正是他们所希望看到的。</p><h2 id="威胁指示标记"><a href="#威胁指示标记" class="headerlink" title="威胁指示标记"></a>威胁指示标记</h2><p>为了让玩家更了解镜头外的敌人在干嘛，他们考虑添加一些标记在屏幕。相比雷达或小地图，还是在HUD上做标记不容易分散玩家的注意力。他们在屏幕边缘闪烁和小箭头指示两者间权衡了利弊之后选择了小箭头的形式。 </p><p>玩家知道的越多，就越有信心，所以箭头有三种颜色：白色代表附近的敌人、红色代表正在攻击玩家的敌人、紫色代表远距离攻击的敌人。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010412.png?x-oss-process=style/WaterMask"></p><p>由于前面的站位系统做得好，所以小箭头的表现也良好，玩家容易理解。</p><h2 id="运镜辅助"><a href="#运镜辅助" class="headerlink" title="运镜辅助"></a>运镜辅助</h2><p>在激烈的战斗中使用右摇杆控制镜头会为操作额外增加一个维度的复杂度。《战神4》希望可以面向更大的玩家群体，所以需要设计一个运镜辅助机制。</p><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221102010432.png?x-oss-process=style/WaterMask"></p><p>两个机制：</p><ol><li>为敌人赋予一个权重，用于选取摄像机的聚焦点，摄像机自动调整使得聚焦点保持在视野中。</li><li>镜头自动转向玩家攻击的方向</li></ol><p>自动调整镜头达到玩家心中期待的状态不是一件容易的事情。虽然这套运镜辅助机制并不100%正确，但是可以缓解玩家不少操作压力。大部分玩家体验良好，如果玩家不喜欢也可以在设置菜单中关闭该机制。</p><hr><p>第一次写GDC解读类文章，如果有不正确的地方，欢迎大家留言指正</p><p>如果大家觉得哪个GDC分享非常好，可以留言推荐一下，合适的话我也去品品~</p>]]></content>
    
    
    <categories>
      
      <category>GDC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Game Road 写给准备进入职场的游戏人</title>
    <link href="/posts/7d2f1a5e.html"/>
    <url>/posts/7d2f1a5e.html</url>
    
    <content type="html"><![CDATA[<p>​<br>准备进入游戏公司工作对于每一个热爱游戏的人来说都是一件令人兴奋的事情，但因为陌生会伴随着不安。本文简单记录一下当年初入职场时的感受以及遇到的各种问题。</p><h1 id="适应"><a href="#适应" class="headerlink" title="适应"></a>适应</h1><p>刚刚进入职场的新人在前两个月主要做的事情是适应新环境、工作节奏和氛围。</p><p>对于部分新人来说，他可能是从其他城市来到当前这个陌生的城市。需要适应的环境不仅仅是公司的环境，包括生活的环境，例如气候，我刚刚来到杭州的时候正好是最冷的时候，作为一个在广东长大的孩子，感觉难以承受。</p><p>如果之前都是在学校敲代码，没有感受过真实生产环境下敲代码。或者之前以实习的身份来敲代码，现在用正式员工的身份敲代码。或者之前不在这家公司，而是在其他公司。我们都要适应下新的工作节奏。如果项目进度非常赶的话，节奏可能会很快，这时可能会比较吃力。我们还需要适应工作氛围。有些公司的工作氛围很沉闷压抑，自己就不要太跳。有些公司的工作氛围比较活泼，自己就可以多放开一点。</p><p>平日上班时间应该是在学习各种课程，而不是在忙着做项目相关的事情。项目进度再赶都不要给刚刚来到公司的新人安排具体业务。事情总是做不完的，要想安排的话随时都可以把新人的日常全部排满。今天修个bug，明天改个功能，短期来看总产出提升了，但是长期来看对新人是有害的。</p><p>项目进度变得这么赶是一件不正常的事情，公司应该反思一下为什么会这么赶，也许pm的排期并不合理。这个状态可以是阶段性的，不应该是长期性的。但无论如何，如果非要让刚刚来到公司的新人去赶任务，就要跟新人好好沟通。</p><p>可以从公司对待你的态度看出公司是不是重视你。如果公司重视你，它会为你作长远的培养规划，想着怎么让你在未来3~5年内跟公式共同成长。如果公司不重视你，它会急着压榨你身上的剩余价值，压榨完了就赶紧换掉。</p><p>这段时间算是一个过渡期，虽然短期来看没什么产出，但长期来看对公司有很大的价值，如果这家公司有长远眼光的话。</p><p>非常不幸的是，我刚毕业去到公司就被拉到前线去战斗了。当时项目进度非常赶，所有的新人都被拉走了，战况异常激烈。大家都快要患上PTSD了，我也差点阵亡。现在回想起来，当年的自己真热血。</p><p>新人完成过渡之后，就可以开始安排一些业务类型的任务。通过业务类型的任务可以让新人逐步了解公司的产品设计和代码。等新人慢慢上手之后可以和新人进行进一步的沟通，结合新人的意愿去调整之后的任务安排。切忌一直安排差不多的任务，时间长了降低新人的热情。也不要把一些比较恶心的锅甩给新人，我发现不少公司都喜欢将锅甩给新人。这时锅的主人会松一口气，等新人兜不住的时候就pua新人。</p><h1 id="感觉自己在打杂？"><a href="#感觉自己在打杂？" class="headerlink" title="感觉自己在打杂？"></a>感觉自己在打杂？</h1><p>大部分刚刚进入游戏研发大厂的同学都是意气风发，磨拳擦掌准备大干一场的。但是进去之后发现自己接到的任务都是一些技术含量不高的任务，这时心里就会开始产生落差，觉得自己这匹千里马没有被伯乐相中，无法施展自己的才华，不被重视。其实这种产生这种心理从某种角度来看也是一种好事，因为这说明这位同学上进、关注自身成长。</p><p>但是不必太过心急，因为刚去到一个新的环境中，同事对你还不够了解，不敢委派比较重要的任务给你。无论如何，你都要把交给自己的任务都当作重要任务来完成，不要因为一个任务很琐屑而敷衍了事。其实大部分情况下，再简单的任务都能学到新的东西，总能把它做得更好。</p><p>你执行的每一项任务都会被leader看在眼里，每一项任务都会在leader心里留下印象。你是希望不断在leader心里累积失望，还是不断在leader心里累积信任，很大程度上取决于你做事情的态度。我记得某大佬说过一句话：“能力还不够也没关系，只要你态度够好，我们就愿意培养。”</p><p>我见过心浮气躁、耐不下性子来处理事情的新人A，也见过勤勤恳恳、脚踏实地的新人B。A完成任务的速度和质量整体来看是不如B的，B做出来的内容总是给人一种一种很精致的感觉，而且时间把控得比较好，不会太快，也不会踩着时间点来。</p><p>慢慢地，leader就会将一些需要投入一定时间进行预研的项目给到B。所以一定要认真对待给到自己的每一个任务，不要以为这个任务琐屑，leader就不关注你。如果自己都觉得自己的任务不重要，就没有人会觉得你的任务重要。</p><p>如果很长一段时间（多长时间算长需要看具体情况，个人感觉4个月左右差不多了）过去了，leader还没有给到你比较重要的任务，但是自己做得已经很不错了，再继续下去提升并不大。而且因为熟练度提升了，leader派下来的任务会越来越多，压榨你每一份精力。</p><p>慢慢就会陷入到疲于应付任务，没有时间思考的状态。这种情况就要引起警觉了，如果是处于业务上升期，可以理解，但是也要有个度，毕竟每个人都要为自己负责，不要对公司过于忠诚。公司不会为你的人生负责。</p><p>这时就要跟leader进行沟通，保持信息对称。</p><p>最担心出现误解，leader所了解的信息、预期和你所了解的信息、预期不一致，但是你以为是一致的。误解会随着时间的推移慢慢被放大，导致双方工作状态不好，降低合作效率。其实你的很多问题都是沟通问题，比如对leader不满意。</p><p>在出现误解之后，为了保持信息对称，要么改变自己的想法，要么想办法说服leader。在信息对称之后，如果你和leader还是处不来，可以选择跨级沟通。如果跨级沟通还是没有办法解决的话，你懂的&#x3D; &#x3D;</p><h1 id="熟悉"><a href="#熟悉" class="headerlink" title="熟悉"></a>熟悉</h1><p>刚开始处理公司的任务时会有很多地方都是陌生的，做笔记是一个快速熟悉的好方法，而且也非常值得去做。因为这个时候不懂的东西是最多的，提升是最快的，将每一点成长都记录下来可以给后来人留下一段可以借鉴的成长经历。</p><p>有人喜欢每周一记，有人喜欢每日一记，有人喜欢每时每刻都记。我还是比较喜欢每时每刻都记，记录频率尽可能地高。因为我平时的任务都比较多，很多东西如果没有马上记下来就很容易忘记。我也因为这样漏掉了很多内容，所以非常鼓励大家养成记录的习惯。</p><p>有些工作室有着良好的记录文化，这些工作室的策划案整体质量比那些没有良好记录文化的工作要高。除了策划案质量的提升，还会带来看不见的价值。比如研发做好记录可以提升自己的研发效率、沟通效率、成长效率，这些效能的提升不容易让人察觉到是做记录带来的。</p><p>我觉得良好的记录工具是很重要的，舒适的记录环境可以让自己更爱记录。比较通用的记录工具有协同办公软件，例如某书。对于工程师来说，markdown使用起来还是很舒服的，我一般会用vscode+markdown。这些都不喜欢的话，再不济都要用notepad++，怎么都不要用windows自带的记事本来记录。不知道为什么，记事本一打开就犯困。</p><p>很多东西都可以记，比如工作流程的改进、认知的提升、技术点的突破、人生感悟、未来规划。我是那种脑子里一不小心就蹦出一个灵感的人，通过随手记录的方式可以捕捉到这些灵感。</p>]]></content>
    
    
    <categories>
      
      <category>Game Road</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GUI开发那点事</title>
    <link href="/posts/6d38ce7b.html"/>
    <url>/posts/6d38ce7b.html</url>
    
    <content type="html"><![CDATA[<p>  每个项目组的GUI开发流程都不太相同。有些项目组的流程非常落后，基本没有框架设计，都是直接代码设置UI控件，不利于迭代。做的比较好的会采用MVC相关模式进行设计，下面也只讲使用了MVC的工作流程。C由客户端同学负责实现。V由GUI同学进行制作。M和V的连接工作在理想的情况下应该也是由GUI同学进行设置，但是因为上手有些难度，没有很好地落地，所以这块最终由客户端同学进行设置。</p><p>  总体来看，GUI开发流程分为以下几个阶段。</p><p>  策划会先提出界面需求，客户端程序需要认真阅读需求文档，确保需求是完整。因为我之前遇到过策划给出不完整的需求文档，需求前后矛盾、需求细节丢失、需求模糊不清。有一次特别离谱，商城需求文档竟然不给出具体的数值设计。在需求不完整的情况下就开始做功能的工作效率是很低的，需要一边做一边问策划，有时候一个问题要半天时间策划才能给答复。</p><p>  千万不要在需求不完整的情况下展开后面的工作，跟策划和PM提了之后没有理会就提多几次。一定要让策划和PM重视前期规划工作，不然后面就会变成策划想到什么就做什么，想到一点内容就加一点内容进入，加到最后发现和前面的东西有点矛盾，又删除前面的内容。这会带来不必要的时间浪费，在极端情况下可能要推翻重来。</p><p>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-91346abb1a400b9a78d80e3cd3fe4401_b.gif"></p><p>  需求明确之后就由GUI同学输出效果图。</p><p>  等策划确认效果之后，客户端同学也要来看一下效果图。看看有没有比较奇怪的效果，对这些效果进行讨论，确定实现方案或者换效果。如果界面比较复杂，需要跟GUI同学对一下层级结构。</p><p>  进行界面资源输出。一般来说，界面资源输出工作交给GUI同学来负责，但是有些项目会将这个工作交给客户端同学。曾经待过的一个项目组就是这么干的，需要将一张半透的效果图叠在界面最上层，一点一点的拼出来。有时一个界面可以拼一天，眼睛要爆炸，我都不知道我是程序还是GUI了。无论是由谁来输出，都需要注意一下UI控件的命名，不要使用a、b、c、1、2、3之类的名字。最好可以表达出这个UI控件的类型、作用，比如LoginBtn代表这是个按钮，点击之后开始登录。</p><p>  客户端同学拿到界面资源之后，首先需要做的事情是检查UI控件摆放的层级结构是否合理。层级结构可以按照区域或者功能模块来划分，这么做的好处是可以快速定位到自己想要的UI控件，之后做UI资源迭代会轻松很多。一般一个界面的UI控件量都不会很少，即使开头很少，随着功能、效果的迭代优化也会变得越来越多。如果没有处理好UI控件摆放的层级结构，做资源迭代时寻找资源会让你怀疑人生的。</p><p>  UI界面资源处理好之后，就可以开始进行数据绑定工作了。这个过程需要将V和M关联起来，一般都会提供可视化编辑工具，不需要写代码。所以这项工作其实GUI同学也可以做的。但是因为数据绑定需要对业务需求有更深入的理解，大部分GUI同学都会觉得这不是他们应该做的内容，他们应该只负责输出好看的、满足功能需求的界面。</p><p>  如果可以由GUI同学来负责设置的话，客户端程序可以同步开始写业务逻辑代码，生产速度会更快。但是这要做好前期沟通的工作，确保大家对数据的认知是保持一致的，这个沟通的工作可能也要花费时间。综合来看，这项工作还是交给客户端程序来处理会比较好。</p><p>  客户端程序这个时候就可以开始写逻辑代码了。这里需要遵守一个原则，既然都使用了MVC框架，就不允许通过通过代码直接操作UI控件，只允许修改UI控件对应的绑定数据。在实现功能的过程中一般也不可以在修改UI界面的样式。如果非要修改，在改动比较小的情况下可以客户端程序自己改一下，然后让GUI同学过来确认下。如果改动比较大，就直接交给GUI同学进行修改。</p><p>  GUI开发工作整体难度不大，只要积极沟通就好。一般来说，如果开发时间超出预期，大部分都是因为开发过程中出现了莫名奇妙的Bug，由UI框架设计引起。针对这种情况，如果容易修复的bug可以直接进行修复。比较难修复的bug可以记录到一个专门的文档中。方便别人遇到同样的问题时可以快速找到解决方案，提升整体的开发效率，也作为之后修复bug的checklist。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>技术美术的职责</title>
    <link href="/posts/dd4c3610.html"/>
    <url>/posts/dd4c3610.html</url>
    
    <content type="html"><![CDATA[<h1 id="何为技术美术"><a href="#何为技术美术" class="headerlink" title="何为技术美术"></a>何为技术美术</h1><p>  技术美术(Technical Artist, TA)主要职责是作为美术师和程序员之间沟通合作的桥梁。因此TA需要同时兼备编码能力和美术能力，门槛较高，所以身价一般也比较高。前段时间原神的大火，进一步提升了TA的身价。TA是一个复合型工种，所以不同TA的能力侧重点会不一样。TA大致可以再细分为两种类型。一种偏向技术，驻扎在游戏引擎组。一种偏向美术，驻扎在美术支持组。</p><p>  其实还可以继续细分的。比如</p><p>  效果TA，主要负责实现具体的美术效果，比如人物描边、火焰效果、水流效果、运动模糊。</p><p>  流程TA，主要负责各种资源的导出工作，例如全局光照烘焙流程、场景分块导出流程等。</p><p>  优化TA主要负责性能优化工作，比如遮挡剔除的实现、具体效果的性能优化。</p><p>  引擎TA主要负责游戏引擎整体渲染效果的把控，定制渲染管线，所以需要对引擎非常熟悉，并且能够对团队进行引擎相关的培训。</p><p>  资产TA，需要整理、维护项目的资源，比如制定性能指标、资源检查。</p><p>  相比于客户端程序，TA跟美术的沟通更加的紧密和频繁，TA需要主动去跟美术进行沟通，不要期待美术会及时反馈问题。</p><h1 id="主要工作职责"><a href="#主要工作职责" class="headerlink" title="主要工作职责"></a>主要工作职责</h1><p>  TA最重要的工作就是实现具体的美术效果，例如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234443.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234451.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234515.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234522.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234544.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221030234610.png?x-oss-process=style/WaterMask"><br>  一般来说，实现一个美术效果分为4个阶段，方案确定、技术预研、效果实现、生产跟进。</p><p>  TA在拿到一个具体的美术效果需求时，需要针对这个需求选择合适的实现方案。为了找到合适的方案，首先需要用技术语言将需求表达出来。然后对竞品进行分析，推测对方使用了什么技术来实现该效果。再去学习与实现技术相关的资料，可以到书籍、SIGGRAPH等地方找到需要的内容。最后针对之前的工作内容整理输出一份文档，发起一次会议和相关人员对齐之后的工作内容。</p><p>  方案确定之后，TA就可以尝试在项目生产环境下对效果进行初步的实现，输出一个demo。这个过程中不需要太关注代码架构的合理性和性能问题，尽可能快就好。如果过程中使用的美术素材需要使用比较特殊的方式进行制作，就自己动手制作，不要麻烦美术。因为这个实现方案可能并不是最终的实现方案，这时让美术去学习新的制作方法性价比不高。等这个方案真的成为了最终方案时，再推广新的制作方法。但是常规的素材还是需要积极找美术配合输出的。</p><p>  在整个过程中需要习惯性地将自己想法和问题记录到文档上，可以作为备忘录，也方便之后进行技术分享。demo出来之后，可以开会跟相关人员对实现出来的效果进行讨论，确定最终是否采纳该方案。</p><p>  如果demo的效果不ok，则需要重新选择实现方案。否则将继续往前推进，这时就进入到了方案实现阶段，这个阶段主要是将demo的效果落地到项目生产环境中。在这个过程中需要依据项目规范重构demo的实现代码。如果存在较明显的性能消耗，则需要开展性能优化工作。开发特殊素材的制作工具并进行优化。输出美术制作文档，配合给出样例素材。如果有必要，则对美术进行基本的生产培训。之后还可以定期给团队成员进行技术分享，确保大家对引擎技术有着一致的认知。</p><p>  在方案正式投入生产线使用时，TA需要积极主动跟美术进行交流，确保他们在制作过程没有被问题卡住，保证开发流程通畅。效果的跟进不可以交给QA来进行，QA只负责提出异常效果，表现力需要TA亲自跟进。多向美术收集素材制作工具的使用体验，及时对工具进行改良。</p><h1 id="在各研发阶段中的具体工作职责"><a href="#在各研发阶段中的具体工作职责" class="headerlink" title="在各研发阶段中的具体工作职责"></a>在各研发阶段中的具体工作职责</h1><p>  在项目研发的不同阶段，TA的工作侧重点会有所不同。</p><p>  在项目启动阶段，TA需要配合美术同学给出可供我们项目参考的美术风格，并针对特定的效果进行技术评估，确定效果是否能实现。除了仿制出其它项目的效果之外，TA还需要为项目增加自己的特色，提升项目的市场竞争力。</p><p>  在项目Demo制作阶段，TA就需要开始实现具体效果了，可参考上文。</p><p>  在项目立项阶段，主要对效果表现力和性能进行优化。</p><p>  在中期阶段，TA需要对资产进行良好地分类、维护、升级，因为资产会逐渐变得庞大。控制好资产大小，确保被打包的资产不多也不少。为了更合理地管理好资产，需要输出一定的规范文档，并依据必要的规范实现自动资源检查。还需要关注性能表现，针对性能消耗较大的效果进行优化，如果无法优化，可以考虑直接毙掉该效果。这时还需要开始考虑上线后可能会面临的问题，针对这些问题给出解决方案。</p><p>  在内测阶段，需要及时解决运行环境中出现的性能问题、兼容性问题、效果表现力问题。</p><p>  项目上线后，可以对之前工作结果进行总结和分享，沉淀下来，为新的项目做准备。</p>]]></content>
    
    
    <categories>
      
      <category>游戏开发碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>漫谈Entity-Component-System</title>
    <link href="/posts/1abc5785.html"/>
    <url>/posts/1abc5785.html</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>  对于很多人来说，ECS只是一个可以提升性能的架构，但是我觉得ECS更强大的地方在于可以降低代码复杂度。</p><p>  在游戏项目开发的过程中，一般会使用OOP的设计方式让GameObject处理自身的业务，然后框架去管理GameObject的集合。但是使用OOP的思想进行框架设计的难点在于一开始就要构建出一个清晰类层次结构。而且在开发过程中需要改动类层次结构的可能性非常大，越到开发后期对类层次结构的改动就会越困难。</p><p>  经过一段时间的开发，总会在某个时间点开始引入多重继承。实现一个又可工作、又易理解、又易维护的多重继承类层次结构的难度通常超过其得益。因此多数游戏工作室禁止或严格限制在类层次结构中使用多重继承。若非要使用多重继承，要求一个类只能多重继承一些 简单且无父类的类(min-in class)，例如Shape和Animator。</p><p>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029194540.png?x-oss-process=style/WaterMask"></p><p>  也就是说在大型游戏项目中，OOP并不适用于框架设计。但是也不用完全抛弃OOP，只是在很大程度上，代码中的类不再具体地对应现实世界中的具体物件，ECS中类的语义变得更加抽象了。</p><p>  ECS有一个很重要的思想：数据都放在一边，需要的时候就去用，不需要的时候不要动。ECS 的本质就是数据和操作分离。传统OOP思想常常会面临一种情况，A打了B，那么到底是A主动打了B还是B被A打了，这个函数该放在哪里。但是ECS不用纠结这个问题，数据存放到Component种，逻辑直接由System接管。借着这个思想，我们可以大幅度减少函数调用的层次，进而缩短数据流传递的深度。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>  Entity由多个Component组成，Component由数据组成，System由逻辑组成。</p><h2 id="Component-组件"><a href="#Component-组件" class="headerlink" title="Component(组件)"></a>Component(组件)</h2><p>  Component是数据的集合，只有变量，没有函数，但可以有getter和setter函数。Component之间不可以直接通信。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">Component</span>&#123;<br><span class="hljs-comment">//子类将会有大量变量，以供System利用</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Entity-实体"><a href="#Entity-实体" class="headerlink" title="Entity(实体)"></a>Entity(实体)</h2><p>  Entity用来代表游戏世界中任意类型的游戏对象，宏观上Entity是一个Component实例的集合，且拥有一个全局唯一的EntityID，用于标识Entity本身。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Entity</span>&#123;<br>Int32 ID;<br>List&lt;Component&gt; components;<br>        <span class="hljs-comment">//通过观察者模式将自己注册到System可以提升System遍历的速度，因为只需要遍历已经注册的entity</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  Entity需要遵循立即创建和延迟销毁原则，销毁放在帧末执行。因为可能会出现这样的情况：systemA提出要在entityA所在位置创建一个特效，然后systemB认为需要销毁entityA。如果systemB直接销毁了entityA，那么稍后FxSystem就会拿不到entityA的位置导致特效播放失败（你可能会问为什么不直接把entityA的位置记录下来，这样就不会有问题了。这里只是简单举个例子，不要太深究(●’◡’●)）。理想的表现效果应该是，播放特效后消失。</p><h2 id="System-系统"><a href="#System-系统" class="headerlink" title="System(系统)"></a>System(系统)</h2><p>  System用来制定游戏的运行规则，只有函数，没有变量。System之间的执行顺序需要严格制定。System之间不可以直接通信。</p><p>  一个 System只关心某一个固定的Component组合，这个组合集合称为tuple。</p><p>  各个System的Update顺序要根据具体情况设置好，System在Update时都会遍历所有的Entity，如果一个Entity拥有该System的tuple中指定的所有Component实例，则对该Entity进行处理。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">System</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ASystem</span>:<span class="hljs-title">System</span>&#123;<br>    Tuple tuple;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>&#123;<br>        <span class="hljs-keyword">for</span>(Entity entity <span class="hljs-keyword">in</span> World.entitys)&#123;<br>            <span class="hljs-keyword">if</span>(entity.components中有tuple指定的所有Component实例)&#123;<br>                <span class="hljs-comment">//do something for Components</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>  一个Component会被不同System区别对待，因为每个System用到的数据可能只有其中一部分，且不一定相同。</p><h2 id="World-世界"><a href="#World-世界" class="headerlink" title="World(世界)"></a>World(世界)</h2><p>  World代表整个游戏世界，游戏会视情况来创建一个或两个World。通常情况下只有一个，但是守望先锋为了做死亡回放，有两个World，分别是liveGame和replyGame。World下面会包含所有的System实例和Entity实例。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">World</span>&#123;<br>    List&lt;System&gt; systems;                   <span class="hljs-comment">//所有System</span><br>    <span class="hljs-built_in">dictionary<span class="hljs-keyword">&lt;Int32, Entity&gt;</span></span> entitys;      <span class="hljs-comment">//所有Entity，Int32是Entity.ID</span><br><br>    <span class="hljs-comment">//由引擎帧循环驱动</span><br>    <span class="hljs-built_in">void</span> Update()&#123;<br>        <span class="hljs-keyword">for</span>(System sys <span class="hljs-keyword">in</span> systems)<br>            sys.Update();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  由ECS架构出来的游戏世界就像是一个数据库表，每个Entity对应一行，每个Component对应一列，打了✔代表Entity拥有Component。</p><table><thead><tr><th></th><th align="center">Component1</th><th align="center">Component2</th><th align="center">…</th><th align="center">ComponentN</th></tr></thead><tbody><tr><td>EntityId1</td><td align="center"></td><td align="center">✔</td><td align="center"></td><td align="center"></td></tr><tr><td>EntityId2</td><td align="center">✔</td><td align="center"></td><td align="center"></td><td align="center">✔</td></tr><tr><td>…</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>EntityIdN</td><td align="center">✔</td><td align="center">✔</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="单例Component"><a href="#单例Component" class="headerlink" title="单例Component"></a>单例Component</h2><p>  在定义一个Component时最好先搞清楚它的数据是System数据还是Entity数据。如果是System的数据，一般设计成单例Component。例如存放玩家键盘输入的 Component ，全局只需要一个，很多 System 都需要去读这个唯一的 Component 中的数据。<br>  单例Component顾名思义就是只有一个实例的Component，它只能用来存储某些System状态。单例Component在整个架构中的占比通常会很高，据说在守望先锋中占比高达40%。其实换一个角度来看，单例Component可以看成是只有一个Component的匿名Entity单例，但可以通过GetSingletonIns接口来直接访问，而不用通过EntityID。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>  守望先锋种有一个根据输入状态来决定是不是要把长期不产生输入的对象踢下线的AFKSystem，该System需要对象同时具备连接Component、输入Component等，然后AFKSystem遍历所有符合要求的对象，根据最近输入事件产生的时间，把长期没有输入事件的对象通知下线。</p><h1 id="设计需要遵循的原则"><a href="#设计需要遵循的原则" class="headerlink" title="设计需要遵循的原则"></a>设计需要遵循的原则</h1><ol><li>设计并不是从Entity开始的，而是应该从System抽象出Component，最后组装到Entity中。</li><li>设计的过程中尽量确保每个System都依赖很多Component去运行，也就是说System和Component并不是一对一的关系，而是一对多的关系。所以xxxCOM不一定有xxxSys，xxxSys不一定有xxxCOM。<ul><li>System和Component的划分很难在一开始就确定好，一般都是在实现的过程中看情况一步一步地去划分System和Component。而且最终划分出来的System和Component一般都是比较抽象的，也就是说通常不会对应现实世界中的具体物件，可以参考下图守望先锋System和Component划分的例子。<br><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029195909.png?x-oss-process=style/WaterMask" alt="20221029195909"></li></ul></li><li>System尽量不改变Component的数据。<ul><li>可以读数据完成的功能就不要写数据来完成。因为写数据会影响到使用了这些数据的模块，如果对于其它模块不熟悉的话，就会产生Bug。如果只是读数据来增加功能的话，即使出Bug也只局限于新功能中，而不会影响其它模块。这样容易管理复杂度，而且给并行处理留下了优化空间。</li></ul></li></ol><h1 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h1><p>  我在一个游戏demo里尝试使用ECS去进行设计，最大的感受是所有游戏逻辑都变得那么的合理，应对改动、扩展也变得那么的轻松。加班变少了，也不再焦虑。在开始使用ECS来架构业务层之前，我对ECS还是存有一丝疑虑的。担心会不会因为规矩太多了，导致有些功能写不出来。中途也确实因为ECS的种种规矩，导致有些功能不好写出来，需要用到一些奇技淫巧，剑走偏锋。但这些技术最终造就了一个可持续维护的、解耦合的、简洁易读的代码系统。据说守望团队在将整个游戏转成ECS之前也不确定ECS是不是真的好使。现在他们说ECS可以管理快速增长的代码复杂性，也是事后诸葛亮。</p><p>  引擎层的System比较好定义，因为引擎相关层级划分比较明确。但是游戏业务逻辑层可能会出现各种奇奇怪怪的System，因为业务层的需求千变万化，有时没有办法划分出一个对应具体业务的System。例如我曾经在业务层定义过DamageHitSystem、PointForceSys。</p><p>  推迟技术：不是非常必要马上执行的内容可以推迟到合适的时再执行，这样可以将副作用集中到一处，易于做优化。例如游戏可能会在某个瞬间产生大量的贴花，利用延迟技术可以将这些需要产生的贴花数据保存下来，稍后可以将部分重叠的贴花删除，再依据性能情况分到多个帧中去创建，可以有效平滑性能毛刺。</p><p>  如果不知道该如何去划分System，而导致System之间一定要相互通信才能完成功能，可以通过将数据放在中的一个队列里延迟处理。比如SystemA在执行Update的时候，需要执行SystemB中的逻辑。但是这个时候还没轮到SystemB执行Update，只能先将需要执行的内容保存到一个地方。但是System本身又没有数据，所以SystemA只好将需要执行的内容保存到单例Component中的一个队列里，等轮到SystemB执行Update的时候再从队列里拿出数据来执行逻辑。</p><p>  但是System之间通过单例Component有个缺点。如果向单例Component中添加太多需要延迟处理的数据，一旦出现bug就不好查了。因为这类数据是一段时间之前添加进来的，到后面才出问题的话，不好定位是何处、何时、基于什么情况添加进来的。解决方案是给每一条需要延迟处理的数据加上调用堆栈信息、时间戳、一个用于描述为什么添加进来的字符串。</p><p>  各个System都用到的公共函数可以定义在全局，也可以作为对应System的静态函数，这类函数叫做Utility函数。Utility函数涉及的Component最好尽可能少，不然需要作为参数传进函数Component会很多，导致函数调用不太雅观。Utility函数最好是无副作用的，即不对Component的数据做任何写操作，只读取数据，最后返回计算结果。要改Component的数据的话，也要交给System来改。</p><p>  函数调用堆栈的层次变浅了，因为逻辑被摊开到各个System，而System之间又禁止直接访问。代码变得扁平化，扁平化意味的函数封装少了，所以阅读、修改、扩展也很轻松。</p><p>  如果可以把整个游戏世界都抽象成数据，存档&#x2F;读档功能的实现也变得容易了。存档时只需要将所有Component数据保存下来，读档时只需要将所有Component数据加载进来，然后System照常运行。想想就觉得强大，这就是DOP的魅力。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>  模式简单</p><p>  结构清晰</p><p>  通过组合高度复用。用组合代替继承，可以像拼积木一样将任意Component组装到任意Entity中。</p><p>  扩展性强。Component和System可以随意增删。因为Component之间不可以直接访问，System之间也不可以直接访问，也就是说Component之间不存在耦合，System之间也不存在耦合。System和Component在设计原则上也不存在耦合。对于System来说，Component只是放在一边的数据，Component提供的数据足够就update，数据不够就不update。所以随时增删任意Component和System都不会导致游戏崩溃报错。</p><p>  天然与DOP(data-oriented processing)亲和。数据都被统一存放到各种各样的Component中，System直接对这些数据进行处理。函数调用堆栈深度大幅度降低，流程被弱化。</p><p>  易优化性能。因为数据都被统一存放到Component中，所以如果能够在内存中以合理的方式将所有Component聚合到连续的内存中，这样可以大幅度提升cpu cache命中率。cpu cache命中良好的情况下，Entity的遍历速度可以提升50倍，游戏对象越多，性能提升越明显。ECS的这项特性给大部分人留下了深刻印象，但是大部分人也认为这就是ECS的全部。我觉得可能是被Unity的官方演示带歪的。</p><p>  易实现多线程。由于System之间不可以直接访问，已经完全解耦，所以理论上可以为每个System分配一个线程来运行。需要注意的是，部分System的执行顺序需要严格制定，为这部分System分配线程时需要注意一下执行先后顺序。</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>  在充满限制的情况下写代码，有时速度会慢一些。但是习惯之后，后期开发速度会越来越快。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>  一个entity就是一个ID，所有组成这个entity的component将会被这个ID给标记。因为不用创建entity类，可以降低内存的消耗。如果通过以下方式来组织架构，还可以提升cpu cache命中率。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//数组下标代表entity的ID</span><br><span class="hljs-selector-tag">ComponentA</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentAs</span>;<br><span class="hljs-selector-tag">ComponentB</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentBs</span>;<br><span class="hljs-selector-tag">ComponentC</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentCs</span>;<br><span class="hljs-selector-tag">ComponentD</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">componentDs</span>;<br>...<br></code></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://gameinstitute.qq.com/community/detail/114516">《守望先锋》架构设计与网络同步 – GDC2017 精品分享实录</a></li><li><a href="http://gamadu.com/artemis/">http://gamadu.com/artemis/</a></li><li><a href="http://gameprogrammingpatterns.com/component.html">http://gameprogrammingpatterns.com/component.html</a></li><li><a href="http://t-machine.org/index.php/2014/03/08/data-structures-for-entity-systems-contiguous-memory/">http://t-machine.org/index.php/2014/03/08/data-structures-for-entity-systems-contiguous-memory/</a></li><li><a href="http://blog.lmorchard.com/2013/11/27/entity-component-system/">http://blog.lmorchard.com/2013/11/27/entity-component-system/</a> </li><li><a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html">浅谈《守望先锋》中的 ECS 构架</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏动画技术简介</title>
    <link href="/posts/49a81750.html"/>
    <url>/posts/49a81750.html</url>
    
    <content type="html"><![CDATA[<p>  动画系统是游戏中对表现力影响最大的系统之一，经过一段时间的调研，最后通过这篇文章总结下游戏动画系统。</p><h1 id="精灵动画系统"><a href="#精灵动画系统" class="headerlink" title="精灵动画系统"></a>精灵动画系统</h1><p>  精灵动画系统在早年间计算机性能还比较差的时候被广泛运用，一般作为游戏的背景而存在，比如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029175924.png?x-oss-process=style/WaterMask" alt="极品飞车系列的路边观众"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180025.png?x-oss-process=style/WaterMask" alt="NBA2K系列的观众"><br>  这些人物都是一个四边形，游戏引擎会给四边形连续贴上纹理贴图来产生动感。通常为了不暴露这是个扁的四边形，会使这些四边形一直面向摄像机。比如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180040.png?x-oss-process=style/WaterMask" alt="DOOM"><br>  这类动画系统在早期游戏中盛行，因为当时的计算机性能不够，而该系统对计算机资源的消耗非常低。现在部分手游依然会保留这类动画系统，因为手机性能有限。</p><h1 id="刚性层阶式动画"><a href="#刚性层阶式动画" class="headerlink" title="刚性层阶式动画"></a>刚性层阶式动画</h1><p>  刚性层阶式动画驱动的人物都由一堆独立的刚性物体组合而成。刚性物体指的是不会发生形变(包括缩放)的物体。然后动画系统会驱动每一个刚性物体，从而实现动画效果。最经典的例子就是1997年在PS上发售的FF7。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180105.png?x-oss-process=style/WaterMask" alt="97版FF7"><br>  这个系统驱动的是3D模型，而不再是四边形贴图，同时还能保持高效的性能和较低的内存使用量。缺点是不允许网格发生形变，整个人物会显得非常生硬。而且人物的关节位置会产生明显的“裂缝”。</p><h1 id="每顶点动画"><a href="#每顶点动画" class="headerlink" title="每顶点动画"></a>每顶点动画</h1><p>  每顶点动画需要动画师为每个顶点去k动画。工作量非常巨大，产生的数据量也非常巨大，但是可以获得非常精细的动画效果，网格的三角形产生形变。通常用于制作CG中人物的表情，一般通过硬件设备来捕捉人脸信息，再转换成顶点数据。<br>  <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><br>    <iframe src="//player.bilibili.com/player.html?aid=859596268&bvid=BV1eV4y1g7H7&cid=875385956&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe><br>  </div><br>  <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><br>    <iframe src="//player.bilibili.com/player.html?aid=559589709&bvid=BV1Re4y127Tn&cid=875387307&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe><br>  </div></p><h1 id="变形目标动画-morphing-animation"><a href="#变形目标动画-morphing-animation" class="headerlink" title="变形目标动画(morphing animation)"></a>变形目标动画(morphing animation)</h1><p>  由于每顶点动画需要保存大量的动画数据，不方便存储和使用。于是提出了变形目标动画，动画师只需要通过调整网格上所有顶点的信息制作出一些静态姿势(morph target)。这些静态姿势都是一些“极端”的姿势，例如生气、开心等。在游戏引擎中通过对这些静态姿势按时间进行线性插值即可得到动画。</p><h1 id="蒙皮动画-skinened-animation"><a href="#蒙皮动画-skinened-animation" class="headerlink" title="蒙皮动画(skinened animation)"></a>蒙皮动画(skinened animation)</h1><blockquote><p>有时也被称为骨骼动画、蒙皮骨骼动画，是一种FK</p></blockquote><p>  为了可以得到较生动的动画效果，允许网格的三角形产生形变。同时兼顾较高的性能、较低的存储空间。蒙皮动画便出现了，现在市场上几乎所有的游戏都采用蒙皮动画作为动画解决方案。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>  在蒙皮动画中有几个重要的概念。首先是骨骼(skeleton)，骨骼由关节通过一棵树的形态组织起来。如果是一个人物模型，一般以髋部为根节点，以肢体末端为叶节点，比如手指、脚指、眼睛等。skeleton本身不需要被渲染引擎渲染出来，仅由动画系统驱动。</p><p>  然后是皮肤(skin)，皮肤由多边形网格组成。而网格又由顶点构成，这些顶点将会被动画师通过设置权重绑定(bind)到若干关节上。一般每个顶点最多绑定4个关节。但不是所有的关节都会被顶点绑定，这些没有被绑定的关节又称为定位器(locator)，作为其它模型的挂接点存在。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180348.png?x-oss-process=style/WaterMask" alt="DX中skeleton的组织方式"><br>  蒙皮动画中存在几个重要的姿势(pose)，这些姿势可以矩阵或者SQT格式来保存。首先是绑定姿势，又称为T-pose，顾名思义，是动画师在给模型顶点做绑定时用的姿势。该姿势从DCC中输出之后就固定好了，在游戏运行时不会被改变。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180400.png?x-oss-process=style/WaterMask"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180408.png?x-oss-process=style/WaterMask"><br>  然后是局部姿势，它保存了当前关节在其父关节空间中的姿势。因为动画引擎直接驱动的是局部姿势，我们经常需要对局部姿势进行各种插值，所以一般不会存储为矩阵形式，而是存储为SQT形式。我们的动画片段就是由一连串的局部姿势组合起来，也就是说动画片段是一个因变量为局部姿势，自变量为时间的函数。</p><p>  最后是全局姿势，它保存了关节在其模型空间或世界空间中的姿势，具体保存形式不同的引擎有不同的做法。它是在游戏运行过程中通过联合具有父子关系的局部姿势实时生成的，算是被动画引擎间接驱动。</p><h2 id="蒙皮-skinning"><a href="#蒙皮-skinning" class="headerlink" title="蒙皮(skinning)"></a>蒙皮(skinning)</h2><p>  首先需要准备数据，每一个关节都保存着一个绑定姿势逆矩阵，以下简称IBP，该矩阵可以将物体从模型空间转换到当前关节空间。IBP是在3D模型从DCC输出后，利用T-Pose计算出来的。一次计算，无限次使用。</p><p>  动画引擎Update之后，每一个关节都会得到一个最新的局部姿势。这个时候可以进行一些额外的插值计算、程序式动画、IK等后处理过程。因为局部姿势一般保存为SQT格式，所以需要在这时转换成矩阵。</p><p>  然后我们开始计算每个关节的全局姿势矩阵，计算方法是依次连接关节本身及其所有父节点的局部姿势矩阵。</p><p>  最后IBP乘上全局姿势矩阵，就得到了蒙皮矩阵。顶点乘上蒙皮矩阵后会对顶点产生什么样的影响呢？可以这么想象：顶点原本位于模型为T-Pose时的模型空间中，乘上了IBP之后进入到关节空间中；再乘上全局姿势矩阵，这时模型摆出了由动画引擎驱动的姿势，在这个姿势下从关节空间回到模型空间。</p><p>  所以最终呈现的效果是，顶点被关节带到了特定位置。计算出所有关节的蒙皮矩阵之后，我们就得到了矩阵调色</p><p>  然后开始正式蒙皮。每个顶点都会从矩阵调色板中取得需要绑定的关节的蒙皮矩阵，然后更具动画师设定好的权重对这些矩阵进行混合。顶点乘上混合后的矩阵，这时蒙皮就完成了。</p><p>  ps：动画引擎Update时，可以通过多种方式计算出局部姿势。可以对单个动画片段进行一维线性插值实现时间性混合来得到常规的动画效果。可以对两个动画片段进行淡入&#x2F;淡出计算获得圆滑过渡、冻结过渡等过渡效果。更进一步推广，可以对多个动画片段进行N维线性插值实现自定义的混合。为了充分利用资源，可以对动画片段进行分部混合或加法混合，例如人物在Idle状态时，通过加法混合给人物加入一些小动作，使得人物更真实。例如…<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-14d7181792c45287b55129c0856b82ff_720w.gif"></p>]]></content>
    
    
    <categories>
      
      <category>游戏引擎从入门到入土</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法测试</title>
    <link href="/posts/5df9aa96.html"/>
    <url>/posts/5df9aa96.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://roudersky.com/">转载自</a></p><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><blockquote><p>引用</p><blockquote><p>引用中的引用</p></blockquote></blockquote><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><hr><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><hr><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><hr><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><p>这是正常的文字</p><p><em>斜体文本</em></p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><strong>粗体文本</strong></p><p><em><strong>粗斜体文本</strong></em></p><p><em><strong>粗斜体文本</strong></em></p><p><del>这是加删除线的文字</del></p><p>$ \sum_{i&#x3D;1}^n a_i&#x3D;0 $</p><p>$$ \sum_{i&#x3D;1}^n a_i&#x3D;0 $$</p><p><code>int a;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>  <span class="hljs-comment">/* An annoying &quot;Hello World&quot; example */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0xFFFF</span>; i++)<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br><br>  <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  unordered_map &lt;string, vector&lt;string&gt; &gt; m;<br>  m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;\\\\&quot;</span>; <span class="hljs-comment">// this is an error</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-2e3</span> + <span class="hljs-number">12l</span>;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">val s = &quot;hello Markdown&quot;println( s )</code></pre><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><p>$$<br>\begin{vmatrix}<br>  \frac{cot\frac{FOV}{2}}{Aspect} &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; cot\frac{FOV}{2} &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; -\frac{Far+Near}{Far-Near} &amp; -\frac{2 \cdot Near \cdot Far}{Far-Near} \<br>  0 &amp; 0 &amp; -1 &amp; 0<br>\end{vmatrix}<br>$$</p><ul><li><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029173905.png?x-oss-process=style/WaterMask" alt="20221029173905"></li><li><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/%E4%B8%80%E8%84%9A%E6%89%AB%E5%BC%80.gif" alt="一脚扫开"></li></ul><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=894986163&bvid=BV15P4y1T7nS&cid=555347982&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
