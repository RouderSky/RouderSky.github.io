<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>游戏动画技术简介</title>
    <link href="/posts/49a81750.html"/>
    <url>/posts/49a81750.html</url>
    
    <content type="html"><![CDATA[<p>  动画系统是游戏中对表现力影响最大的系统之一，经过一段时间的调研，最后通过这篇文章总结下游戏动画系统。</p><h1 id="精灵动画系统"><a href="#精灵动画系统" class="headerlink" title="精灵动画系统"></a>精灵动画系统</h1><p>  精灵动画系统在早年间计算机性能还比较差的时候被广泛运用，一般作为游戏的背景而存在，比如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029175924.png?x-oss-process=style/WaterMask" alt="极品飞车系列的路边观众"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180025.png?x-oss-process=style/WaterMask" alt="NBA2K系列的观众"><br>  这些人物都是一个四边形，游戏引擎会给四边形连续贴上纹理贴图来产生动感。通常为了不暴露这是个扁的四边形，会使这些四边形一直面向摄像机。比如<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180040.png?x-oss-process=style/WaterMask" alt="DOOM"><br>  这类动画系统在早期游戏中盛行，因为当时的计算机性能不够，而该系统对计算机资源的消耗非常低。现在部分手游依然会保留这类动画系统，因为手机性能有限。</p><h1 id="刚性层阶式动画"><a href="#刚性层阶式动画" class="headerlink" title="刚性层阶式动画"></a>刚性层阶式动画</h1><p>  刚性层阶式动画驱动的人物都由一堆独立的刚性物体组合而成。刚性物体指的是不会发生形变(包括缩放)的物体。然后动画系统会驱动每一个刚性物体，从而实现动画效果。最经典的例子就是1997年在PS上发售的FF7。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180105.png?x-oss-process=style/WaterMask" alt="97版FF7"><br>  这个系统驱动的是3D模型，而不再是四边形贴图，同时还能保持高效的性能和较低的内存使用量。缺点是不允许网格发生形变，整个人物会显得非常生硬。而且人物的关节位置会产生明显的“裂缝”。</p><h1 id="每顶点动画"><a href="#每顶点动画" class="headerlink" title="每顶点动画"></a>每顶点动画</h1><p>  每顶点动画需要动画师为每个顶点去k动画。工作量非常巨大，产生的数据量也非常巨大，但是可以获得非常精细的动画效果，网格的三角形产生形变。通常用于制作CG中人物的表情，一般通过硬件设备来捕捉人脸信息，再转换成顶点数据。<br>  <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><br>    <iframe src="//player.bilibili.com/player.html?aid=859596268&bvid=BV1eV4y1g7H7&cid=875385956&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe><br>  </div><br>  <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><br>    <iframe src="//player.bilibili.com/player.html?aid=559589709&bvid=BV1Re4y127Tn&cid=875387307&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe><br>  </div></p><h1 id="变形目标动画-morphing-animation"><a href="#变形目标动画-morphing-animation" class="headerlink" title="变形目标动画(morphing animation)"></a>变形目标动画(morphing animation)</h1><p>  由于每顶点动画需要保存大量的动画数据，不方便存储和使用。于是提出了变形目标动画，动画师只需要通过调整网格上所有顶点的信息制作出一些静态姿势(morph target)。这些静态姿势都是一些“极端”的姿势，例如生气、开心等。在游戏引擎中通过对这些静态姿势按时间进行线性插值即可得到动画。</p><h1 id="蒙皮动画-skinened-animation"><a href="#蒙皮动画-skinened-animation" class="headerlink" title="蒙皮动画(skinened animation)"></a>蒙皮动画(skinened animation)</h1><blockquote><p>有时也被称为骨骼动画、蒙皮骨骼动画，是一种FK</p></blockquote><p>  为了可以得到较生动的动画效果，允许网格的三角形产生形变。同时兼顾较高的性能、较低的存储空间。蒙皮动画便出现了，现在市场上几乎所有的游戏都采用蒙皮动画作为动画解决方案。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>  在蒙皮动画中有几个重要的概念。首先是骨骼(skeleton)，骨骼由关节通过一棵树的形态组织起来。如果是一个人物模型，一般以髋部为根节点，以肢体末端为叶节点，比如手指、脚指、眼睛等。skeleton本身不需要被渲染引擎渲染出来，仅由动画系统驱动。</p><p>  然后是皮肤(skin)，皮肤由多边形网格组成。而网格又由顶点构成，这些顶点将会被动画师通过设置权重绑定(bind)到若干关节上。一般每个顶点最多绑定4个关节。但不是所有的关节都会被顶点绑定，这些没有被绑定的关节又称为定位器(locator)，作为其它模型的挂接点存在。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180348.png?x-oss-process=style/WaterMask" alt="DX中skeleton的组织方式"><br>  蒙皮动画中存在几个重要的姿势(pose)，这些姿势可以矩阵或者SQT格式来保存。首先是绑定姿势，又称为T-pose，顾名思义，是动画师在给模型顶点做绑定时用的姿势。该姿势从DCC中输出之后就固定好了，在游戏运行时不会被改变。<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180400.png?x-oss-process=style/WaterMask" alt="20221029180400"><br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029180408.png?x-oss-process=style/WaterMask" alt="20221029180408"><br>  然后是局部姿势，它保存了当前关节在其父关节空间中的姿势。因为动画引擎直接驱动的是局部姿势，我们经常需要对局部姿势进行各种插值，所以一般不会存储为矩阵形式，而是存储为SQT形式。我们的动画片段就是由一连串的局部姿势组合起来，也就是说动画片段是一个因变量为局部姿势，自变量为时间的函数。</p><p>  最后是全局姿势，它保存了关节在其模型空间或世界空间中的姿势，具体保存形式不同的引擎有不同的做法。它是在游戏运行过程中通过联合具有父子关系的局部姿势实时生成的，算是被动画引擎间接驱动。</p><h2 id="蒙皮-skinning"><a href="#蒙皮-skinning" class="headerlink" title="蒙皮(skinning)"></a>蒙皮(skinning)</h2><p>  首先需要准备数据，每一个关节都保存着一个绑定姿势逆矩阵，以下简称IBP，该矩阵可以将物体从模型空间转换到当前关节空间。IBP是在3D模型从DCC输出后，利用T-Pose计算出来的。一次计算，无限次使用。</p><p>  动画引擎Update之后，每一个关节都会得到一个最新的局部姿势。这个时候可以进行一些额外的插值计算、程序式动画、IK等后处理过程。因为局部姿势一般保存为SQT格式，所以需要在这时转换成矩阵。</p><p>  然后我们开始计算每个关节的全局姿势矩阵，计算方法是依次连接关节本身及其所有父节点的局部姿势矩阵。</p><p>  最后IBP乘上全局姿势矩阵，就得到了蒙皮矩阵。顶点乘上蒙皮矩阵后会对顶点产生什么样的影响呢？可以这么想象：顶点原本位于模型为T-Pose时的模型空间中，乘上了IBP之后进入到关节空间中；再乘上全局姿势矩阵，这时模型摆出了由动画引擎驱动的姿势，在这个姿势下从关节空间回到模型空间。</p><p>  所以最终呈现的效果是，顶点被关节带到了特定位置。计算出所有关节的蒙皮矩阵之后，我们就得到了矩阵调色</p><p>  然后开始正式蒙皮。每个顶点都会从矩阵调色板中取得需要绑定的关节的蒙皮矩阵，然后更具动画师设定好的权重对这些矩阵进行混合。顶点乘上混合后的矩阵，这时蒙皮就完成了。</p><p>  ps：动画引擎Update时，可以通过多种方式计算出局部姿势。可以对单个动画片段进行一维线性插值实现时间性混合来得到常规的动画效果。可以对两个动画片段进行淡入&#x2F;淡出计算获得圆滑过渡、冻结过渡等过渡效果。更进一步推广，可以对多个动画片段进行N维线性插值实现自定义的混合。为了充分利用资源，可以对动画片段进行分部混合或加法混合，例如人物在Idle状态时，通过加法混合给人物加入一些小动作，使得人物更真实。例如…<br>  <img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/v2-14d7181792c45287b55129c0856b82ff_720w.gif" alt="v2-14d7181792c45287b55129c0856b82ff_720w"></p>]]></content>
    
    
    <categories>
      
      <category>游戏引擎从入门到入土</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown语法测试</title>
    <link href="/posts/5df9aa96.html"/>
    <url>/posts/5df9aa96.html</url>
    
    <content type="html"><![CDATA[<h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><blockquote><p>引用</p><blockquote><p>引用中的引用</p></blockquote></blockquote><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><hr><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><hr><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><hr><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><p>这是正常的文字</p><p><em>斜体文本</em></p><p><em>斜体文本</em></p><p><strong>粗体文本</strong></p><p><strong>粗体文本</strong></p><p><em><strong>粗斜体文本</strong></em></p><p><em><strong>粗斜体文本</strong></em></p><p><del>这是加删除线的文字</del></p><p>$ \sum_{i&#x3D;1}^n a_i&#x3D;0 $</p><p>$$ \sum_{i&#x3D;1}^n a_i&#x3D;0 $$</p><p><code>int a;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br><br>  <span class="hljs-comment">/* An annoying &quot;Hello World&quot; example */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">0xFFFF</span>; i++)<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br><br>  <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;\n&#x27;</span>;<br>  unordered_map &lt;string, vector&lt;string&gt; &gt; m;<br>  m[<span class="hljs-string">&quot;key&quot;</span>] = <span class="hljs-string">&quot;\\\\&quot;</span>; <span class="hljs-comment">// this is an error</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-2e3</span> + <span class="hljs-number">12l</span>;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">val s = &quot;hello Markdown&quot;println( s )</code></pre><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><p>$$<br>\begin{vmatrix}<br>  \frac{cot\frac{FOV}{2}}{Aspect} &amp; 0 &amp; 0 &amp; 0 \<br>  0 &amp; cot\frac{FOV}{2} &amp; 0 &amp; 0 \<br>  0 &amp; 0 &amp; -\frac{Far+Near}{Far-Near} &amp; -\frac{2 \cdot Near \cdot Far}{Far-Near} \<br>  0 &amp; 0 &amp; -1 &amp; 0<br>\end{vmatrix}<br>$$</p><ul><li><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/20221029173905.png?x-oss-process=style/WaterMask" alt="20221029173905"></p></li><li><p><img src="https://article-pic-res.oss-cn-hangzhou.aliyuncs.com/imgs/%E4%B8%80%E8%84%9A%E6%89%AB%E5%BC%80.gif" alt="一脚扫开"></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/417640759">参考资料1</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/430541328">参考资料2</a></p></li></ul><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=894986163&bvid=BV15P4y1T7nS&cid=555347982&page=1&high_quality=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
